/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:timedelta:LinuxCNC HAL component that measures thread scheduling timing behavior");
MODULE_INFO(linuxcnc, "pin:jitter:s32:0:out:Worst-case scheduling error (in ns).  This is the largest discrepancy between ideal thread period, and actual time between sequential runs of this component.  This uses the absolute value of the error, so 'got run too early' and 'got run too late' both show up as positive jitter.:0:None");
MODULE_INFO(linuxcnc, "pin:current_jitter:s32:0:out:Scheduling error (in ns) of the current invocation.  This is the discrepancy between ideal thread period, and actual time since the previous run of this component.  This uses the absolute value of the error, so 'got run too early' and 'got run too late' both show up as positive jitter.:0:None");
MODULE_INFO(linuxcnc, "pin:current_error:s32:0:out:Scheduling error (in ns) of the current invocation.  This is the discrepancy between ideal thread period, and actual time since the previous run of this component.  This does not use the absolute value of the error, so 'got run too early' shows up as negative error and 'got run too late' shows up as positive error.:0:None");
MODULE_INFO(linuxcnc, "pin:min_:s32:0:out:Minimum time (in ns) between sequential runs of this component.:0:None");
MODULE_INFO(linuxcnc, "pin:max_:s32:0:out:Maximum time (in ns) between sequential runs of this component.:0:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in:Set this pin to True, then back to False, to reset some of the statistics.:None:None");
MODULE_INFO(linuxcnc, "pin:out:s32:0:out:Time (in ns) since the previous run of this component.  This should ideally be equal to the thread period.:None:None");
MODULE_INFO(linuxcnc, "pin:err:s32:0:out:Cumulative time error (in ns).  Probably not useful.:0:None");
MODULE_INFO(linuxcnc, "pin:avg_err:float:0:out:The average scheduling error (in ns).:0:None");
MODULE_INFO(linuxcnc, "funct:_:0:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Jeff Epler");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_s32_t *jitter_p;
    hal_s32_t *current_jitter_p;
    hal_s32_t *current_error_p;
    hal_s32_t *min__p;
    hal_s32_t *max__p;
    hal_bit_t *reset_p;
    hal_s32_t *out_p;
    hal_s32_t *err_p;
    hal_float_t *avg_err_p;
    rtapi_s64 last_p;

    int first_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_s32_newf(HAL_OUT, &(inst->jitter_p), comp_id,
        "%s.jitter", prefix);
    if(r != 0) return r;
    *(inst->jitter_p) = 0;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->current_jitter_p), comp_id,
        "%s.current-jitter", prefix);
    if(r != 0) return r;
    *(inst->current_jitter_p) = 0;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->current_error_p), comp_id,
        "%s.current-error", prefix);
    if(r != 0) return r;
    *(inst->current_error_p) = 0;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->min__p), comp_id,
        "%s.min", prefix);
    if(r != 0) return r;
    *(inst->min__p) = 0;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->max__p), comp_id,
        "%s.max", prefix);
    if(r != 0) return r;
    *(inst->max__p) = 0;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset_p), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->out_p), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->err_p), comp_id,
        "%s.err", prefix);
    if(r != 0) return r;
    *(inst->err_p) = 0;
    r = hal_pin_float_newf(HAL_OUT, &(inst->avg_err_p), comp_id,
        "%s.avg-err", prefix);
    if(r != 0) return r;
    *(inst->avg_err_p) = 0;
    inst->last_p = 0.0;
    inst->first_p = 1.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 0, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of timedelta");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of timedelta");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("timedelta");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "timedelta.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef jitter
#undef jitter_ptr
#define jitter_ptr (__comp_inst->jitter_p)
#define jitter (*__comp_inst->jitter_p)
#undef current_jitter
#undef current_jitter_ptr
#define current_jitter_ptr (__comp_inst->current_jitter_p)
#define current_jitter (*__comp_inst->current_jitter_p)
#undef current_error
#undef current_error_ptr
#define current_error_ptr (__comp_inst->current_error_p)
#define current_error (*__comp_inst->current_error_p)
#undef min_
#undef min__ptr
#define min__ptr (__comp_inst->min__p)
#define min_ (*__comp_inst->min__p)
#undef max_
#undef max__ptr
#define max__ptr (__comp_inst->max__p)
#define max_ (*__comp_inst->max__p)
#undef reset
#undef reset_ptr
#define reset_ptr (__comp_inst->reset_p)
#define reset (0+*__comp_inst->reset_p)
#undef out
#undef out_ptr
#define out_ptr (__comp_inst->out_p)
#define out (*__comp_inst->out_p)
#undef err
#undef err_ptr
#define err_ptr (__comp_inst->err_p)
#define err (*__comp_inst->err_p)
#undef avg_err
#undef avg_err_ptr
#define avg_err_ptr (__comp_inst->avg_err_p)
#define avg_err (*__comp_inst->avg_err_p)
#undef last
#define last (__comp_inst->last_p)
#undef first
#define first (__comp_inst->first_p)


FUNCTION(_) {
#line 28 "/home/end/projects/linuxcnc/src/hal/components/timedelta.comp"
#undef max
#define max(a,b) ((a)>(b)?(a):(b))

rtapi_s64 now = rtapi_get_time();

if(last != 0) {
        rtapi_s64 del = (now - last);
        out = del;

	err = err + del - period;
	if(first) {
		first = 0;
		min_ = max_ = del;
		jitter = 0;
	} else {
		if(del < min_) min_ = del;
		if(del > max_) max_ = del;
		jitter = max(max_ - period, period - min_);
		current_jitter = max(del - period, period - del);
		current_error = del - period;
	}
	count++;
	avg_err = err / (double)count;
}

if(reset) { first = 1; last = 0; out = 0; jitter = 0; max_ = 0; }
else last = now;
}

static int __comp_get_data_size(void) { return 0; }
