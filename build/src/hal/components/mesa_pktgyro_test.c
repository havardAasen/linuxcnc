/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#include "hal/drivers/mesa-hostmot2/hostmot2.h"
#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:mesa_pktgyro_test:PktUART simple test with Microstrain 3DM-GX3-15 gyro");
MODULE_INFO(linuxcnc, "descr:This component is written in order to test\nthe PktUART driver for Mesa. It resembles partly Andy Pugh's mesa_uart.comp .\n\nThis module uses the names= mode of loadrt declaration to specify which PktUART\ninstances to enable. A check is included to ensure that the count= option is\nnot used instead.\nFor simplicity we test only one PktUART instance, therefore load the component\nlike this:\n\n\\fB loadrt mesa_uart names=hm2_5i25.0.pktuart.0\\fR\n\nThe PktUART instance names are printed to the dmesg buffer during the Hostmot2\nsetup sequence, one for each PktUART instance included in the bitfile loaded to\neach installed card during the Hostmot2 setup sequence. Type \"dmesg\" at the\nterminal prompt to view the output.\nIf you want to work with more than one PktUART instance, consult Andy Pugh's\nmesa_uart.comp\n\nIn order to compile and install do:\n\\fB halcompile --install src/hal/drivers/mesa_pktgyro_test.comp\\fR\n\nThe component exports only one function, namely receive, which needs to be added\nto a realtime thread.\nTo test this component  set DEBUG=5 before and execute this HAL script:\n\\fB loadrt hostmot2\\fR\n\\fB loadrt hm2_pci\\fR\n\\fB loadrt mesa_pktgyro_test names=hm2_5i25.0.pktuart.0\\fR\n\\fB loadrt threads name1=test1 period1=10000000\\fR\n\\fB addf hm2_5i25.0.pktuart.0.receive test1\\fR\n\\fB start\\fR\n\nCheck linuxcnc.log for debug output.\n\n");
MODULE_INFO(linuxcnc, "author:Boris Skegin");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "pin:rxbytes:s32:0:out:Number of Bytes received or negative Error code:None:None");
MODULE_INFO(linuxcnc, "funct:receive:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_s32_t *rxbytes_p;
    char *name_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void receive(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->rxbytes_p), comp_id,
        "%s.rxbytes", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.receive", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))receive, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of mesa_pktgyro_test");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of mesa_pktgyro_test");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("mesa_pktgyro_test");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "mesa-pktgyro-test.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef rxbytes
#undef rxbytes_ptr
#define rxbytes_ptr (__comp_inst->rxbytes_p)
#define rxbytes (*__comp_inst->rxbytes_p)
#undef name
#define name (__comp_inst->name_p)


#line 54 "/home/end/projects/linuxcnc/src/hal/components/mesa_pktgyro_test.comp"



#define BAUDRATE (115200)



/* This uses the RTAPI_MP_ARRAY_STRING macro to load the list of PktUART channels
into an array. This is copied into the *name string of each */

char *pktuart_chans[4] = {0,};
RTAPI_MP_ARRAY_STRING(pktuart_chans, 2, "PktUART Channel names");

static hostmot2_t* hm2=NULL;



FUNCTION(receive){
	rtapi_u16 max_frame_length = 20;
	rtapi_u8 num_frames = 20;
	unsigned char Replyd3[num_frames*max_frame_length];
	rtapi_u16 frame_sizes3[20];
	rxbytes=hm2_pktuart_read(name, Replyd3, &num_frames, &max_frame_length, frame_sizes3);
	rtapi_print_msg(RTAPI_MSG_INFO, "PktUART receive: got %d bytes, %d frames\n", rxbytes, num_frames);

	//Print out the actual frame sizes
	int i;
	for(i=0;i<num_frames; i++) {
	    rtapi_print_msg(RTAPI_MSG_INFO, "Rec frame %d: size %d bytes\n", i+1 , frame_sizes3[i]);
		}
	rtapi_print_msg(RTAPI_MSG_INFO, "\n");

	// Print out ACK replies for the frames sent out
	// from EXTRA_SETUP function
	int k=0;
	int bytes_total = 0;
	while(k <num_frames) {
		        int j=0;
	            while(j<=frame_sizes3[k]-1) {
				   rtapi_print_msg(RTAPI_MSG_INFO, "Rec frame %d, byte %d 0x%.2x", k+1 , bytes_total+j , Replyd3[bytes_total+j]);
				   j++;
				}
		   bytes_total = bytes_total + frame_sizes3[k];
		   rtapi_print_msg(RTAPI_MSG_INFO, "\n");
		   k++;
	}



}

EXTRA_SETUP(){ // the names parameters are passed in 'prefix'.
	if (prefix[0] == 'm'){ // should be the 'm' of hm2_....
		rtapi_print_msg(0, "mesa_pktuart_test can not be loaded using the 'count' "
						"parameter, see man mesa_uart for details\n");
		return -1;
	}
	name = prefix;


	/* 115200bps - default value from MIP Monitor Systems Settings */


	 rtapi_print_msg(RTAPI_MSG_INFO, "Set up PktUART now\n");

	/* Check buff = (u32)((bitrate * 1048576.0)/inst->clock_freq);
	   Bitrate is (RXBitrate_Register_Value/1048576)*ClockLow */
	/*  http://freeby.mesanet.com/regmap
	  The PktUARTxMode register is used for setting and checking the
	  PktUARTx's operation mode, timing and status:
	  Bit  21	       FrameBuffer Has Data
	  Bits 20..16      Frames to send
	  Bits 15..8       InterFrame delay in bit times
	  Bit  7	       Tr Logic active (not an error)
	  Bit  6	       Drive Enable bit (enables external RS-422/485 Driver when set)
	  Bit  5	       Drive enable Auto (Automatic external drive enable)
	  Bit  4	       unused
	  Bits 3..0        Drive enable delay (delay from asserting drive enable
					   to start of data transmit. In CLock Low periods
	*/

	 /* http://freeby.mesanet.com/regmap
	  The PktUARTrMode register is used for setting and checking the PktUARTr's
	  operation mode, timing, and status
	  Bit  21	       FrameBuffer has data
	  Bits 20..16      Frames received
	  Bits 15..8       InterFrame delay in bit times
	  Bit  7	       Rx Logic active ( not an error)
	  Bit  6	       RXMask
	  Bit  5	       Unused
	  Bit  4	       RCFIFO Error
	  Bit  3	       RXEnable (must be set to receive packets)
	  Bit  2	       RXMask Enable (enables input data masking when transmitting)
	  Bit  1	       Overrun error (no stop bit when expected) (sticky)
	  Bit  0	       False Start bit error (sticky)
	*/


	/*
	   In case our device is streaming data from the very beginning,
	   at first we do not set RXEnable but clear Rx and Tx registers.
	   Then we read out whatever is in the buffer, send the DISABLE STREAM
	   datagram and only then set RXEnable bit.
	*/
	int retval=hm2_pktuart_setup(name, BAUDRATE , 0x0ff20,  0x007f00,1,1);
	if (retval<0)
	{
	    rtapi_print_msg(1, "PktUART for gyro setup problem: %d\n", retval);
	    return -1;
	}

	/*
	  We expect the max frame length to be 58 byte if the gyro is
	  streaming data from the beginning,
	  but in case the InterFrame delay is not appropriate,
	  the frame size can be longer.
	  Anyway as long as the array size we pass to hm2_pktuart_read
	  is big enough, we can read everything which is in the Rx buffer.
	*/
	rtapi_u16 max_frame_length = 58*2;
	rtapi_u8 num_frames = 20;

	// If Rx buffer <= 1024 bytes, than 2*58*20 bytes of read1 array are enough
	unsigned char read1[num_frames*max_frame_length];
	rtapi_u16 read1_sizes[num_frames];

	// read out as many frames as possible
	retval=hm2_pktuart_read(name, read1, &num_frames, &max_frame_length, read1_sizes);

	rtapi_print_msg(RTAPI_MSG_INFO, "PktUART after first read: got %d bytes\n", retval);



	//Print out the actual frame sizes
	int i;
	for(i=0;i<num_frames; i++) {
	    rtapi_print_msg(RTAPI_MSG_INFO, "Reply frame %d: size %d bytes\n", i+1 , read1_sizes[i]);
	}

	int k=0;
	int bytes_total=0;
	while(k < num_frames) {
		  int j=0;
	      while(j<read1_sizes[k]) {
				rtapi_print_msg(RTAPI_MSG_INFO, "Reply frame %d, byte %d 0x%.2x", k+1 , bytes_total+j , read1[bytes_total+j]);
				j++;
		  }
		  bytes_total = bytes_total + read1_sizes[k];
		  rtapi_print_msg(RTAPI_MSG_INFO, "\n");
		  k++;
	}
	// We have read out everything we could
	rtapi_print_msg(RTAPI_MSG_INFO, "%s: read all of the buffer\n", name);


	// Test the exported hm2_get_pktuart function
	retval = hm2_get_pktuart(&hm2, name);
	if (retval < 0)
	{
	   rtapi_print_msg(RTAPI_MSG_ERR, "%s hm2_get_pktuart: smth. is wrong. \n", name);
	   return -1;
	}

	// Now we set RxEnable bit and clear Rx/Tx registers
	retval=hm2_pktuart_setup(name, BAUDRATE , 0x0ff20,  0x007f08,1,1);
	if (retval<0)
	{
	 rtapi_print_msg(1, "PktUART for gyro setup problem: %d\n", retval);
	 return -1;
	}

	/*
	Disable the IMU/AHRS data-stream "7565 0C05 0511 0101 0003 19"
	In order to test the hm2_pktuart_send function
	we want to send out 16 DISABLE STREAM datagrams
	and receive 16 ACK datagrams as replies.
	*/

	unsigned char disable16[11*16] ={
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,

	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,

	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,

	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19,
	0x75, 0x65, 0x0C,0x05,  0x05,0x11, 0x01,0x01, 0x00, 0x03, 0x19
	};
	rtapi_u16 disable_size16[16]={11,11,11,11, 11,11,11,11, 11,11,11,11, 11,11,11,11};
	num_frames = 16;
	retval=hm2_pktuart_send(name, disable16, &num_frames, disable_size16);
	rtapi_print_msg(RTAPI_MSG_INFO, "%s sent: bytes %d, frames %u\n", name, retval, num_frames);



	/*
	We assume a bit time to be 10 us/bit at 115200 bit/s baud rate for simplicity.
	Try to estimate the total time for sending out 16 frames and receiving
	16 reply frames:

	16 Frames * 10 bits/byte * 10 us/bit*11 bytes + 15*255*10 us/bit (Tx Interfame delay) +
	+ 16 Frames * 10 bits/byte * 10 us/bit*10 bytes + 15*255*10 us/bit (Rx Interfame delay) =
	= 17600 + 38250 + 16000 + 38250 = 110100 us at least as the gyro needs to process
	each DISABLE STREAM datagram and "compute" an ACK reply.

	This wait time might be too long for  EXTRA_SETUP function,
	that's why we read  out the ACK reply frames in the receive function
	attached to a thread cycle of 10000 us , as we need about
	10 bits/byte * 10 us/bit*10 bytes + 255*10 us/bit = 1000 + 2550 = 3550 us
	for receiving an ACK frame of 10 bytes at 115200 bit/s baud rate .
	*/


	return 0;
}


int get_count(void){
	int i;
	for (i= 0; pktuart_chans[i] != NULL && i < 2 ; i++){}
	return i;
}

static int __comp_get_data_size(void) { return 0; }
