/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:demux:Select one of several output pins by integer and/or or individual bits.");
MODULE_INFO(linuxcnc, "descr:This component creates a number of output bits defined\nby the \"personality\" command-line parameter. One of these bits will be\nset based on interpreting the bit-inputs as a binary number and then\nadding on the integer input. Most uses will use only one\nor the other, but it is possible to use the bits as a \"\"shift\"\" if\nrequired.\nAn optional operating mode is enabled by setting the \"bargraph\"\nparameter to true, in this case all bits up to the selected bit will be\nset, as might be required for an LED bargraph display.");
MODULE_INFO(linuxcnc, "pin:sel-bit-##:bit:5:in:Binary-number bit selectors:None:None");
MODULE_INFO(linuxcnc, "pin:sel-u32:u32:0:in:Integer selection input:None:None");
MODULE_INFO(linuxcnc, "pin:out-##:bit:(32, 'personality'):out:The set of output bits:None:None");
MODULE_INFO(linuxcnc, "param:bargraph:bit:0:rw::0:None");
MODULE_INFO(linuxcnc, "license:GPL 2+");
MODULE_INFO(linuxcnc, "author:Andy Pugh");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL 2+");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *sel_bit_p[5];
    hal_u32_t *sel_u32_p;
    hal_bit_t *out_p[32];
    hal_bit_t bargraph_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    for(j=0; j < (5); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->sel_bit_p[j]), comp_id,
            "%s.sel-bit-%02d", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_u32_newf(HAL_IN, &(inst->sel_u32_p), comp_id,
        "%s.sel-u32", prefix);
    if(r != 0) return r;
    if((personality) > (32)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin out-##: Requested size %d exceeds max size %d\n",(int)personality, (int)32);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->out_p[j]), comp_id,
            "%s.out-%02d", prefix, j);
        if(r != 0) return r;
    }
    r = hal_param_bit_newf(HAL_RW, &(inst->bargraph_p), comp_id,
        "%s.bargraph", prefix);
    inst->bargraph_p = 0;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of demux");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of demux");
static int personality[64] = {32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each demux");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("demux");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "demux.%d", i);
            r = export(buf, i, p_value("demux", buf, i) );
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx, p_value("demux", buf, idx) );
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef sel_bit
#undef sel_bit_ptr
#define sel_bit_ptr(i) (__comp_inst->sel_bit_p[i])
#define sel_bit(i) (0+*(__comp_inst->sel_bit_p[i]))
#undef sel_u32
#undef sel_u32_ptr
#define sel_u32_ptr (__comp_inst->sel_u32_p)
#define sel_u32 (0+*__comp_inst->sel_u32_p)
#undef out
#undef out_ptr
#define out_ptr(i) (__comp_inst->out_p[i])
#define out(i) (*(__comp_inst->out_p[i]))
#undef bargraph
#define bargraph (__comp_inst->bargraph_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 26 "/home/end/projects/linuxcnc/src/hal/components/demux.comp"

FUNCTION(_){
    int i, bit;

    bit = sel_u32 + sel_bit(0) + (sel_bit(1) << 1) + (sel_bit(2) << 2)
          + (sel_bit(3) << 3) + (sel_bit(4) << 4);
    if (bit >= personality) bit = personality - 1;
    for (i = 0; i < personality ; i++) {
        out(i) = (bargraph) ? (bit > i) : (bit == i);
    }
}

static int __comp_get_data_size(void) { return 0; }
