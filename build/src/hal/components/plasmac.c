/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:plasmac:A plasma cutter controller");
MODULE_INFO(linuxcnc, "descr:\n\nA plasma cutting table control component for use with the LinuxCNC V2.8 or later.\n\n.I VERSION:\n.br\n1.236\n\n.I SUMMARY:\n.br\nUsage of this component is demonstrated in the QtPlasmaC example configurations included with LinuxCNC.\n\n.I DISCLAIMER:\n.br\nTHE AUTHOR OF THIS SOFTWARE ACCEPTS ABSOLUTELY NO LIABILITY FOR ANY HARM OR LOSS RESULTING FROM ITS USE.\n\nIT IS EXTREMELY UNWISE TO RELY ON SOFTWARE ALONE FOR SAFETY.\n\nAny machinery capable of harming persons must have provisions for completely stopping all motors and moving parts etc. before persons enter any danger area.\n\nAll machinery must be designed to comply with local and national safety codes, and the author of this software can not, and does not, take any responsibility for such compliance.\n");
MODULE_INFO(linuxcnc, "pin:arc_fail_delay:float:0:in:arc start failure timeout (seconds):None:None");
MODULE_INFO(linuxcnc, "pin:arc_lost_delay:float:0:in:arc lost delay during a cut (seconds):None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok_high:float:0:in:maximum voltage level for Arc OK signal [mode 0] (volts):None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok_in:bit:0:in:external arc ok input signal [mode 1 & mode 2]:None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok_low:float:0:in:minimum voltage level for Arc OK signal [mode 0] (volts):None:None");
MODULE_INFO(linuxcnc, "pin:arc_max_starts:s32:0:in:maximum attempts at starting the arc:None:None");
MODULE_INFO(linuxcnc, "pin:arc_voltage_in:float:0:in:arc voltage input [mode 0 & mode 1] see Notes above:None:None");
MODULE_INFO(linuxcnc, "pin:arc_voltage_offset:float:0:in:offset to set arc voltage to 0 at 0 volts:None:None");
MODULE_INFO(linuxcnc, "pin:arc_voltage_scale:float:0:in:scale to convert arc_voltage input to actual volts:None:None");
MODULE_INFO(linuxcnc, "pin:thc_auto:bit:0:in:enable automatic thc activation:None:None");
MODULE_INFO(linuxcnc, "pin:axis_x_max_limit:float:0:in:axis x maximum limit, connect to ini.x.max-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_x_min_limit:float:0:in:axis x minimum limit, connect to ini.x.min-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_x_position:float:0:in:current x axis position, connect to axis.x.pos-cmd:None:None");
MODULE_INFO(linuxcnc, "pin:axis_y_max_limit:float:0:in:axis y maximum limit, connect to ini.y.max-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_y_min_limit:float:0:in:axis y minimum limit, connect to ini.y.min-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_y_position:float:0:in:current y axis position, connect to axis.y.pos-cmd:None:None");
MODULE_INFO(linuxcnc, "pin:axis_z_max_limit:float:0:in:axis z maximum limit, connect to ini.z.max-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_z_min_limit:float:0:in:axis z minimum limit, connect to ini.z.min-limit:None:None");
MODULE_INFO(linuxcnc, "pin:axis_z_position:float:0:in:current z axis position, connect to joint.N.pos-fb:None:None");
MODULE_INFO(linuxcnc, "pin:breakaway:bit:0:in:torch breakaway switch (optional, see float_switch):None:None");
MODULE_INFO(linuxcnc, "pin:consumable_change:bit:0:in:change consumables in torch:None:None");
MODULE_INFO(linuxcnc, "pin:cornerlock_enable:bit:0:in:enable corner lock:None:None");
MODULE_INFO(linuxcnc, "pin:cornerlock_threshold:float:0:in:corner lock threshold (% of requested feed rate), speeds below this disable THC:None:None");
MODULE_INFO(linuxcnc, "pin:current_velocity:float:0:in:current machine velocity, connect to motion.current-vel:None:None");
MODULE_INFO(linuxcnc, "pin:cut_feed_rate:float:0:in:cut feed rate from current material (machine units per minute):None:None");
MODULE_INFO(linuxcnc, "pin:cut_height:float:0:in:cut height (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:cut_recovery:bit:0:in:recover from cut error:None:None");
MODULE_INFO(linuxcnc, "pin:cut_volts:float:0:in:cut voltage (volts):None:None");
MODULE_INFO(linuxcnc, "pin:cutting_start:bit:0:in:start a new cut, connect to spindle.0.on:None:None");
MODULE_INFO(linuxcnc, "pin:debug_print:bit:0:in:if true will print state changes as a debug aid:None:None");
MODULE_INFO(linuxcnc, "pin:external_estop:bit:0:in:external E-stop input:None:None");
MODULE_INFO(linuxcnc, "pin:feed_override:float:0:in:feed override value from GUI (connect to halui.feed-override.value):None:None");
MODULE_INFO(linuxcnc, "pin:feed_reduction:float:0:in:reduce adaptive feed to this percentage (connect to motion.analog-out-03):None:None");
MODULE_INFO(linuxcnc, "pin:float_switch:bit:0:in:float switch input (can also act as breakaway if it actuates when torch breaks away):None:None");
MODULE_INFO(linuxcnc, "pin:float_switch_travel:float:0:in:float switch travel (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:gcode_scale:float:0:in:current G-code scale:1:None");
MODULE_INFO(linuxcnc, "pin:height_override:float:0:in:height override adjustment (volts):None:None");
MODULE_INFO(linuxcnc, "pin:height_per_volt:float:0:in:torch height change per volt (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:homed:bit:0:in:machine is homed:None:None");
MODULE_INFO(linuxcnc, "pin:ignore_arc_ok_0:bit:0:in:don't require arc ok for start or cutting:None:None");
MODULE_INFO(linuxcnc, "pin:ignore_arc_ok_1:bit:0:in:don't require arc ok for start or cutting:None:None");
MODULE_INFO(linuxcnc, "pin:kerf_width:float:0:in:placeholder for better G-code portability between GUIs:None:None");
MODULE_INFO(linuxcnc, "pin:override_jog:bit:0:in:override jog inhibit:None:None");
MODULE_INFO(linuxcnc, "pin:offset_set_probe:bit:0:in:deploy probe for setting offsets:None:None");
MODULE_INFO(linuxcnc, "pin:offset_set_scribe:bit:0:in:deploy scribe for setting offsets:None:None");
MODULE_INFO(linuxcnc, "pin:laser_recovery_start:s32:0:in:start laser offset for cut recovery:None:None");
MODULE_INFO(linuxcnc, "pin:laser_x_offset:s32:0:in:alignment laser x axis offset (scaled units):None:None");
MODULE_INFO(linuxcnc, "pin:laser_y_offset:s32:0:in:alignment laser y axis offset (scaled units):None:None");
MODULE_INFO(linuxcnc, "pin:lowpass_frequency:float:0:in:lowpass cutoff frequency for arc voltage output:None:None");
MODULE_INFO(linuxcnc, "pin:machine_is_on:bit:0:in:machine is on signal:None:None");
MODULE_INFO(linuxcnc, "pin:max_offset:s32:0:in:maximum height offset:5:None");
MODULE_INFO(linuxcnc, "pin:mesh_arc_ok:bit:0:in:don't require arc ok for mesh mode:FALSE:None");
MODULE_INFO(linuxcnc, "pin:mesh_enable:bit:0:in:enable mesh cutting mode:None:None");
MODULE_INFO(linuxcnc, "pin:mode:s32:0:in:operating mode:None:None");
MODULE_INFO(linuxcnc, "pin:motion_type:s32:0:in:motion type, connect to motion.motion-type:None:None");
MODULE_INFO(linuxcnc, "pin:move_down:bit:0:in:external thc down switch [mode 2]:None:None");
MODULE_INFO(linuxcnc, "pin:move_up:bit:0:in:external thc up switch [mode 2]:None:None");
MODULE_INFO(linuxcnc, "pin:multi_tool:bit:0:in:allows the use of multiple tools:1:None");
MODULE_INFO(linuxcnc, "pin:offset_probe_delay:float:0:in:wait for probe to deploy (seconds):None:None");
MODULE_INFO(linuxcnc, "pin:offset_probe_x:float:0:in:X axis offset for offset probe (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:offset_probe_y:float:0:in:Y axis offset for offset probe (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:offsets_active:bit:0:in:offsets are active, connect to motion.eoffsets-active:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_sense_on_delay:s32:0:in:debounce cycles for ohmic sense on:3:None");
MODULE_INFO(linuxcnc, "pin:ohmic_sense_off_delay:s32:0:in:debounce cycles for ohmic sense off:3:None");
MODULE_INFO(linuxcnc, "pin:ohmic_sense_in:bit:0:in:ohmic sense relay input:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_max_attempts:s32:0:in:maximum ohmic probe attempts before fallback to float switch:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_probe:bit:0:in:ohmic probe input, from ohmic-sense-out or external component/pin:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_probe_enable:bit:0:in:enable ohmic probe:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_probe_offset:float:0:in:Z axis offset for ohmic probe (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_test:bit:0:in:test for shorted torch:None:None");
MODULE_INFO(linuxcnc, "pin:ok_sample_counts:s32:0:in:arc_ok number of valid samples required [mode 0]:10:None");
MODULE_INFO(linuxcnc, "pin:ok_sample_threshold:float:0:in:arc_ok maximum arc voltage deviation allowed [mode 0]:10:None");
MODULE_INFO(linuxcnc, "pin:pause_at_end:float:0:in:time to pause at end of cut:None:None");
MODULE_INFO(linuxcnc, "pin:paused_motion_speed:float:0:in:multiplier for speed of motion when paused, from -1 to 1:None:None");
MODULE_INFO(linuxcnc, "pin:pid_d_gain:float:0:in:derivative gain input [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:pid_i_gain:float:0:in:integral gain input [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:pid_p_gain:float:0:in:proportional gain input [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:pierce_delay:float:0:in:time required to pierce stock (seconds):None:None");
MODULE_INFO(linuxcnc, "pin:probe_feed_rate:float:0:in:probe down velocity (machine units per minute):None:None");
MODULE_INFO(linuxcnc, "pin:probe_final_speed:s32:0:in:final probe speed (steps per servo period):1:None");
MODULE_INFO(linuxcnc, "pin:pierce_height:float:0:in:pierce height (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:probe_start_height:float:0:in:probe starting height:None:None");
MODULE_INFO(linuxcnc, "pin:probe_test:bit:0:in:probe test only:None:None");
MODULE_INFO(linuxcnc, "pin:program_is_idle:bit:0:in:program is idle, connect to halui.program.is-idle:None:None");
MODULE_INFO(linuxcnc, "pin:program_is_paused:bit:0:in:program is paused, connect to halui.program.is-paused:None:None");
MODULE_INFO(linuxcnc, "pin:program_is_running:bit:0:in:program is running, connect to halui.program.is-running:None:None");
MODULE_INFO(linuxcnc, "pin:puddle_jump_delay:float:0:in:Delay move from pierce height to cut height (seconds), leave disconnected if not required.:None:None");
MODULE_INFO(linuxcnc, "pin:puddle_jump_height:float:0:in:Puddle jump height (percentage of pierce height), leave disconnected if not required.:None:None");
MODULE_INFO(linuxcnc, "pin:requested_velocity:float:0:in:deprecated:None:None");
MODULE_INFO(linuxcnc, "pin:feed_upm:float:0:in:requested feed_rate, connect to motion.feed-upm to use as the default (G-code units per minute):None:None");
MODULE_INFO(linuxcnc, "pin:resolution:s32:0:in:multiplier for resolution of the offset counts:100:None");
MODULE_INFO(linuxcnc, "pin:restart_delay:float:0:in:time from arc failure till next restart attempt:None:None");
MODULE_INFO(linuxcnc, "pin:safe_height:float:0:in:requested safe traverse height (machine units):None:None");
MODULE_INFO(linuxcnc, "pin:scribe_arm_delay:float:0:in:delay from scribe arm to scribe on:None:None");
MODULE_INFO(linuxcnc, "pin:scribe_on_delay:float:0:in:delay from scribe on to motion beginning:None:None");
MODULE_INFO(linuxcnc, "pin:scribe_start:bit:0:in:start a new scribe, connect to spindle.1.on:None:None");
MODULE_INFO(linuxcnc, "pin:setup_feed_rate:float:0:in:feed rate for moves to pierce and cut heights (machine units per minute):None:None");
MODULE_INFO(linuxcnc, "pin:skip_ihs_distance:float:0:in:skip IHS if less than this distance from last cut:None:None");
MODULE_INFO(linuxcnc, "pin:spotting_start:bit:0:in:start a new spot, connect to spindle.2.on:None:None");
MODULE_INFO(linuxcnc, "pin:spotting_threshold:float:0:in:threshold voltage to start spotting delay:None:None");
MODULE_INFO(linuxcnc, "pin:spotting_time:float:0:in:torch off delay after spotting threshold reached:None:None");
MODULE_INFO(linuxcnc, "pin:thc_delay:float:0:in:delay from cut feed rate reached to THC activate (seconds) [non auto THC]:None:None");
MODULE_INFO(linuxcnc, "pin:thc_disable:bit:0:in:thc disable:None:None");
MODULE_INFO(linuxcnc, "pin:thc_enable:bit:0:in:enable/disable thc and set the IHS skip type:None:None");
MODULE_INFO(linuxcnc, "pin:thc_feed_rate:float:0:in:maximum feed rate for thc (machine units per minute):None:None");
MODULE_INFO(linuxcnc, "pin:thc_sample_counts:s32:0:in:thc number of valid samples required [auto THC]:50:None");
MODULE_INFO(linuxcnc, "pin:thc_sample_threshold:float:0:in:thc maximum arc voltage deviation allowed [auto THC]:1:None");
MODULE_INFO(linuxcnc, "pin:thc_threshold:float:0:in:thc threshold (volts), changes below this have no effect:None:None");
MODULE_INFO(linuxcnc, "pin:torch_enable:bit:0:in:enable torch:None:None");
MODULE_INFO(linuxcnc, "pin:torch_off:bit:0:in:turn torch off:None:None");
MODULE_INFO(linuxcnc, "pin:torch_pulse_start:bit:0:in:torch pulse start:None:None");
MODULE_INFO(linuxcnc, "pin:torch_pulse_time:float:0:in:torch pulse time (seconds):None:None");
MODULE_INFO(linuxcnc, "pin:units_per_mm:float:0:in:for scale calcs, connect to halui.machine.units-per-mm:None:None");
MODULE_INFO(linuxcnc, "pin:use_auto_volts:bit:0:in:use calculated voltage for thc baseline:None:None");
MODULE_INFO(linuxcnc, "pin:voidlock_enable:bit:0:in:enable voidlock [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:voidlock_on_cycles:s32:0:in:number of sampling cycles to activate voidlock :2:None");
MODULE_INFO(linuxcnc, "pin:voidlock_off_cycles:s32:0:in:number of sampling cycles to deactivate voidlock:10:None");
MODULE_INFO(linuxcnc, "pin:voidlock_slope:s32:0:in:voidlock slope in volts per second:500:None");
MODULE_INFO(linuxcnc, "pin:x_offset:s32:0:in:offset to apply to axis x for consumable change and cut recovery (scaled units):None:None");
MODULE_INFO(linuxcnc, "pin:x_offset_current:float:0:in:current x axis offset, connect to axis.x.eoffset:None:None");
MODULE_INFO(linuxcnc, "pin:xy_feed_rate:float:0:in:feed-rate for consumable change:None:None");
MODULE_INFO(linuxcnc, "pin:y_offset:s32:0:in:offset to apply to axis y for consumable change and cut recovery (scaled units):None:None");
MODULE_INFO(linuxcnc, "pin:y_offset_current:float:0:in:current z axis offset, connect to axis.y.eoffset:None:None");
MODULE_INFO(linuxcnc, "pin:z_offset_current:float:0:in:current z axis offset, connect to axis.z.eoffset:None:None");
MODULE_INFO(linuxcnc, "pin:zero_window:float:0:in:sets window that voltage fluctuations show as zero (-0.1 to 0.1 at default value):0.1:None");
MODULE_INFO(linuxcnc, "pin:adaptive_feed:float:0:out:for reverse-run, connect to motion.adaptive-feed:None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok_out:bit:0:out:arc ok output:None:None");
MODULE_INFO(linuxcnc, "pin:arc_voltage_out:float:0:out:arc voltage output [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:consumable_changing:bit:0:out:consumables are being changed:None:None");
MODULE_INFO(linuxcnc, "pin:cornerlock_is_locked:bit:0:out:corner locked indicator:None:None");
MODULE_INFO(linuxcnc, "pin:cut_length:float:0:out:length of current cut job:None:None");
MODULE_INFO(linuxcnc, "pin:cut_recovering:bit:0:out:recovering from cut error:None:None");
MODULE_INFO(linuxcnc, "pin:cut_time:float:0:out:cut time of current job:None:None");
MODULE_INFO(linuxcnc, "pin:cutting_stop:bit:0:out:stop manual cut, connect to halui.spindle.0.stop:None:None");
MODULE_INFO(linuxcnc, "pin:feed_hold:bit:0:out:feed hold, connect to motion.feed-hold:None:None");
MODULE_INFO(linuxcnc, "pin:jog_inhibit:bit:0:out:jog inhibit, connect to motion.jog-inhibit:None:None");
MODULE_INFO(linuxcnc, "pin:laser_recovery_state:s32:0:out:laser recovery status:None:None");
MODULE_INFO(linuxcnc, "pin:led_down:bit:0:out:thc move down indicator:None:None");
MODULE_INFO(linuxcnc, "pin:led_up:bit:0:out:thc move up indicator:None:None");
MODULE_INFO(linuxcnc, "pin:offset_scale:float:0:out:offset scale, connect to axis.<x y z>.eoffset-scale:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_enable:bit:0:out:on only while probing:None:None");
MODULE_INFO(linuxcnc, "pin:ohmic_sense_out:bit:0:out:ohmic sense output state:None:None");
MODULE_INFO(linuxcnc, "pin:paused_motion:bit:0:out:paused motion flag, true when paused motion is active:None:None");
MODULE_INFO(linuxcnc, "pin:paused_time:float:0:out:paused time during current job:None:None");
MODULE_INFO(linuxcnc, "pin:pierce_count:s32:0:out:number of pierce attempts (torch starts):None:None");
MODULE_INFO(linuxcnc, "pin:probe_test_error:bit:0:out:minimum limit reached while probe testing:None:None");
MODULE_INFO(linuxcnc, "pin:probe_time:float:0:out:probe time of current job:None:None");
MODULE_INFO(linuxcnc, "pin:program_pause:bit:0:out:pause the current program, connect to halui.program.pause:None:None");
MODULE_INFO(linuxcnc, "pin:program_resume:bit:0:out:resume the currently paused program, connect to halui.program.resume:None:None");
MODULE_INFO(linuxcnc, "pin:program_run:bit:0:out:run the currently loaded program, connect to halui.program.run:None:None");
MODULE_INFO(linuxcnc, "pin:program_stop:bit:0:out:stop current program, connect to halui.program.stop:None:None");
MODULE_INFO(linuxcnc, "pin:rapid_time:float:0:out:rapid motion time of current job:None:None");
MODULE_INFO(linuxcnc, "pin:run_time:float:0:out:run time of current job:None:None");
MODULE_INFO(linuxcnc, "pin:safe_height_is_limited:bit:0:out:safe height is limited indicator:None:None");
MODULE_INFO(linuxcnc, "pin:sensor_active:bit:0:out:one of float, ohmic, or breakaway is detected:None:None");
MODULE_INFO(linuxcnc, "pin:scribe_arm:bit:0:out:arm the scribe:None:None");
MODULE_INFO(linuxcnc, "pin:scribe_on:bit:0:out:turn scribe on:None:None");
MODULE_INFO(linuxcnc, "pin:state_out:s32:0:out:current state:None:None");
MODULE_INFO(linuxcnc, "pin:stop_type_out:s32:0:out:current stop type:None:None");
MODULE_INFO(linuxcnc, "pin:thc_active:bit:0:out:thc status output:None:None");
MODULE_INFO(linuxcnc, "pin:thc_enabled:bit:0:out:thc is enabled:None:None");
MODULE_INFO(linuxcnc, "pin:torch_on:bit:0:out:turn torch on, connect to your torch on input:None:None");
MODULE_INFO(linuxcnc, "pin:torch_time:float:0:out:torch on time of current job:None:None");
MODULE_INFO(linuxcnc, "pin:voidlock_is_locked:bit:0:out:voidlock is locked indicator [mode 0 & mode 1]:None:None");
MODULE_INFO(linuxcnc, "pin:x_offset_counts:s32:0:out:x offset for consumable change, connect to axis.x.eoffset-counts:None:None");
MODULE_INFO(linuxcnc, "pin:xy_offset_enable:bit:0:out:enable x and y offsets, connect to axis.<x & y>.eoffset-enable:None:None");
MODULE_INFO(linuxcnc, "pin:y_offset_counts:s32:0:out:y offset for consumable change, connect to axis.y.eoffset-counts:None:None");
MODULE_INFO(linuxcnc, "pin:z_height:float:0:out:current z axis height relative to the probed zero height:None:None");
MODULE_INFO(linuxcnc, "pin:z_offset_counts:s32:0:out:z offset for height control, connect to axis.z.eoffset-counts:None:None");
MODULE_INFO(linuxcnc, "pin:z_offset_enable:bit:0:out:enable z offsets, connect to axis.z.eoffset-enable:None:None");
MODULE_INFO(linuxcnc, "pin:z_relative:float:0:out:distance of Z from last probed height:None:None");
MODULE_INFO(linuxcnc, "pin:current_feed_rate:float:0:out:current feed rate per minute:None:None");
MODULE_INFO(linuxcnc, "pin:requested_feed_rate:float:0:out:requested feed rate:None:None");
MODULE_INFO(linuxcnc, "pin:low_cut_volts:s32:0:in:low cut voltage threshold while thc active:None:None");
MODULE_INFO(linuxcnc, "pin:target_samples:s32:0:in:number of samples for setting target_volts:6:None");
MODULE_INFO(linuxcnc, "pin:target_volts:float:0:out:target voltage for thc, set by arc voltage at cut height:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "author:Phillip A Carter & Gregory D Carl");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *arc_fail_delay_p;
    hal_float_t *arc_lost_delay_p;
    hal_float_t *arc_ok_high_p;
    hal_bit_t *arc_ok_in_p;
    hal_float_t *arc_ok_low_p;
    hal_s32_t *arc_max_starts_p;
    hal_float_t *arc_voltage_in_p;
    hal_float_t *arc_voltage_offset_p;
    hal_float_t *arc_voltage_scale_p;
    hal_bit_t *thc_auto_p;
    hal_float_t *axis_x_max_limit_p;
    hal_float_t *axis_x_min_limit_p;
    hal_float_t *axis_x_position_p;
    hal_float_t *axis_y_max_limit_p;
    hal_float_t *axis_y_min_limit_p;
    hal_float_t *axis_y_position_p;
    hal_float_t *axis_z_max_limit_p;
    hal_float_t *axis_z_min_limit_p;
    hal_float_t *axis_z_position_p;
    hal_bit_t *breakaway_p;
    hal_bit_t *consumable_change_p;
    hal_bit_t *cornerlock_enable_p;
    hal_float_t *cornerlock_threshold_p;
    hal_float_t *current_velocity_p;
    hal_float_t *cut_feed_rate_p;
    hal_float_t *cut_height_p;
    hal_bit_t *cut_recovery_p;
    hal_float_t *cut_volts_p;
    hal_bit_t *cutting_start_p;
    hal_bit_t *debug_print_p;
    hal_bit_t *external_estop_p;
    hal_float_t *feed_override_p;
    hal_float_t *feed_reduction_p;
    hal_bit_t *float_switch_p;
    hal_float_t *float_switch_travel_p;
    hal_float_t *gcode_scale_p;
    hal_float_t *height_override_p;
    hal_float_t *height_per_volt_p;
    hal_bit_t *homed_p;
    hal_bit_t *ignore_arc_ok_0_p;
    hal_bit_t *ignore_arc_ok_1_p;
    hal_float_t *kerf_width_p;
    hal_bit_t *override_jog_p;
    hal_bit_t *offset_set_probe_p;
    hal_bit_t *offset_set_scribe_p;
    hal_s32_t *laser_recovery_start_p;
    hal_s32_t *laser_x_offset_p;
    hal_s32_t *laser_y_offset_p;
    hal_float_t *lowpass_frequency_p;
    hal_bit_t *machine_is_on_p;
    hal_s32_t *max_offset_p;
    hal_bit_t *mesh_arc_ok_p;
    hal_bit_t *mesh_enable_p;
    hal_s32_t *mode_p;
    hal_s32_t *motion_type_p;
    hal_bit_t *move_down_p;
    hal_bit_t *move_up_p;
    hal_bit_t *multi_tool_p;
    hal_float_t *offset_probe_delay_p;
    hal_float_t *offset_probe_x_p;
    hal_float_t *offset_probe_y_p;
    hal_bit_t *offsets_active_p;
    hal_s32_t *ohmic_sense_on_delay_p;
    hal_s32_t *ohmic_sense_off_delay_p;
    hal_bit_t *ohmic_sense_in_p;
    hal_s32_t *ohmic_max_attempts_p;
    hal_bit_t *ohmic_probe_p;
    hal_bit_t *ohmic_probe_enable_p;
    hal_float_t *ohmic_probe_offset_p;
    hal_bit_t *ohmic_test_p;
    hal_s32_t *ok_sample_counts_p;
    hal_float_t *ok_sample_threshold_p;
    hal_float_t *pause_at_end_p;
    hal_float_t *paused_motion_speed_p;
    hal_float_t *pid_d_gain_p;
    hal_float_t *pid_i_gain_p;
    hal_float_t *pid_p_gain_p;
    hal_float_t *pierce_delay_p;
    hal_float_t *probe_feed_rate_p;
    hal_s32_t *probe_final_speed_p;
    hal_float_t *pierce_height_p;
    hal_float_t *probe_start_height_p;
    hal_bit_t *probe_test_p;
    hal_bit_t *program_is_idle_p;
    hal_bit_t *program_is_paused_p;
    hal_bit_t *program_is_running_p;
    hal_float_t *puddle_jump_delay_p;
    hal_float_t *puddle_jump_height_p;
    hal_float_t *requested_velocity_p;
    hal_float_t *feed_upm_p;
    hal_s32_t *resolution_p;
    hal_float_t *restart_delay_p;
    hal_float_t *safe_height_p;
    hal_float_t *scribe_arm_delay_p;
    hal_float_t *scribe_on_delay_p;
    hal_bit_t *scribe_start_p;
    hal_float_t *setup_feed_rate_p;
    hal_float_t *skip_ihs_distance_p;
    hal_bit_t *spotting_start_p;
    hal_float_t *spotting_threshold_p;
    hal_float_t *spotting_time_p;
    hal_float_t *thc_delay_p;
    hal_bit_t *thc_disable_p;
    hal_bit_t *thc_enable_p;
    hal_float_t *thc_feed_rate_p;
    hal_s32_t *thc_sample_counts_p;
    hal_float_t *thc_sample_threshold_p;
    hal_float_t *thc_threshold_p;
    hal_bit_t *torch_enable_p;
    hal_bit_t *torch_off_p;
    hal_bit_t *torch_pulse_start_p;
    hal_float_t *torch_pulse_time_p;
    hal_float_t *units_per_mm_p;
    hal_bit_t *use_auto_volts_p;
    hal_bit_t *voidlock_enable_p;
    hal_s32_t *voidlock_on_cycles_p;
    hal_s32_t *voidlock_off_cycles_p;
    hal_s32_t *voidlock_slope_p;
    hal_s32_t *x_offset_p;
    hal_float_t *x_offset_current_p;
    hal_float_t *xy_feed_rate_p;
    hal_s32_t *y_offset_p;
    hal_float_t *y_offset_current_p;
    hal_float_t *z_offset_current_p;
    hal_float_t *zero_window_p;
    hal_float_t *adaptive_feed_p;
    hal_bit_t *arc_ok_out_p;
    hal_float_t *arc_voltage_out_p;
    hal_bit_t *consumable_changing_p;
    hal_bit_t *cornerlock_is_locked_p;
    hal_float_t *cut_length_p;
    hal_bit_t *cut_recovering_p;
    hal_float_t *cut_time_p;
    hal_bit_t *cutting_stop_p;
    hal_bit_t *feed_hold_p;
    hal_bit_t *jog_inhibit_p;
    hal_s32_t *laser_recovery_state_p;
    hal_bit_t *led_down_p;
    hal_bit_t *led_up_p;
    hal_float_t *offset_scale_p;
    hal_bit_t *ohmic_enable_p;
    hal_bit_t *ohmic_sense_out_p;
    hal_bit_t *paused_motion_p;
    hal_float_t *paused_time_p;
    hal_s32_t *pierce_count_p;
    hal_bit_t *probe_test_error_p;
    hal_float_t *probe_time_p;
    hal_bit_t *program_pause_p;
    hal_bit_t *program_resume_p;
    hal_bit_t *program_run_p;
    hal_bit_t *program_stop_p;
    hal_float_t *rapid_time_p;
    hal_float_t *run_time_p;
    hal_bit_t *safe_height_is_limited_p;
    hal_bit_t *sensor_active_p;
    hal_bit_t *scribe_arm_p;
    hal_bit_t *scribe_on_p;
    hal_s32_t *state_out_p;
    hal_s32_t *stop_type_out_p;
    hal_bit_t *thc_active_p;
    hal_bit_t *thc_enabled_p;
    hal_bit_t *torch_on_p;
    hal_float_t *torch_time_p;
    hal_bit_t *voidlock_is_locked_p;
    hal_s32_t *x_offset_counts_p;
    hal_bit_t *xy_offset_enable_p;
    hal_s32_t *y_offset_counts_p;
    hal_float_t *z_height_p;
    hal_s32_t *z_offset_counts_p;
    hal_bit_t *z_offset_enable_p;
    hal_float_t *z_relative_p;
    hal_float_t *current_feed_rate_p;
    hal_float_t *requested_feed_rate_p;
    hal_s32_t *low_cut_volts_p;
    hal_s32_t *target_samples_p;
    hal_float_t *target_volts_p;
    double angle_x_y_p;

    float arc_fail_timer_p;

    float arc_lost_timer_p;

    int arc_starts_p;

    float arc_valid_timer_p;

    float arc_voltage_raw_p;

    int arc_voltage_buffer_index_p;

    int ok_sampler_samples_p;

    bool auto_cut_p;

    float axis_x_finish_p;

    float axis_x_start_p;

    float axis_y_finish_p;

    float axis_y_start_p;

    int cons_change_clear_p;

    int count_p;

    int cut_height_first_p;

    int cut_height_last_p;

    float cut_offset_p;

    bool cut_started_p;

    int cut_target_p;

    bool error_message_p;

    bool first_cut_finished_p;

    bool float_detected_p;

    int height_ovr_counts_p;

    float height_ovr_old_p;

    bool initialized_p;

    int laser_x_target_p;

    int laser_y_target_p;

    float last_arc_voltage_p;

    bool manual_cut_p;

    int offset_datum_p;

    int offset_max_p;

    int offset_min_p;

    float offset_probe_timer_p;

    bool offset_probing_p;

    int offset_res_p;

    bool offset_set_p;

    int ohmic_attempts_p;

    bool ohmic_detected_p;

    int ohmic_sense_counts_p;

    int old_resolution_p;

    int op_x_start_p;

    int op_x_target_p;

    int op_x_velocity_p;

    double op_xy_angle_p;

    int op_y_start_p;

    int op_y_target_p;

    int op_y_velocity_p;

    float pause_at_end_timer_p;

    float paused_motion_timer_p;

    float pid_error_now_p;

    float pid_error_old_p;

    float pid_output_p;

    int pierce_target_p;

    float pierce_timer_p;

    float probe_at_bottom_p;

    bool probe_inhibit_p;

    int probe_offset_p;

    bool probe_required_p;

    bool probe_retry_p;

    int probe_start_target_p;

    bool probe_testing_p;

    int probe_velocity_p;

    int puddle_jump_percent_p;

    int puddle_jump_target_p;

    float puddle_jump_timer_p;

    float recovery_velocity_p;

    int res_p;

    float restart_timer_p;

    int safe_alarm_p;

    int safe_available_p;

    int safe_min_p;

    int safe_preferred_p;

    int safe_target_p;

    int setup_velocity_p;

    float scribe_arm_timer_p;

    float scribe_on_timer_p;

    bool scribe_pause_p;

    bool spotting_p;

    float spotting_timer_p;

    int state_old_p;

    int statistics_reset_p;

    float target_total_p;

    bool thc_activated_p;

    float thc_activated_timer_p;

    float thc_delay_timer_p;

    int thc_sampler_samples_p;

    int thc_velocity_p;

    float torch_off_timer_p;

    float torch_pulse_timer_p;

    float velocity_scale_p;

    float voidlock_change_p;

    float voidlock_off_count_p;

    int voidlock_on_count_p;

    float voidlock_threshold_p;

    int x_velocity_p;

    int y_velocity_p;

    int z_max_p;

    int z_pierce_p;

    int zero_target_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_fail_delay_p), comp_id,
        "%s.arc-fail-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_lost_delay_p), comp_id,
        "%s.arc-lost-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_ok_high_p), comp_id,
        "%s.arc-ok-high", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->arc_ok_in_p), comp_id,
        "%s.arc-ok-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_ok_low_p), comp_id,
        "%s.arc-ok-low", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->arc_max_starts_p), comp_id,
        "%s.arc-max-starts", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_voltage_in_p), comp_id,
        "%s.arc-voltage-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_voltage_offset_p), comp_id,
        "%s.arc-voltage-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_voltage_scale_p), comp_id,
        "%s.arc-voltage-scale", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->thc_auto_p), comp_id,
        "%s.thc-auto", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_x_max_limit_p), comp_id,
        "%s.axis-x-max-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_x_min_limit_p), comp_id,
        "%s.axis-x-min-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_x_position_p), comp_id,
        "%s.axis-x-position", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_y_max_limit_p), comp_id,
        "%s.axis-y-max-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_y_min_limit_p), comp_id,
        "%s.axis-y-min-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_y_position_p), comp_id,
        "%s.axis-y-position", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_z_max_limit_p), comp_id,
        "%s.axis-z-max-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_z_min_limit_p), comp_id,
        "%s.axis-z-min-limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->axis_z_position_p), comp_id,
        "%s.axis-z-position", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->breakaway_p), comp_id,
        "%s.breakaway", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->consumable_change_p), comp_id,
        "%s.consumable-change", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->cornerlock_enable_p), comp_id,
        "%s.cornerlock-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->cornerlock_threshold_p), comp_id,
        "%s.cornerlock-threshold", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->current_velocity_p), comp_id,
        "%s.current-velocity", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->cut_feed_rate_p), comp_id,
        "%s.cut-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->cut_height_p), comp_id,
        "%s.cut-height", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->cut_recovery_p), comp_id,
        "%s.cut-recovery", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->cut_volts_p), comp_id,
        "%s.cut-volts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->cutting_start_p), comp_id,
        "%s.cutting-start", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->debug_print_p), comp_id,
        "%s.debug-print", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->external_estop_p), comp_id,
        "%s.external-estop", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->feed_override_p), comp_id,
        "%s.feed-override", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->feed_reduction_p), comp_id,
        "%s.feed-reduction", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->float_switch_p), comp_id,
        "%s.float-switch", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->float_switch_travel_p), comp_id,
        "%s.float-switch-travel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->gcode_scale_p), comp_id,
        "%s.gcode-scale", prefix);
    if(r != 0) return r;
    *(inst->gcode_scale_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->height_override_p), comp_id,
        "%s.height-override", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->height_per_volt_p), comp_id,
        "%s.height-per-volt", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->homed_p), comp_id,
        "%s.homed", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ignore_arc_ok_0_p), comp_id,
        "%s.ignore-arc-ok-0", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ignore_arc_ok_1_p), comp_id,
        "%s.ignore-arc-ok-1", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->kerf_width_p), comp_id,
        "%s.kerf-width", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->override_jog_p), comp_id,
        "%s.override-jog", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->offset_set_probe_p), comp_id,
        "%s.offset-set-probe", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->offset_set_scribe_p), comp_id,
        "%s.offset-set-scribe", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->laser_recovery_start_p), comp_id,
        "%s.laser-recovery-start", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->laser_x_offset_p), comp_id,
        "%s.laser-x-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->laser_y_offset_p), comp_id,
        "%s.laser-y-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->lowpass_frequency_p), comp_id,
        "%s.lowpass-frequency", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->machine_is_on_p), comp_id,
        "%s.machine-is-on", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->max_offset_p), comp_id,
        "%s.max-offset", prefix);
    if(r != 0) return r;
    *(inst->max_offset_p) = 5;
    r = hal_pin_bit_newf(HAL_IN, &(inst->mesh_arc_ok_p), comp_id,
        "%s.mesh-arc-ok", prefix);
    if(r != 0) return r;
    *(inst->mesh_arc_ok_p) = FALSE;
    r = hal_pin_bit_newf(HAL_IN, &(inst->mesh_enable_p), comp_id,
        "%s.mesh-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->mode_p), comp_id,
        "%s.mode", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->motion_type_p), comp_id,
        "%s.motion-type", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->move_down_p), comp_id,
        "%s.move-down", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->move_up_p), comp_id,
        "%s.move-up", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->multi_tool_p), comp_id,
        "%s.multi-tool", prefix);
    if(r != 0) return r;
    *(inst->multi_tool_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->offset_probe_delay_p), comp_id,
        "%s.offset-probe-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->offset_probe_x_p), comp_id,
        "%s.offset-probe-x", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->offset_probe_y_p), comp_id,
        "%s.offset-probe-y", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->offsets_active_p), comp_id,
        "%s.offsets-active", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->ohmic_sense_on_delay_p), comp_id,
        "%s.ohmic-sense-on-delay", prefix);
    if(r != 0) return r;
    *(inst->ohmic_sense_on_delay_p) = 3;
    r = hal_pin_s32_newf(HAL_IN, &(inst->ohmic_sense_off_delay_p), comp_id,
        "%s.ohmic-sense-off-delay", prefix);
    if(r != 0) return r;
    *(inst->ohmic_sense_off_delay_p) = 3;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ohmic_sense_in_p), comp_id,
        "%s.ohmic-sense-in", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->ohmic_max_attempts_p), comp_id,
        "%s.ohmic-max-attempts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ohmic_probe_p), comp_id,
        "%s.ohmic-probe", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ohmic_probe_enable_p), comp_id,
        "%s.ohmic-probe-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->ohmic_probe_offset_p), comp_id,
        "%s.ohmic-probe-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ohmic_test_p), comp_id,
        "%s.ohmic-test", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->ok_sample_counts_p), comp_id,
        "%s.ok-sample-counts", prefix);
    if(r != 0) return r;
    *(inst->ok_sample_counts_p) = 10;
    r = hal_pin_float_newf(HAL_IN, &(inst->ok_sample_threshold_p), comp_id,
        "%s.ok-sample-threshold", prefix);
    if(r != 0) return r;
    *(inst->ok_sample_threshold_p) = 10;
    r = hal_pin_float_newf(HAL_IN, &(inst->pause_at_end_p), comp_id,
        "%s.pause-at-end", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->paused_motion_speed_p), comp_id,
        "%s.paused-motion-speed", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->pid_d_gain_p), comp_id,
        "%s.pid-d-gain", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->pid_i_gain_p), comp_id,
        "%s.pid-i-gain", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->pid_p_gain_p), comp_id,
        "%s.pid-p-gain", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->pierce_delay_p), comp_id,
        "%s.pierce-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->probe_feed_rate_p), comp_id,
        "%s.probe-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->probe_final_speed_p), comp_id,
        "%s.probe-final-speed", prefix);
    if(r != 0) return r;
    *(inst->probe_final_speed_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->pierce_height_p), comp_id,
        "%s.pierce-height", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->probe_start_height_p), comp_id,
        "%s.probe-start-height", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->probe_test_p), comp_id,
        "%s.probe-test", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->program_is_idle_p), comp_id,
        "%s.program-is-idle", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->program_is_paused_p), comp_id,
        "%s.program-is-paused", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->program_is_running_p), comp_id,
        "%s.program-is-running", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->puddle_jump_delay_p), comp_id,
        "%s.puddle-jump-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->puddle_jump_height_p), comp_id,
        "%s.puddle-jump-height", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->requested_velocity_p), comp_id,
        "%s.requested-velocity", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->feed_upm_p), comp_id,
        "%s.feed-upm", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->resolution_p), comp_id,
        "%s.resolution", prefix);
    if(r != 0) return r;
    *(inst->resolution_p) = 100;
    r = hal_pin_float_newf(HAL_IN, &(inst->restart_delay_p), comp_id,
        "%s.restart-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->safe_height_p), comp_id,
        "%s.safe-height", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->scribe_arm_delay_p), comp_id,
        "%s.scribe-arm-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->scribe_on_delay_p), comp_id,
        "%s.scribe-on-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->scribe_start_p), comp_id,
        "%s.scribe-start", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->setup_feed_rate_p), comp_id,
        "%s.setup-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->skip_ihs_distance_p), comp_id,
        "%s.skip-ihs-distance", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->spotting_start_p), comp_id,
        "%s.spotting-start", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->spotting_threshold_p), comp_id,
        "%s.spotting-threshold", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->spotting_time_p), comp_id,
        "%s.spotting-time", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->thc_delay_p), comp_id,
        "%s.thc-delay", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->thc_disable_p), comp_id,
        "%s.thc-disable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->thc_enable_p), comp_id,
        "%s.thc-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->thc_feed_rate_p), comp_id,
        "%s.thc-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->thc_sample_counts_p), comp_id,
        "%s.thc-sample-counts", prefix);
    if(r != 0) return r;
    *(inst->thc_sample_counts_p) = 50;
    r = hal_pin_float_newf(HAL_IN, &(inst->thc_sample_threshold_p), comp_id,
        "%s.thc-sample-threshold", prefix);
    if(r != 0) return r;
    *(inst->thc_sample_threshold_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->thc_threshold_p), comp_id,
        "%s.thc-threshold", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_enable_p), comp_id,
        "%s.torch-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_off_p), comp_id,
        "%s.torch-off", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_pulse_start_p), comp_id,
        "%s.torch-pulse-start", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->torch_pulse_time_p), comp_id,
        "%s.torch-pulse-time", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->units_per_mm_p), comp_id,
        "%s.units-per-mm", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->use_auto_volts_p), comp_id,
        "%s.use-auto-volts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->voidlock_enable_p), comp_id,
        "%s.voidlock-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->voidlock_on_cycles_p), comp_id,
        "%s.voidlock-on-cycles", prefix);
    if(r != 0) return r;
    *(inst->voidlock_on_cycles_p) = 2;
    r = hal_pin_s32_newf(HAL_IN, &(inst->voidlock_off_cycles_p), comp_id,
        "%s.voidlock-off-cycles", prefix);
    if(r != 0) return r;
    *(inst->voidlock_off_cycles_p) = 10;
    r = hal_pin_s32_newf(HAL_IN, &(inst->voidlock_slope_p), comp_id,
        "%s.voidlock-slope", prefix);
    if(r != 0) return r;
    *(inst->voidlock_slope_p) = 500;
    r = hal_pin_s32_newf(HAL_IN, &(inst->x_offset_p), comp_id,
        "%s.x-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->x_offset_current_p), comp_id,
        "%s.x-offset-current", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->xy_feed_rate_p), comp_id,
        "%s.xy-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->y_offset_p), comp_id,
        "%s.y-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->y_offset_current_p), comp_id,
        "%s.y-offset-current", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->z_offset_current_p), comp_id,
        "%s.z-offset-current", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->zero_window_p), comp_id,
        "%s.zero-window", prefix);
    if(r != 0) return r;
    *(inst->zero_window_p) = 0.1;
    r = hal_pin_float_newf(HAL_OUT, &(inst->adaptive_feed_p), comp_id,
        "%s.adaptive-feed", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->arc_ok_out_p), comp_id,
        "%s.arc-ok-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->arc_voltage_out_p), comp_id,
        "%s.arc-voltage-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->consumable_changing_p), comp_id,
        "%s.consumable-changing", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->cornerlock_is_locked_p), comp_id,
        "%s.cornerlock-is-locked", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->cut_length_p), comp_id,
        "%s.cut-length", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->cut_recovering_p), comp_id,
        "%s.cut-recovering", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->cut_time_p), comp_id,
        "%s.cut-time", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->cutting_stop_p), comp_id,
        "%s.cutting-stop", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->feed_hold_p), comp_id,
        "%s.feed-hold", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->jog_inhibit_p), comp_id,
        "%s.jog-inhibit", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->laser_recovery_state_p), comp_id,
        "%s.laser-recovery-state", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->led_down_p), comp_id,
        "%s.led-down", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->led_up_p), comp_id,
        "%s.led-up", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->offset_scale_p), comp_id,
        "%s.offset-scale", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->ohmic_enable_p), comp_id,
        "%s.ohmic-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->ohmic_sense_out_p), comp_id,
        "%s.ohmic-sense-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->paused_motion_p), comp_id,
        "%s.paused-motion", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->paused_time_p), comp_id,
        "%s.paused-time", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->pierce_count_p), comp_id,
        "%s.pierce-count", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->probe_test_error_p), comp_id,
        "%s.probe-test-error", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->probe_time_p), comp_id,
        "%s.probe-time", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->program_pause_p), comp_id,
        "%s.program-pause", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->program_resume_p), comp_id,
        "%s.program-resume", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->program_run_p), comp_id,
        "%s.program-run", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->program_stop_p), comp_id,
        "%s.program-stop", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->rapid_time_p), comp_id,
        "%s.rapid-time", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->run_time_p), comp_id,
        "%s.run-time", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->safe_height_is_limited_p), comp_id,
        "%s.safe-height-is-limited", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->sensor_active_p), comp_id,
        "%s.sensor-active", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->scribe_arm_p), comp_id,
        "%s.scribe-arm", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->scribe_on_p), comp_id,
        "%s.scribe-on", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->state_out_p), comp_id,
        "%s.state-out", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->stop_type_out_p), comp_id,
        "%s.stop-type-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->thc_active_p), comp_id,
        "%s.thc-active", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->thc_enabled_p), comp_id,
        "%s.thc-enabled", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->torch_on_p), comp_id,
        "%s.torch-on", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->torch_time_p), comp_id,
        "%s.torch-time", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->voidlock_is_locked_p), comp_id,
        "%s.voidlock-is-locked", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->x_offset_counts_p), comp_id,
        "%s.x-offset-counts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->xy_offset_enable_p), comp_id,
        "%s.xy-offset-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->y_offset_counts_p), comp_id,
        "%s.y-offset-counts", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_height_p), comp_id,
        "%s.z-height", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->z_offset_counts_p), comp_id,
        "%s.z-offset-counts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->z_offset_enable_p), comp_id,
        "%s.z-offset-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_relative_p), comp_id,
        "%s.z-relative", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->current_feed_rate_p), comp_id,
        "%s.current-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->requested_feed_rate_p), comp_id,
        "%s.requested-feed-rate", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->low_cut_volts_p), comp_id,
        "%s.low-cut-volts", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->target_samples_p), comp_id,
        "%s.target-samples", prefix);
    if(r != 0) return r;
    *(inst->target_samples_p) = 6;
    r = hal_pin_float_newf(HAL_OUT, &(inst->target_volts_p), comp_id,
        "%s.target-volts", prefix);
    if(r != 0) return r;
    inst->probe_required_p = 1.0;
    inst->state_old_p = -1.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("plasmac");
    if(comp_id < 0) return comp_id;
    r = export("plasmac", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef arc_fail_delay
#undef arc_fail_delay_ptr
#define arc_fail_delay_ptr (__comp_inst->arc_fail_delay_p)
#define arc_fail_delay (0+*__comp_inst->arc_fail_delay_p)
#undef arc_lost_delay
#undef arc_lost_delay_ptr
#define arc_lost_delay_ptr (__comp_inst->arc_lost_delay_p)
#define arc_lost_delay (0+*__comp_inst->arc_lost_delay_p)
#undef arc_ok_high
#undef arc_ok_high_ptr
#define arc_ok_high_ptr (__comp_inst->arc_ok_high_p)
#define arc_ok_high (0+*__comp_inst->arc_ok_high_p)
#undef arc_ok_in
#undef arc_ok_in_ptr
#define arc_ok_in_ptr (__comp_inst->arc_ok_in_p)
#define arc_ok_in (0+*__comp_inst->arc_ok_in_p)
#undef arc_ok_low
#undef arc_ok_low_ptr
#define arc_ok_low_ptr (__comp_inst->arc_ok_low_p)
#define arc_ok_low (0+*__comp_inst->arc_ok_low_p)
#undef arc_max_starts
#undef arc_max_starts_ptr
#define arc_max_starts_ptr (__comp_inst->arc_max_starts_p)
#define arc_max_starts (0+*__comp_inst->arc_max_starts_p)
#undef arc_voltage_in
#undef arc_voltage_in_ptr
#define arc_voltage_in_ptr (__comp_inst->arc_voltage_in_p)
#define arc_voltage_in (0+*__comp_inst->arc_voltage_in_p)
#undef arc_voltage_offset
#undef arc_voltage_offset_ptr
#define arc_voltage_offset_ptr (__comp_inst->arc_voltage_offset_p)
#define arc_voltage_offset (0+*__comp_inst->arc_voltage_offset_p)
#undef arc_voltage_scale
#undef arc_voltage_scale_ptr
#define arc_voltage_scale_ptr (__comp_inst->arc_voltage_scale_p)
#define arc_voltage_scale (0+*__comp_inst->arc_voltage_scale_p)
#undef thc_auto
#undef thc_auto_ptr
#define thc_auto_ptr (__comp_inst->thc_auto_p)
#define thc_auto (0+*__comp_inst->thc_auto_p)
#undef axis_x_max_limit
#undef axis_x_max_limit_ptr
#define axis_x_max_limit_ptr (__comp_inst->axis_x_max_limit_p)
#define axis_x_max_limit (0+*__comp_inst->axis_x_max_limit_p)
#undef axis_x_min_limit
#undef axis_x_min_limit_ptr
#define axis_x_min_limit_ptr (__comp_inst->axis_x_min_limit_p)
#define axis_x_min_limit (0+*__comp_inst->axis_x_min_limit_p)
#undef axis_x_position
#undef axis_x_position_ptr
#define axis_x_position_ptr (__comp_inst->axis_x_position_p)
#define axis_x_position (0+*__comp_inst->axis_x_position_p)
#undef axis_y_max_limit
#undef axis_y_max_limit_ptr
#define axis_y_max_limit_ptr (__comp_inst->axis_y_max_limit_p)
#define axis_y_max_limit (0+*__comp_inst->axis_y_max_limit_p)
#undef axis_y_min_limit
#undef axis_y_min_limit_ptr
#define axis_y_min_limit_ptr (__comp_inst->axis_y_min_limit_p)
#define axis_y_min_limit (0+*__comp_inst->axis_y_min_limit_p)
#undef axis_y_position
#undef axis_y_position_ptr
#define axis_y_position_ptr (__comp_inst->axis_y_position_p)
#define axis_y_position (0+*__comp_inst->axis_y_position_p)
#undef axis_z_max_limit
#undef axis_z_max_limit_ptr
#define axis_z_max_limit_ptr (__comp_inst->axis_z_max_limit_p)
#define axis_z_max_limit (0+*__comp_inst->axis_z_max_limit_p)
#undef axis_z_min_limit
#undef axis_z_min_limit_ptr
#define axis_z_min_limit_ptr (__comp_inst->axis_z_min_limit_p)
#define axis_z_min_limit (0+*__comp_inst->axis_z_min_limit_p)
#undef axis_z_position
#undef axis_z_position_ptr
#define axis_z_position_ptr (__comp_inst->axis_z_position_p)
#define axis_z_position (0+*__comp_inst->axis_z_position_p)
#undef breakaway
#undef breakaway_ptr
#define breakaway_ptr (__comp_inst->breakaway_p)
#define breakaway (0+*__comp_inst->breakaway_p)
#undef consumable_change
#undef consumable_change_ptr
#define consumable_change_ptr (__comp_inst->consumable_change_p)
#define consumable_change (0+*__comp_inst->consumable_change_p)
#undef cornerlock_enable
#undef cornerlock_enable_ptr
#define cornerlock_enable_ptr (__comp_inst->cornerlock_enable_p)
#define cornerlock_enable (0+*__comp_inst->cornerlock_enable_p)
#undef cornerlock_threshold
#undef cornerlock_threshold_ptr
#define cornerlock_threshold_ptr (__comp_inst->cornerlock_threshold_p)
#define cornerlock_threshold (0+*__comp_inst->cornerlock_threshold_p)
#undef current_velocity
#undef current_velocity_ptr
#define current_velocity_ptr (__comp_inst->current_velocity_p)
#define current_velocity (0+*__comp_inst->current_velocity_p)
#undef cut_feed_rate
#undef cut_feed_rate_ptr
#define cut_feed_rate_ptr (__comp_inst->cut_feed_rate_p)
#define cut_feed_rate (0+*__comp_inst->cut_feed_rate_p)
#undef cut_height
#undef cut_height_ptr
#define cut_height_ptr (__comp_inst->cut_height_p)
#define cut_height (0+*__comp_inst->cut_height_p)
#undef cut_recovery
#undef cut_recovery_ptr
#define cut_recovery_ptr (__comp_inst->cut_recovery_p)
#define cut_recovery (0+*__comp_inst->cut_recovery_p)
#undef cut_volts
#undef cut_volts_ptr
#define cut_volts_ptr (__comp_inst->cut_volts_p)
#define cut_volts (0+*__comp_inst->cut_volts_p)
#undef cutting_start
#undef cutting_start_ptr
#define cutting_start_ptr (__comp_inst->cutting_start_p)
#define cutting_start (0+*__comp_inst->cutting_start_p)
#undef debug_print
#undef debug_print_ptr
#define debug_print_ptr (__comp_inst->debug_print_p)
#define debug_print (0+*__comp_inst->debug_print_p)
#undef external_estop
#undef external_estop_ptr
#define external_estop_ptr (__comp_inst->external_estop_p)
#define external_estop (0+*__comp_inst->external_estop_p)
#undef feed_override
#undef feed_override_ptr
#define feed_override_ptr (__comp_inst->feed_override_p)
#define feed_override (0+*__comp_inst->feed_override_p)
#undef feed_reduction
#undef feed_reduction_ptr
#define feed_reduction_ptr (__comp_inst->feed_reduction_p)
#define feed_reduction (0+*__comp_inst->feed_reduction_p)
#undef float_switch
#undef float_switch_ptr
#define float_switch_ptr (__comp_inst->float_switch_p)
#define float_switch (0+*__comp_inst->float_switch_p)
#undef float_switch_travel
#undef float_switch_travel_ptr
#define float_switch_travel_ptr (__comp_inst->float_switch_travel_p)
#define float_switch_travel (0+*__comp_inst->float_switch_travel_p)
#undef gcode_scale
#undef gcode_scale_ptr
#define gcode_scale_ptr (__comp_inst->gcode_scale_p)
#define gcode_scale (0+*__comp_inst->gcode_scale_p)
#undef height_override
#undef height_override_ptr
#define height_override_ptr (__comp_inst->height_override_p)
#define height_override (0+*__comp_inst->height_override_p)
#undef height_per_volt
#undef height_per_volt_ptr
#define height_per_volt_ptr (__comp_inst->height_per_volt_p)
#define height_per_volt (0+*__comp_inst->height_per_volt_p)
#undef homed
#undef homed_ptr
#define homed_ptr (__comp_inst->homed_p)
#define homed (0+*__comp_inst->homed_p)
#undef ignore_arc_ok_0
#undef ignore_arc_ok_0_ptr
#define ignore_arc_ok_0_ptr (__comp_inst->ignore_arc_ok_0_p)
#define ignore_arc_ok_0 (0+*__comp_inst->ignore_arc_ok_0_p)
#undef ignore_arc_ok_1
#undef ignore_arc_ok_1_ptr
#define ignore_arc_ok_1_ptr (__comp_inst->ignore_arc_ok_1_p)
#define ignore_arc_ok_1 (0+*__comp_inst->ignore_arc_ok_1_p)
#undef kerf_width
#undef kerf_width_ptr
#define kerf_width_ptr (__comp_inst->kerf_width_p)
#define kerf_width (0+*__comp_inst->kerf_width_p)
#undef override_jog
#undef override_jog_ptr
#define override_jog_ptr (__comp_inst->override_jog_p)
#define override_jog (0+*__comp_inst->override_jog_p)
#undef offset_set_probe
#undef offset_set_probe_ptr
#define offset_set_probe_ptr (__comp_inst->offset_set_probe_p)
#define offset_set_probe (0+*__comp_inst->offset_set_probe_p)
#undef offset_set_scribe
#undef offset_set_scribe_ptr
#define offset_set_scribe_ptr (__comp_inst->offset_set_scribe_p)
#define offset_set_scribe (0+*__comp_inst->offset_set_scribe_p)
#undef laser_recovery_start
#undef laser_recovery_start_ptr
#define laser_recovery_start_ptr (__comp_inst->laser_recovery_start_p)
#define laser_recovery_start (0+*__comp_inst->laser_recovery_start_p)
#undef laser_x_offset
#undef laser_x_offset_ptr
#define laser_x_offset_ptr (__comp_inst->laser_x_offset_p)
#define laser_x_offset (0+*__comp_inst->laser_x_offset_p)
#undef laser_y_offset
#undef laser_y_offset_ptr
#define laser_y_offset_ptr (__comp_inst->laser_y_offset_p)
#define laser_y_offset (0+*__comp_inst->laser_y_offset_p)
#undef lowpass_frequency
#undef lowpass_frequency_ptr
#define lowpass_frequency_ptr (__comp_inst->lowpass_frequency_p)
#define lowpass_frequency (0+*__comp_inst->lowpass_frequency_p)
#undef machine_is_on
#undef machine_is_on_ptr
#define machine_is_on_ptr (__comp_inst->machine_is_on_p)
#define machine_is_on (0+*__comp_inst->machine_is_on_p)
#undef max_offset
#undef max_offset_ptr
#define max_offset_ptr (__comp_inst->max_offset_p)
#define max_offset (0+*__comp_inst->max_offset_p)
#undef mesh_arc_ok
#undef mesh_arc_ok_ptr
#define mesh_arc_ok_ptr (__comp_inst->mesh_arc_ok_p)
#define mesh_arc_ok (0+*__comp_inst->mesh_arc_ok_p)
#undef mesh_enable
#undef mesh_enable_ptr
#define mesh_enable_ptr (__comp_inst->mesh_enable_p)
#define mesh_enable (0+*__comp_inst->mesh_enable_p)
#undef mode
#undef mode_ptr
#define mode_ptr (__comp_inst->mode_p)
#define mode (0+*__comp_inst->mode_p)
#undef motion_type
#undef motion_type_ptr
#define motion_type_ptr (__comp_inst->motion_type_p)
#define motion_type (0+*__comp_inst->motion_type_p)
#undef move_down
#undef move_down_ptr
#define move_down_ptr (__comp_inst->move_down_p)
#define move_down (0+*__comp_inst->move_down_p)
#undef move_up
#undef move_up_ptr
#define move_up_ptr (__comp_inst->move_up_p)
#define move_up (0+*__comp_inst->move_up_p)
#undef multi_tool
#undef multi_tool_ptr
#define multi_tool_ptr (__comp_inst->multi_tool_p)
#define multi_tool (0+*__comp_inst->multi_tool_p)
#undef offset_probe_delay
#undef offset_probe_delay_ptr
#define offset_probe_delay_ptr (__comp_inst->offset_probe_delay_p)
#define offset_probe_delay (0+*__comp_inst->offset_probe_delay_p)
#undef offset_probe_x
#undef offset_probe_x_ptr
#define offset_probe_x_ptr (__comp_inst->offset_probe_x_p)
#define offset_probe_x (0+*__comp_inst->offset_probe_x_p)
#undef offset_probe_y
#undef offset_probe_y_ptr
#define offset_probe_y_ptr (__comp_inst->offset_probe_y_p)
#define offset_probe_y (0+*__comp_inst->offset_probe_y_p)
#undef offsets_active
#undef offsets_active_ptr
#define offsets_active_ptr (__comp_inst->offsets_active_p)
#define offsets_active (0+*__comp_inst->offsets_active_p)
#undef ohmic_sense_on_delay
#undef ohmic_sense_on_delay_ptr
#define ohmic_sense_on_delay_ptr (__comp_inst->ohmic_sense_on_delay_p)
#define ohmic_sense_on_delay (0+*__comp_inst->ohmic_sense_on_delay_p)
#undef ohmic_sense_off_delay
#undef ohmic_sense_off_delay_ptr
#define ohmic_sense_off_delay_ptr (__comp_inst->ohmic_sense_off_delay_p)
#define ohmic_sense_off_delay (0+*__comp_inst->ohmic_sense_off_delay_p)
#undef ohmic_sense_in
#undef ohmic_sense_in_ptr
#define ohmic_sense_in_ptr (__comp_inst->ohmic_sense_in_p)
#define ohmic_sense_in (0+*__comp_inst->ohmic_sense_in_p)
#undef ohmic_max_attempts
#undef ohmic_max_attempts_ptr
#define ohmic_max_attempts_ptr (__comp_inst->ohmic_max_attempts_p)
#define ohmic_max_attempts (0+*__comp_inst->ohmic_max_attempts_p)
#undef ohmic_probe
#undef ohmic_probe_ptr
#define ohmic_probe_ptr (__comp_inst->ohmic_probe_p)
#define ohmic_probe (0+*__comp_inst->ohmic_probe_p)
#undef ohmic_probe_enable
#undef ohmic_probe_enable_ptr
#define ohmic_probe_enable_ptr (__comp_inst->ohmic_probe_enable_p)
#define ohmic_probe_enable (0+*__comp_inst->ohmic_probe_enable_p)
#undef ohmic_probe_offset
#undef ohmic_probe_offset_ptr
#define ohmic_probe_offset_ptr (__comp_inst->ohmic_probe_offset_p)
#define ohmic_probe_offset (0+*__comp_inst->ohmic_probe_offset_p)
#undef ohmic_test
#undef ohmic_test_ptr
#define ohmic_test_ptr (__comp_inst->ohmic_test_p)
#define ohmic_test (0+*__comp_inst->ohmic_test_p)
#undef ok_sample_counts
#undef ok_sample_counts_ptr
#define ok_sample_counts_ptr (__comp_inst->ok_sample_counts_p)
#define ok_sample_counts (0+*__comp_inst->ok_sample_counts_p)
#undef ok_sample_threshold
#undef ok_sample_threshold_ptr
#define ok_sample_threshold_ptr (__comp_inst->ok_sample_threshold_p)
#define ok_sample_threshold (0+*__comp_inst->ok_sample_threshold_p)
#undef pause_at_end
#undef pause_at_end_ptr
#define pause_at_end_ptr (__comp_inst->pause_at_end_p)
#define pause_at_end (0+*__comp_inst->pause_at_end_p)
#undef paused_motion_speed
#undef paused_motion_speed_ptr
#define paused_motion_speed_ptr (__comp_inst->paused_motion_speed_p)
#define paused_motion_speed (0+*__comp_inst->paused_motion_speed_p)
#undef pid_d_gain
#undef pid_d_gain_ptr
#define pid_d_gain_ptr (__comp_inst->pid_d_gain_p)
#define pid_d_gain (0+*__comp_inst->pid_d_gain_p)
#undef pid_i_gain
#undef pid_i_gain_ptr
#define pid_i_gain_ptr (__comp_inst->pid_i_gain_p)
#define pid_i_gain (0+*__comp_inst->pid_i_gain_p)
#undef pid_p_gain
#undef pid_p_gain_ptr
#define pid_p_gain_ptr (__comp_inst->pid_p_gain_p)
#define pid_p_gain (0+*__comp_inst->pid_p_gain_p)
#undef pierce_delay
#undef pierce_delay_ptr
#define pierce_delay_ptr (__comp_inst->pierce_delay_p)
#define pierce_delay (0+*__comp_inst->pierce_delay_p)
#undef probe_feed_rate
#undef probe_feed_rate_ptr
#define probe_feed_rate_ptr (__comp_inst->probe_feed_rate_p)
#define probe_feed_rate (0+*__comp_inst->probe_feed_rate_p)
#undef probe_final_speed
#undef probe_final_speed_ptr
#define probe_final_speed_ptr (__comp_inst->probe_final_speed_p)
#define probe_final_speed (0+*__comp_inst->probe_final_speed_p)
#undef pierce_height
#undef pierce_height_ptr
#define pierce_height_ptr (__comp_inst->pierce_height_p)
#define pierce_height (0+*__comp_inst->pierce_height_p)
#undef probe_start_height
#undef probe_start_height_ptr
#define probe_start_height_ptr (__comp_inst->probe_start_height_p)
#define probe_start_height (0+*__comp_inst->probe_start_height_p)
#undef probe_test
#undef probe_test_ptr
#define probe_test_ptr (__comp_inst->probe_test_p)
#define probe_test (0+*__comp_inst->probe_test_p)
#undef program_is_idle
#undef program_is_idle_ptr
#define program_is_idle_ptr (__comp_inst->program_is_idle_p)
#define program_is_idle (0+*__comp_inst->program_is_idle_p)
#undef program_is_paused
#undef program_is_paused_ptr
#define program_is_paused_ptr (__comp_inst->program_is_paused_p)
#define program_is_paused (0+*__comp_inst->program_is_paused_p)
#undef program_is_running
#undef program_is_running_ptr
#define program_is_running_ptr (__comp_inst->program_is_running_p)
#define program_is_running (0+*__comp_inst->program_is_running_p)
#undef puddle_jump_delay
#undef puddle_jump_delay_ptr
#define puddle_jump_delay_ptr (__comp_inst->puddle_jump_delay_p)
#define puddle_jump_delay (0+*__comp_inst->puddle_jump_delay_p)
#undef puddle_jump_height
#undef puddle_jump_height_ptr
#define puddle_jump_height_ptr (__comp_inst->puddle_jump_height_p)
#define puddle_jump_height (0+*__comp_inst->puddle_jump_height_p)
#undef requested_velocity
#undef requested_velocity_ptr
#define requested_velocity_ptr (__comp_inst->requested_velocity_p)
#define requested_velocity (0+*__comp_inst->requested_velocity_p)
#undef feed_upm
#undef feed_upm_ptr
#define feed_upm_ptr (__comp_inst->feed_upm_p)
#define feed_upm (0+*__comp_inst->feed_upm_p)
#undef resolution
#undef resolution_ptr
#define resolution_ptr (__comp_inst->resolution_p)
#define resolution (0+*__comp_inst->resolution_p)
#undef restart_delay
#undef restart_delay_ptr
#define restart_delay_ptr (__comp_inst->restart_delay_p)
#define restart_delay (0+*__comp_inst->restart_delay_p)
#undef safe_height
#undef safe_height_ptr
#define safe_height_ptr (__comp_inst->safe_height_p)
#define safe_height (0+*__comp_inst->safe_height_p)
#undef scribe_arm_delay
#undef scribe_arm_delay_ptr
#define scribe_arm_delay_ptr (__comp_inst->scribe_arm_delay_p)
#define scribe_arm_delay (0+*__comp_inst->scribe_arm_delay_p)
#undef scribe_on_delay
#undef scribe_on_delay_ptr
#define scribe_on_delay_ptr (__comp_inst->scribe_on_delay_p)
#define scribe_on_delay (0+*__comp_inst->scribe_on_delay_p)
#undef scribe_start
#undef scribe_start_ptr
#define scribe_start_ptr (__comp_inst->scribe_start_p)
#define scribe_start (0+*__comp_inst->scribe_start_p)
#undef setup_feed_rate
#undef setup_feed_rate_ptr
#define setup_feed_rate_ptr (__comp_inst->setup_feed_rate_p)
#define setup_feed_rate (0+*__comp_inst->setup_feed_rate_p)
#undef skip_ihs_distance
#undef skip_ihs_distance_ptr
#define skip_ihs_distance_ptr (__comp_inst->skip_ihs_distance_p)
#define skip_ihs_distance (0+*__comp_inst->skip_ihs_distance_p)
#undef spotting_start
#undef spotting_start_ptr
#define spotting_start_ptr (__comp_inst->spotting_start_p)
#define spotting_start (0+*__comp_inst->spotting_start_p)
#undef spotting_threshold
#undef spotting_threshold_ptr
#define spotting_threshold_ptr (__comp_inst->spotting_threshold_p)
#define spotting_threshold (0+*__comp_inst->spotting_threshold_p)
#undef spotting_time
#undef spotting_time_ptr
#define spotting_time_ptr (__comp_inst->spotting_time_p)
#define spotting_time (0+*__comp_inst->spotting_time_p)
#undef thc_delay
#undef thc_delay_ptr
#define thc_delay_ptr (__comp_inst->thc_delay_p)
#define thc_delay (0+*__comp_inst->thc_delay_p)
#undef thc_disable
#undef thc_disable_ptr
#define thc_disable_ptr (__comp_inst->thc_disable_p)
#define thc_disable (0+*__comp_inst->thc_disable_p)
#undef thc_enable
#undef thc_enable_ptr
#define thc_enable_ptr (__comp_inst->thc_enable_p)
#define thc_enable (0+*__comp_inst->thc_enable_p)
#undef thc_feed_rate
#undef thc_feed_rate_ptr
#define thc_feed_rate_ptr (__comp_inst->thc_feed_rate_p)
#define thc_feed_rate (0+*__comp_inst->thc_feed_rate_p)
#undef thc_sample_counts
#undef thc_sample_counts_ptr
#define thc_sample_counts_ptr (__comp_inst->thc_sample_counts_p)
#define thc_sample_counts (0+*__comp_inst->thc_sample_counts_p)
#undef thc_sample_threshold
#undef thc_sample_threshold_ptr
#define thc_sample_threshold_ptr (__comp_inst->thc_sample_threshold_p)
#define thc_sample_threshold (0+*__comp_inst->thc_sample_threshold_p)
#undef thc_threshold
#undef thc_threshold_ptr
#define thc_threshold_ptr (__comp_inst->thc_threshold_p)
#define thc_threshold (0+*__comp_inst->thc_threshold_p)
#undef torch_enable
#undef torch_enable_ptr
#define torch_enable_ptr (__comp_inst->torch_enable_p)
#define torch_enable (0+*__comp_inst->torch_enable_p)
#undef torch_off
#undef torch_off_ptr
#define torch_off_ptr (__comp_inst->torch_off_p)
#define torch_off (0+*__comp_inst->torch_off_p)
#undef torch_pulse_start
#undef torch_pulse_start_ptr
#define torch_pulse_start_ptr (__comp_inst->torch_pulse_start_p)
#define torch_pulse_start (0+*__comp_inst->torch_pulse_start_p)
#undef torch_pulse_time
#undef torch_pulse_time_ptr
#define torch_pulse_time_ptr (__comp_inst->torch_pulse_time_p)
#define torch_pulse_time (0+*__comp_inst->torch_pulse_time_p)
#undef units_per_mm
#undef units_per_mm_ptr
#define units_per_mm_ptr (__comp_inst->units_per_mm_p)
#define units_per_mm (0+*__comp_inst->units_per_mm_p)
#undef use_auto_volts
#undef use_auto_volts_ptr
#define use_auto_volts_ptr (__comp_inst->use_auto_volts_p)
#define use_auto_volts (0+*__comp_inst->use_auto_volts_p)
#undef voidlock_enable
#undef voidlock_enable_ptr
#define voidlock_enable_ptr (__comp_inst->voidlock_enable_p)
#define voidlock_enable (0+*__comp_inst->voidlock_enable_p)
#undef voidlock_on_cycles
#undef voidlock_on_cycles_ptr
#define voidlock_on_cycles_ptr (__comp_inst->voidlock_on_cycles_p)
#define voidlock_on_cycles (0+*__comp_inst->voidlock_on_cycles_p)
#undef voidlock_off_cycles
#undef voidlock_off_cycles_ptr
#define voidlock_off_cycles_ptr (__comp_inst->voidlock_off_cycles_p)
#define voidlock_off_cycles (0+*__comp_inst->voidlock_off_cycles_p)
#undef voidlock_slope
#undef voidlock_slope_ptr
#define voidlock_slope_ptr (__comp_inst->voidlock_slope_p)
#define voidlock_slope (0+*__comp_inst->voidlock_slope_p)
#undef x_offset
#undef x_offset_ptr
#define x_offset_ptr (__comp_inst->x_offset_p)
#define x_offset (0+*__comp_inst->x_offset_p)
#undef x_offset_current
#undef x_offset_current_ptr
#define x_offset_current_ptr (__comp_inst->x_offset_current_p)
#define x_offset_current (0+*__comp_inst->x_offset_current_p)
#undef xy_feed_rate
#undef xy_feed_rate_ptr
#define xy_feed_rate_ptr (__comp_inst->xy_feed_rate_p)
#define xy_feed_rate (0+*__comp_inst->xy_feed_rate_p)
#undef y_offset
#undef y_offset_ptr
#define y_offset_ptr (__comp_inst->y_offset_p)
#define y_offset (0+*__comp_inst->y_offset_p)
#undef y_offset_current
#undef y_offset_current_ptr
#define y_offset_current_ptr (__comp_inst->y_offset_current_p)
#define y_offset_current (0+*__comp_inst->y_offset_current_p)
#undef z_offset_current
#undef z_offset_current_ptr
#define z_offset_current_ptr (__comp_inst->z_offset_current_p)
#define z_offset_current (0+*__comp_inst->z_offset_current_p)
#undef zero_window
#undef zero_window_ptr
#define zero_window_ptr (__comp_inst->zero_window_p)
#define zero_window (0+*__comp_inst->zero_window_p)
#undef adaptive_feed
#undef adaptive_feed_ptr
#define adaptive_feed_ptr (__comp_inst->adaptive_feed_p)
#define adaptive_feed (*__comp_inst->adaptive_feed_p)
#undef arc_ok_out
#undef arc_ok_out_ptr
#define arc_ok_out_ptr (__comp_inst->arc_ok_out_p)
#define arc_ok_out (*__comp_inst->arc_ok_out_p)
#undef arc_voltage_out
#undef arc_voltage_out_ptr
#define arc_voltage_out_ptr (__comp_inst->arc_voltage_out_p)
#define arc_voltage_out (*__comp_inst->arc_voltage_out_p)
#undef consumable_changing
#undef consumable_changing_ptr
#define consumable_changing_ptr (__comp_inst->consumable_changing_p)
#define consumable_changing (*__comp_inst->consumable_changing_p)
#undef cornerlock_is_locked
#undef cornerlock_is_locked_ptr
#define cornerlock_is_locked_ptr (__comp_inst->cornerlock_is_locked_p)
#define cornerlock_is_locked (*__comp_inst->cornerlock_is_locked_p)
#undef cut_length
#undef cut_length_ptr
#define cut_length_ptr (__comp_inst->cut_length_p)
#define cut_length (*__comp_inst->cut_length_p)
#undef cut_recovering
#undef cut_recovering_ptr
#define cut_recovering_ptr (__comp_inst->cut_recovering_p)
#define cut_recovering (*__comp_inst->cut_recovering_p)
#undef cut_time
#undef cut_time_ptr
#define cut_time_ptr (__comp_inst->cut_time_p)
#define cut_time (*__comp_inst->cut_time_p)
#undef cutting_stop
#undef cutting_stop_ptr
#define cutting_stop_ptr (__comp_inst->cutting_stop_p)
#define cutting_stop (*__comp_inst->cutting_stop_p)
#undef feed_hold
#undef feed_hold_ptr
#define feed_hold_ptr (__comp_inst->feed_hold_p)
#define feed_hold (*__comp_inst->feed_hold_p)
#undef jog_inhibit
#undef jog_inhibit_ptr
#define jog_inhibit_ptr (__comp_inst->jog_inhibit_p)
#define jog_inhibit (*__comp_inst->jog_inhibit_p)
#undef laser_recovery_state
#undef laser_recovery_state_ptr
#define laser_recovery_state_ptr (__comp_inst->laser_recovery_state_p)
#define laser_recovery_state (*__comp_inst->laser_recovery_state_p)
#undef led_down
#undef led_down_ptr
#define led_down_ptr (__comp_inst->led_down_p)
#define led_down (*__comp_inst->led_down_p)
#undef led_up
#undef led_up_ptr
#define led_up_ptr (__comp_inst->led_up_p)
#define led_up (*__comp_inst->led_up_p)
#undef offset_scale
#undef offset_scale_ptr
#define offset_scale_ptr (__comp_inst->offset_scale_p)
#define offset_scale (*__comp_inst->offset_scale_p)
#undef ohmic_enable
#undef ohmic_enable_ptr
#define ohmic_enable_ptr (__comp_inst->ohmic_enable_p)
#define ohmic_enable (*__comp_inst->ohmic_enable_p)
#undef ohmic_sense_out
#undef ohmic_sense_out_ptr
#define ohmic_sense_out_ptr (__comp_inst->ohmic_sense_out_p)
#define ohmic_sense_out (*__comp_inst->ohmic_sense_out_p)
#undef paused_motion
#undef paused_motion_ptr
#define paused_motion_ptr (__comp_inst->paused_motion_p)
#define paused_motion (*__comp_inst->paused_motion_p)
#undef paused_time
#undef paused_time_ptr
#define paused_time_ptr (__comp_inst->paused_time_p)
#define paused_time (*__comp_inst->paused_time_p)
#undef pierce_count
#undef pierce_count_ptr
#define pierce_count_ptr (__comp_inst->pierce_count_p)
#define pierce_count (*__comp_inst->pierce_count_p)
#undef probe_test_error
#undef probe_test_error_ptr
#define probe_test_error_ptr (__comp_inst->probe_test_error_p)
#define probe_test_error (*__comp_inst->probe_test_error_p)
#undef probe_time
#undef probe_time_ptr
#define probe_time_ptr (__comp_inst->probe_time_p)
#define probe_time (*__comp_inst->probe_time_p)
#undef program_pause
#undef program_pause_ptr
#define program_pause_ptr (__comp_inst->program_pause_p)
#define program_pause (*__comp_inst->program_pause_p)
#undef program_resume
#undef program_resume_ptr
#define program_resume_ptr (__comp_inst->program_resume_p)
#define program_resume (*__comp_inst->program_resume_p)
#undef program_run
#undef program_run_ptr
#define program_run_ptr (__comp_inst->program_run_p)
#define program_run (*__comp_inst->program_run_p)
#undef program_stop
#undef program_stop_ptr
#define program_stop_ptr (__comp_inst->program_stop_p)
#define program_stop (*__comp_inst->program_stop_p)
#undef rapid_time
#undef rapid_time_ptr
#define rapid_time_ptr (__comp_inst->rapid_time_p)
#define rapid_time (*__comp_inst->rapid_time_p)
#undef run_time
#undef run_time_ptr
#define run_time_ptr (__comp_inst->run_time_p)
#define run_time (*__comp_inst->run_time_p)
#undef safe_height_is_limited
#undef safe_height_is_limited_ptr
#define safe_height_is_limited_ptr (__comp_inst->safe_height_is_limited_p)
#define safe_height_is_limited (*__comp_inst->safe_height_is_limited_p)
#undef sensor_active
#undef sensor_active_ptr
#define sensor_active_ptr (__comp_inst->sensor_active_p)
#define sensor_active (*__comp_inst->sensor_active_p)
#undef scribe_arm
#undef scribe_arm_ptr
#define scribe_arm_ptr (__comp_inst->scribe_arm_p)
#define scribe_arm (*__comp_inst->scribe_arm_p)
#undef scribe_on
#undef scribe_on_ptr
#define scribe_on_ptr (__comp_inst->scribe_on_p)
#define scribe_on (*__comp_inst->scribe_on_p)
#undef state_out
#undef state_out_ptr
#define state_out_ptr (__comp_inst->state_out_p)
#define state_out (*__comp_inst->state_out_p)
#undef stop_type_out
#undef stop_type_out_ptr
#define stop_type_out_ptr (__comp_inst->stop_type_out_p)
#define stop_type_out (*__comp_inst->stop_type_out_p)
#undef thc_active
#undef thc_active_ptr
#define thc_active_ptr (__comp_inst->thc_active_p)
#define thc_active (*__comp_inst->thc_active_p)
#undef thc_enabled
#undef thc_enabled_ptr
#define thc_enabled_ptr (__comp_inst->thc_enabled_p)
#define thc_enabled (*__comp_inst->thc_enabled_p)
#undef torch_on
#undef torch_on_ptr
#define torch_on_ptr (__comp_inst->torch_on_p)
#define torch_on (*__comp_inst->torch_on_p)
#undef torch_time
#undef torch_time_ptr
#define torch_time_ptr (__comp_inst->torch_time_p)
#define torch_time (*__comp_inst->torch_time_p)
#undef voidlock_is_locked
#undef voidlock_is_locked_ptr
#define voidlock_is_locked_ptr (__comp_inst->voidlock_is_locked_p)
#define voidlock_is_locked (*__comp_inst->voidlock_is_locked_p)
#undef x_offset_counts
#undef x_offset_counts_ptr
#define x_offset_counts_ptr (__comp_inst->x_offset_counts_p)
#define x_offset_counts (*__comp_inst->x_offset_counts_p)
#undef xy_offset_enable
#undef xy_offset_enable_ptr
#define xy_offset_enable_ptr (__comp_inst->xy_offset_enable_p)
#define xy_offset_enable (*__comp_inst->xy_offset_enable_p)
#undef y_offset_counts
#undef y_offset_counts_ptr
#define y_offset_counts_ptr (__comp_inst->y_offset_counts_p)
#define y_offset_counts (*__comp_inst->y_offset_counts_p)
#undef z_height
#undef z_height_ptr
#define z_height_ptr (__comp_inst->z_height_p)
#define z_height (*__comp_inst->z_height_p)
#undef z_offset_counts
#undef z_offset_counts_ptr
#define z_offset_counts_ptr (__comp_inst->z_offset_counts_p)
#define z_offset_counts (*__comp_inst->z_offset_counts_p)
#undef z_offset_enable
#undef z_offset_enable_ptr
#define z_offset_enable_ptr (__comp_inst->z_offset_enable_p)
#define z_offset_enable (*__comp_inst->z_offset_enable_p)
#undef z_relative
#undef z_relative_ptr
#define z_relative_ptr (__comp_inst->z_relative_p)
#define z_relative (*__comp_inst->z_relative_p)
#undef current_feed_rate
#undef current_feed_rate_ptr
#define current_feed_rate_ptr (__comp_inst->current_feed_rate_p)
#define current_feed_rate (*__comp_inst->current_feed_rate_p)
#undef requested_feed_rate
#undef requested_feed_rate_ptr
#define requested_feed_rate_ptr (__comp_inst->requested_feed_rate_p)
#define requested_feed_rate (*__comp_inst->requested_feed_rate_p)
#undef low_cut_volts
#undef low_cut_volts_ptr
#define low_cut_volts_ptr (__comp_inst->low_cut_volts_p)
#define low_cut_volts (0+*__comp_inst->low_cut_volts_p)
#undef target_samples
#undef target_samples_ptr
#define target_samples_ptr (__comp_inst->target_samples_p)
#define target_samples (0+*__comp_inst->target_samples_p)
#undef target_volts
#undef target_volts_ptr
#define target_volts_ptr (__comp_inst->target_volts_p)
#define target_volts (*__comp_inst->target_volts_p)
#undef angle_x_y
#define angle_x_y (__comp_inst->angle_x_y_p)
#undef arc_fail_timer
#define arc_fail_timer (__comp_inst->arc_fail_timer_p)
#undef arc_lost_timer
#define arc_lost_timer (__comp_inst->arc_lost_timer_p)
#undef arc_starts
#define arc_starts (__comp_inst->arc_starts_p)
#undef arc_valid_timer
#define arc_valid_timer (__comp_inst->arc_valid_timer_p)
#undef arc_voltage_raw
#define arc_voltage_raw (__comp_inst->arc_voltage_raw_p)
#undef arc_voltage_buffer_index
#define arc_voltage_buffer_index (__comp_inst->arc_voltage_buffer_index_p)
#undef ok_sampler_samples
#define ok_sampler_samples (__comp_inst->ok_sampler_samples_p)
#undef auto_cut
#define auto_cut (__comp_inst->auto_cut_p)
#undef axis_x_finish
#define axis_x_finish (__comp_inst->axis_x_finish_p)
#undef axis_x_start
#define axis_x_start (__comp_inst->axis_x_start_p)
#undef axis_y_finish
#define axis_y_finish (__comp_inst->axis_y_finish_p)
#undef axis_y_start
#define axis_y_start (__comp_inst->axis_y_start_p)
#undef cons_change_clear
#define cons_change_clear (__comp_inst->cons_change_clear_p)
#undef count
#define count (__comp_inst->count_p)
#undef cut_height_first
#define cut_height_first (__comp_inst->cut_height_first_p)
#undef cut_height_last
#define cut_height_last (__comp_inst->cut_height_last_p)
#undef cut_offset
#define cut_offset (__comp_inst->cut_offset_p)
#undef cut_started
#define cut_started (__comp_inst->cut_started_p)
#undef cut_target
#define cut_target (__comp_inst->cut_target_p)
#undef error_message
#define error_message (__comp_inst->error_message_p)
#undef first_cut_finished
#define first_cut_finished (__comp_inst->first_cut_finished_p)
#undef float_detected
#define float_detected (__comp_inst->float_detected_p)
#undef height_ovr_counts
#define height_ovr_counts (__comp_inst->height_ovr_counts_p)
#undef height_ovr_old
#define height_ovr_old (__comp_inst->height_ovr_old_p)
#undef initialized
#define initialized (__comp_inst->initialized_p)
#undef laser_x_target
#define laser_x_target (__comp_inst->laser_x_target_p)
#undef laser_y_target
#define laser_y_target (__comp_inst->laser_y_target_p)
#undef last_arc_voltage
#define last_arc_voltage (__comp_inst->last_arc_voltage_p)
#undef manual_cut
#define manual_cut (__comp_inst->manual_cut_p)
#undef offset_datum
#define offset_datum (__comp_inst->offset_datum_p)
#undef offset_max
#define offset_max (__comp_inst->offset_max_p)
#undef offset_min
#define offset_min (__comp_inst->offset_min_p)
#undef offset_probe_timer
#define offset_probe_timer (__comp_inst->offset_probe_timer_p)
#undef offset_probing
#define offset_probing (__comp_inst->offset_probing_p)
#undef offset_res
#define offset_res (__comp_inst->offset_res_p)
#undef offset_set
#define offset_set (__comp_inst->offset_set_p)
#undef ohmic_attempts
#define ohmic_attempts (__comp_inst->ohmic_attempts_p)
#undef ohmic_detected
#define ohmic_detected (__comp_inst->ohmic_detected_p)
#undef ohmic_sense_counts
#define ohmic_sense_counts (__comp_inst->ohmic_sense_counts_p)
#undef old_resolution
#define old_resolution (__comp_inst->old_resolution_p)
#undef op_x_start
#define op_x_start (__comp_inst->op_x_start_p)
#undef op_x_target
#define op_x_target (__comp_inst->op_x_target_p)
#undef op_x_velocity
#define op_x_velocity (__comp_inst->op_x_velocity_p)
#undef op_xy_angle
#define op_xy_angle (__comp_inst->op_xy_angle_p)
#undef op_y_start
#define op_y_start (__comp_inst->op_y_start_p)
#undef op_y_target
#define op_y_target (__comp_inst->op_y_target_p)
#undef op_y_velocity
#define op_y_velocity (__comp_inst->op_y_velocity_p)
#undef pause_at_end_timer
#define pause_at_end_timer (__comp_inst->pause_at_end_timer_p)
#undef paused_motion_timer
#define paused_motion_timer (__comp_inst->paused_motion_timer_p)
#undef pid_error_now
#define pid_error_now (__comp_inst->pid_error_now_p)
#undef pid_error_old
#define pid_error_old (__comp_inst->pid_error_old_p)
#undef pid_output
#define pid_output (__comp_inst->pid_output_p)
#undef pierce_target
#define pierce_target (__comp_inst->pierce_target_p)
#undef pierce_timer
#define pierce_timer (__comp_inst->pierce_timer_p)
#undef probe_at_bottom
#define probe_at_bottom (__comp_inst->probe_at_bottom_p)
#undef probe_inhibit
#define probe_inhibit (__comp_inst->probe_inhibit_p)
#undef probe_offset
#define probe_offset (__comp_inst->probe_offset_p)
#undef probe_required
#define probe_required (__comp_inst->probe_required_p)
#undef probe_retry
#define probe_retry (__comp_inst->probe_retry_p)
#undef probe_start_target
#define probe_start_target (__comp_inst->probe_start_target_p)
#undef probe_testing
#define probe_testing (__comp_inst->probe_testing_p)
#undef probe_velocity
#define probe_velocity (__comp_inst->probe_velocity_p)
#undef puddle_jump_percent
#define puddle_jump_percent (__comp_inst->puddle_jump_percent_p)
#undef puddle_jump_target
#define puddle_jump_target (__comp_inst->puddle_jump_target_p)
#undef puddle_jump_timer
#define puddle_jump_timer (__comp_inst->puddle_jump_timer_p)
#undef recovery_velocity
#define recovery_velocity (__comp_inst->recovery_velocity_p)
#undef res
#define res (__comp_inst->res_p)
#undef restart_timer
#define restart_timer (__comp_inst->restart_timer_p)
#undef safe_alarm
#define safe_alarm (__comp_inst->safe_alarm_p)
#undef safe_available
#define safe_available (__comp_inst->safe_available_p)
#undef safe_min
#define safe_min (__comp_inst->safe_min_p)
#undef safe_preferred
#define safe_preferred (__comp_inst->safe_preferred_p)
#undef safe_target
#define safe_target (__comp_inst->safe_target_p)
#undef setup_velocity
#define setup_velocity (__comp_inst->setup_velocity_p)
#undef scribe_arm_timer
#define scribe_arm_timer (__comp_inst->scribe_arm_timer_p)
#undef scribe_on_timer
#define scribe_on_timer (__comp_inst->scribe_on_timer_p)
#undef scribe_pause
#define scribe_pause (__comp_inst->scribe_pause_p)
#undef spotting
#define spotting (__comp_inst->spotting_p)
#undef spotting_timer
#define spotting_timer (__comp_inst->spotting_timer_p)
#undef state_old
#define state_old (__comp_inst->state_old_p)
#undef statistics_reset
#define statistics_reset (__comp_inst->statistics_reset_p)
#undef target_total
#define target_total (__comp_inst->target_total_p)
#undef thc_activated
#define thc_activated (__comp_inst->thc_activated_p)
#undef thc_activated_timer
#define thc_activated_timer (__comp_inst->thc_activated_timer_p)
#undef thc_delay_timer
#define thc_delay_timer (__comp_inst->thc_delay_timer_p)
#undef thc_sampler_samples
#define thc_sampler_samples (__comp_inst->thc_sampler_samples_p)
#undef thc_velocity
#define thc_velocity (__comp_inst->thc_velocity_p)
#undef torch_off_timer
#define torch_off_timer (__comp_inst->torch_off_timer_p)
#undef torch_pulse_timer
#define torch_pulse_timer (__comp_inst->torch_pulse_timer_p)
#undef velocity_scale
#define velocity_scale (__comp_inst->velocity_scale_p)
#undef voidlock_change
#define voidlock_change (__comp_inst->voidlock_change_p)
#undef voidlock_off_count
#define voidlock_off_count (__comp_inst->voidlock_off_count_p)
#undef voidlock_on_count
#define voidlock_on_count (__comp_inst->voidlock_on_count_p)
#undef voidlock_threshold
#define voidlock_threshold (__comp_inst->voidlock_threshold_p)
#undef x_velocity
#define x_velocity (__comp_inst->x_velocity_p)
#undef y_velocity
#define y_velocity (__comp_inst->y_velocity_p)
#undef z_max
#define z_max (__comp_inst->z_max_p)
#undef z_pierce
#define z_pierce (__comp_inst->z_pierce_p)
#undef zero_target
#define zero_target (__comp_inst->zero_target_p)


#line 333 "/home/end/projects/linuxcnc/src/hal/components/plasmac.comp"

#include "rtapi_math.h"

typedef enum{IDLE,
             PROBE_HEIGHT,
             PROBE_DOWN,
             PROBE_UP,
             ZERO_HEIGHT,
             PIERCE_HEIGHT,
             TORCH_ON,
             ARC_OK,
             PIERCE_DELAY,
             PUDDLE_JUMP,
             CUT_HEIGHT,
             CUT_MODE_01,
             CUT_MODE_2,
             PAUSE_AT_END,
             SAFE_HEIGHT,
             MAX_HEIGHT,
             END_CUT,
             END_JOB,
             TORCHPULSE,
             PAUSED_MOTION,
             OHMIC_TEST,
             PROBE_TEST,
             SCRIBING,
             CONSUMABLE_CHANGE_ON,
             CONSUMABLE_CHANGE_OFF,
             CUT_RECOVERY_ON,
             CUT_RECOVERY_OFF,
             DEBUG,
            } state_t;

typedef enum{NONE,
             STOP,
             WAIT,
             PAUSE,
            } stop_type_t;

typedef enum{ZERO,
             UP,
             DOWN,
            } move_direction_t;

typedef enum{FLOAT,
             OHMIC,
            } probe_type_t;

typedef enum{EMPTY,
             CUTTING,
             SCRIBE,
             SPOTTING,
            } tool_t;

typedef enum{OFF,
             SET,
             SETTING,
             ON,
             RESET,
             RESETTING,
         } laser_recovery_state_t;

state_t state = IDLE;
stop_type_t stop_type = NONE;
move_direction_t move_direction = ZERO;
probe_type_t probe_type = FLOAT;
tool_t tool = EMPTY;
laser_recovery_state_t laser_recovery = OFF;

/* setup the arc voltage ring buffer */
#define BUFFERSIZE 1000
#define READ_OK 0
#define READ_THC 1
float arc_voltage_buffer[BUFFERSIZE];

/* read the arc voltage buffer */
float read_arc_voltage_buffer(int caller, int size, int index, float target, float threshold){
    int reads = 0;
    double sum = 0;
    int errors = 0;
    while(reads < size){
        if (arc_voltage_buffer[index] < target - threshold || arc_voltage_buffer[index] > target + threshold){
            if(caller == READ_THC){
                return 0;
            }else{
                errors++;
            }
        }
        sum += arc_voltage_buffer[index];
        if(index == 0){
            index = BUFFERSIZE;
        }else{
            index--;
        }
        reads++;
    }
    if(caller == READ_THC){
        return(sum / reads);
    }else{
        return(errors);
    }
}

/* set an axis eoffset position at a set velocity */
int offset_move(int offset, int vel, int target){
    if(offset - vel > target){
        offset -= vel;
    }else if(offset + vel < target){
        offset += vel;
    }else{
        offset = target;
    }
    return offset;
}

FUNCTION(_) {

    /* set message level */
    if(!debug_print && rtapi_get_msg_level() != 1){
        rtapi_set_msg_level(1);
    }else if(debug_print && rtapi_get_msg_level() != 3){
        rtapi_set_msg_level(3);
    }

    /* validate ok sample size for mode 0 */
    if(mode == 0){
        if(ok_sample_counts < 1){
            ok_sampler_samples = 1;
        }else if(ok_sample_counts > BUFFERSIZE){
            ok_sampler_samples = BUFFERSIZE;
        }else{
            ok_sampler_samples = ok_sample_counts;
        }
    }

    /* validate thc sample size */
    if(mode < 2){
        if(thc_sample_counts < 1){
            thc_sampler_samples = 1;
        }else if(thc_sample_counts > BUFFERSIZE){
            thc_sampler_samples = BUFFERSIZE;
        }else{
            thc_sampler_samples = thc_sample_counts;
        }
    }

    /* wait until arc_voltage_in is valid */
    if(isinf(arc_voltage_in) || isnan(arc_voltage_in)){
        arc_valid_timer += fperiod;
        if(arc_valid_timer > 1){
            rtapi_print_msg(RTAPI_MSG_ERR,"invalid arc-voltage-in\n");
            arc_valid_timer = 0;
        }
        return;
    }

    /* set scaling */
    if(resolution > 1000){
        res = 1000;
    }else if(resolution < 1){
        res = 1;
    }else{
        res = resolution;
    }
    if(units_per_mm == 1){
        offset_res = res;
    }else{
        offset_res = res * 10;
    }
    offset_scale = units_per_mm * fperiod / res;
    velocity_scale = res / units_per_mm / 60;
    recovery_velocity = cut_feed_rate * velocity_scale * 0.5;

    /* set the active tool */
    if(cutting_start){ //  this allows M3 for cutting as well as M3 $0
        tool = CUTTING;
    }else if(multi_tool && scribe_start && !cutting_start && !spotting_start){
        tool = SCRIBE;
    }else if(multi_tool && spotting_start && !cutting_start && !scribe_start){
        tool = SPOTTING;
    }else{
        tool = EMPTY;
    }

    /* check for active sensor */
    if(breakaway || float_switch || ohmic_detected){
        sensor_active = TRUE;
    }else{
        sensor_active = FALSE;
    }


// I don't recall why z_relative was originally created!!!
// commit # b29d1af 24 Oct 2019
//    /* output the relative Z height */
//    if(zero_target){
//        z_relative = z_offset_current - zero_target * offset_scale;
//    }else{
//        z_relative = axis_z_position - axis_z_min_limit;
//    }

// this height calculation is really only the target z height, we may not have reached the target yet
    /* output current z height */
//    z_height = (z_offset_counts - zero_target) * offset_scale;

// this is probably more correct
// we don't use z_relative anywhere so we could probably just rename it to z_height and remove the z_relative pin.
    /* output the relative Z height */
    if(zero_target){
        z_height = z_offset_current - (zero_target * offset_scale);
    }else{
        z_height = axis_z_position - axis_z_min_limit;
    }

// temp for auto-thc testing
//  check when we at "at speed"
    current_feed_rate = current_velocity * 60;

    /* convert feed rates to velocity */
    setup_velocity = setup_feed_rate * velocity_scale;
    if(probe_feed_rate < setup_feed_rate){
        probe_velocity = probe_feed_rate * velocity_scale;
    }else{
        probe_velocity = setup_velocity;
    }
    if(mode == 2){
        thc_velocity = thc_feed_rate * velocity_scale * pid_p_gain / 100;
    }else{
        thc_velocity = thc_feed_rate * velocity_scale;
    }
    if(thc_velocity < 1){
        thc_velocity = 1;
    }

    /* turn torch off if torch off timer completed */
    if(torch_off_timer > 0){
        torch_off_timer -= fperiod;
        if(torch_off_timer <= 0){
            torch_on = FALSE;
            torch_off_timer = 0;
        }
    }

    /* turn torch off from external input */
    if(torch_off){
        torch_on = FALSE;
    }

    /* set THC state */
    thc_enabled = (thc_enable && !thc_disable && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1 && (arc_lost_timer > arc_lost_delay - 0.000001) ? 1:0);

    /* set THC status */
    thc_active = (state == CUT_MODE_01 || state == CUT_MODE_2) && ((mode < 2 && target_volts) || (mode == 2 && arc_ok_out)) && thc_enabled && !cornerlock_is_locked && !voidlock_is_locked ? 1:0;
    if(thc_active){
        thc_activated = TRUE;
        thc_activated_timer = 0.25;
    }else if(thc_activated && (state == CUT_MODE_01 || state == CUT_MODE_2)){
        thc_activated_timer -= fperiod;
        if(thc_activated_timer <= 0){
            thc_activated = FALSE;
        }
    }else if(probe_required){
        thc_activated = FALSE;
    }

    /* set ohmic probe state */
    ohmic_detected = ohmic_probe && ohmic_probe_enable;

    /* set adaptive feed reduction if no paused motion */
    if(state != PAUSED_MOTION){
        if(feed_reduction < 10 && (state == CUT_MODE_01 || state == CUT_MODE_2)){
            adaptive_feed = 1;
        }else if(feed_reduction < 100 && (state == CUT_MODE_01 || state == CUT_MODE_2)){
            adaptive_feed = feed_reduction * 0.01;
        }else{
            adaptive_feed = 1;
        }
    }

    /* check for a manual cut */
    if(tool == CUTTING && !auto_cut){
        manual_cut = TRUE;
    }

    /* check for an abort */
    /* or for a pause or wait while active */
    if(auto_cut){
        if(state == IDLE && sensor_active && !program_is_idle){
            torch_on = FALSE;
            if(!program_is_paused && !program_pause){
                if(breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                                  "program is paused.\n");
                }else if(float_switch){
                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                                  "program is paused.\n");
                }else if(ohmic_detected){
                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                                  "program is paused.\n");
                }
            }
            program_pause = TRUE;
            if(stop_type != WAIT){
                stop_type = PAUSE;
            }
            probe_required = TRUE;
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(!probe_test && program_is_idle && cut_started && !program_run){
            if(consumable_changing){
                state = CONSUMABLE_CHANGE_OFF;
            }else if(cut_recovering){
                state = CUT_RECOVERY_OFF;
            }else{
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = STOP;
                program_stop = TRUE;
                cut_started = FALSE;
                probe_required = TRUE;
                axis_x_finish = 0;
                axis_y_finish = 0;
                if(pause_at_end_timer){
                    state = PAUSE_AT_END;
                }else{
                    state = MAX_HEIGHT;
                }
            }
        }else if(!probe_test && state > IDLE && state <= CUT_MODE_2 && stop_type == NONE && cut_started){
            if(program_is_paused){
                torch_on = FALSE;
                stop_type = PAUSE;
                probe_required = TRUE;
                pause_at_end_timer = pause_at_end;
                state = MAX_HEIGHT;
            }else if(tool == EMPTY){
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = WAIT;
                if(thc_enabled || !torch_enable){
                    axis_x_finish = axis_x_position;
                    axis_y_finish = axis_y_position;
                }else{
                    axis_x_finish = 0;
                    axis_y_finish = 0;
                }
                pause_at_end_timer = pause_at_end;
                state = PAUSE_AT_END;
            }else if(breakaway){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && float_switch){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && ohmic_detected){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && !arc_ok_out && torch_enable && !torch_off && !(mesh_enable || ignore_arc_ok_0 || ignore_arc_ok_1)){ ;
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"valid arc lost\n"
                                              "program is paused.\n");
                state = MAX_HEIGHT;
            }
        }
    }else if(manual_cut){
        if(tool == EMPTY){
            manual_cut = FALSE;
            torch_on = FALSE;
            stop_type = STOP;
            program_stop = TRUE;
            cut_started = FALSE;
            probe_required = TRUE;
            axis_x_finish = 0;
            axis_y_finish = 0;
            state = MAX_HEIGHT;
        }
    }

    /* calculate arc voltage */
    if(lowpass_frequency){
        arc_voltage_raw += (arc_voltage_in - arc_voltage_raw) * (1 - exp(-(2 * M_PI * fabs(lowpass_frequency)) * fperiod));
    }else{
        arc_voltage_raw = arc_voltage_in;
    }
    arc_voltage_out = round(((fabs(arc_voltage_raw) - arc_voltage_offset) * fabs(arc_voltage_scale)) * 1000) / 1000;
    if(arc_voltage_out < zero_window && arc_voltage_out > zero_window * -1){
        arc_voltage_out = 0;
    }

    /* temporary for forum issue #210558 */
    if(thc_active && low_cut_volts && arc_voltage_out < low_cut_volts){
        torch_on = FALSE;
        program_pause = TRUE;
        stop_type = PAUSE;
        probe_required = TRUE;
        rtapi_print_msg(RTAPI_MSG_ERR,"arc voltage fell below safe level while THC active\n"
                                      "target voltage = %f\n"
                                      "low cut volts = %d\n"
                                      "arc voltage = %f\n"
                                      "program is paused.\n", target_volts, low_cut_volts, arc_voltage_out);
        probe_inhibit = TRUE;
        state = MAX_HEIGHT;
    }

    /* ohmic sensing */
    if(ohmic_enable){
        if(ohmic_sense_in){
            if(ohmic_sense_counts < ohmic_sense_on_delay){
                ohmic_sense_counts += 1;
            }else{
                ohmic_sense_out = TRUE;
                ohmic_sense_counts = 0;
            }
        }else if(!ohmic_sense_in && ohmic_sense_out){
            if(ohmic_sense_counts < ohmic_sense_off_delay){
                ohmic_sense_counts += 1;
            }else{
                ohmic_sense_out = FALSE;
                ohmic_sense_counts = 0;
            }
        }else{
            ohmic_sense_counts = 0;
        }
    }else{
        ohmic_sense_out = FALSE;
        ohmic_sense_counts = 0;
    }

    /* offset probing deployment timer*/
    if(ohmic_probe_enable && (offset_probe_x || offset_probe_y)){
        offset_probing = TRUE;
    }else{
        offset_probing = FALSE;
    }
    if(offset_probing && (ohmic_enable || state == PIERCE_HEIGHT)){
        if(offset_probe_timer < offset_probe_delay){
            offset_probe_timer += fperiod;
        }
    }else{
        offset_probe_timer = 0;
    }

    /* set arc ok from either arc ok input of from actual arc voltage
     * if using arc ok input, set arc_ok_low_in and/or arc_ok_high_in to 0 */
    if(torch_on){
        torch_time += fperiod;
        /* add the current arc voltage to the arc voltage buffer */
        arc_voltage_buffer[arc_voltage_buffer_index] = arc_voltage_out;
        if (arc_voltage_buffer_index == BUFFERSIZE) {
            arc_voltage_buffer_index = 0;
        }else{
            arc_voltage_buffer_index++;
        }
        /* set from arc ok input */
        if(mode > 0){
            if(arc_ok_in){
                arc_ok_out = TRUE;
                arc_lost_timer = arc_lost_delay;
            }else if(arc_lost_timer > 0){
                arc_lost_timer -= fperiod;
            }else{
                arc_ok_out = FALSE;
            }
        /* synthesised from arc voltage */
        }else{
            /* stable voltages required to set arc_ok */
            if(!arc_ok_out){
                if(arc_voltage_out >= arc_ok_low &&
                   arc_voltage_out <= arc_ok_high &&
                    !read_arc_voltage_buffer(READ_OK, ok_sampler_samples, arc_voltage_buffer_index - 1, arc_voltage_out, ok_sample_threshold)){
                arc_ok_out = TRUE;
                arc_lost_timer = arc_lost_delay;
                }
            /* stable voltages required to maintain arc_ok */
            }else if((arc_voltage_out < arc_ok_low || arc_voltage_out > arc_ok_high) &&
                    read_arc_voltage_buffer(READ_OK, ok_sampler_samples, arc_voltage_buffer_index - 1, target_volts, ok_sample_threshold) >= ok_sampler_samples){
                if(arc_lost_timer <= 0){
                    arc_ok_out = FALSE;
                }else{
                    arc_lost_timer -= fperiod;
                }
            }
        }
    /* unset arc ok */
    }else{
        arc_lost_timer = arc_lost_delay;
        arc_ok_out = FALSE;
    }

    /* reset program states */
    if(program_is_idle){
        program_stop = FALSE;
        program_resume = FALSE;
        statistics_reset = FALSE;
    }else if(program_is_paused){
        program_pause = FALSE;
        paused_time += fperiod;
        run_time += fperiod;
    }else if(program_is_running){
        program_run = FALSE;
        program_resume = FALSE;
        auto_cut = TRUE;
        run_time += fperiod;
        if(motion_type == 1){
            rapid_time += fperiod;
        }
        if(!statistics_reset){
            cut_length = 0;
            cut_time = 0;
            paused_time = 0;
            pierce_count = 0;
            probe_time = 0;
            rapid_time = 0;
            run_time = 0;
            torch_time = 0;
            statistics_reset = TRUE;
        }
    }

    /* if puddlejump height is 0 then set it to 100 */
    puddle_jump_percent = puddle_jump_height == 0 ? 100:puddle_jump_height;

    /* set jog inhibit if required */
    if(sensor_active && program_is_idle && !(override_jog || state == PROBE_DOWN || state == PROBE_UP)){
        jog_inhibit = TRUE;
    }else{
        jog_inhibit = FALSE;
    }

    /* probe and scribe deployment for setting offsets */
    if(offset_set_probe && !offset_set && homed && program_is_idle && state == IDLE){
        offset_set = TRUE;
        ohmic_enable = TRUE;
    }else if(offset_set_scribe && !offset_set && homed && program_is_idle && state == IDLE){
        offset_set = TRUE;
        scribe_arm = TRUE;
    }else if(offset_set && !offset_set_probe && !offset_set_scribe){
        offset_set = FALSE;
        ohmic_enable = FALSE;
        scribe_arm = FALSE;
    }

    if(!machine_is_on){
        /* if machine is off */
        x_offset_counts = 0;
        y_offset_counts = 0;
        z_offset_counts = 0;
        stop_type = NONE;
        cut_started = FALSE;
        probe_required = TRUE;
        program_stop = FALSE;
        program_resume = FALSE;
        program_pause = FALSE;
        torch_on = FALSE;
        torch_pulse_timer = 0;
        state = IDLE;
    }else{
        /* if machine is on */
        switch(state){
            case IDLE:
//                if(!consumable_changing){
//                    xy_offset_enable = FALSE;
//                }
//                if(!offsets_active && program_is_idle){
//                    z_offset_enable = FALSE;
//                }
                if(probe_inhibit && !float_switch && !breakaway && !ohmic_detected){
                    probe_inhibit = FALSE;
                }else if(!probe_inhibit){
                    /* if we get a paused motion request and we are paused */
                    if(paused_motion_speed && (stop_type == PAUSE || stop_type == WAIT)){
                        state = PAUSED_MOTION;
                    /* if we get a consumable change start request and we are paused */
                    }else if(consumable_change && (stop_type == PAUSE || stop_type == WAIT) && !consumable_changing){
                        state = MAX_HEIGHT;
                        /* if we get a consumable change stop request and we are changing consumables */
                    }else if(!consumable_change && (stop_type == PAUSE || stop_type == WAIT) && consumable_changing){
                        state = CONSUMABLE_CHANGE_OFF;
                    /* if we get a cut recovery start request and we are paused */
                    }else if(cut_recovery && stop_type == PAUSE && (!cut_recovering || laser_recovery_start)){
                        state = CUT_RECOVERY_ON;
                    /* if we get a torch start request and we are stopped or waiting for a restart */
                    }else if((tool == CUTTING || tool == SPOTTING || probe_test) && (stop_type == NONE || stop_type == WAIT) && homed){
                        feed_hold = TRUE;
                        stop_type = NONE;
                        //touchdown = FALSE;
                        if(!probe_test){
                            cut_started = TRUE;
                        }else{
                            probe_testing = TRUE;
                        }
                        if(!thc_activated && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_start - axis_x_position, 2) + pow(axis_y_start - axis_y_position, 2));
                        }else if((axis_x_finish || axis_y_finish) && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_finish - axis_x_position, 2) + pow(axis_y_finish - axis_y_position, 2));
                            axis_x_finish = 0;
                            axis_y_finish = 0;
                        }
                        thc_activated = FALSE;
                        if(skip_ihs_distance && cut_offset < skip_ihs_distance && !probe_required){
                            if(thc_enabled){
                                pierce_target = pierce_target + cut_height_last - cut_target;
                                puddle_jump_target = puddle_jump_target + cut_height_last - cut_target;
                                cut_target = cut_height_last;
                                cut_height_first = cut_target;
                            }
                            cut_offset = 0;
                            state = PIERCE_HEIGHT;
                        }else{
                            if(ohmic_detected && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "probe test aborted.\n");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(float_switch && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "probe test aborted.");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(breakaway && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "probe test aborted.\n");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if (!program_is_paused && !program_pause){
                                if(!first_cut_finished){
                                    if(probe_start_height){
                                        probe_start_target = z_offset_counts - ((axis_z_position - axis_z_min_limit - probe_start_height) / offset_scale);
                                    }else{
                                        probe_start_target = z_offset_counts;
                                    }
                                }
                                cut_offset = 0;
                                /* offset probing setup if required */
                                if(offset_probing){
                                    op_xy_angle = atan2(-offset_probe_y, -offset_probe_x);
                                    op_x_velocity = fabs(setup_velocity * cos(op_xy_angle));
                                    op_y_velocity = fabs(setup_velocity * sin(op_xy_angle));
                                    op_x_target = x_offset_counts + (offset_probe_x / offset_scale);
                                    op_y_target = y_offset_counts + (offset_probe_y / offset_scale);
                                    op_x_start = x_offset_counts;
                                    op_y_start = y_offset_counts;
                                    if(axis_x_position + (op_x_target * offset_scale) <= axis_x_min_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis X minimum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_y_position + (op_y_target * offset_scale) <= axis_y_min_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis Y minimum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_x_position + (op_x_target * offset_scale) >= axis_x_max_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis X maximum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_y_position + (op_y_target * offset_scale) >= axis_y_max_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis Y maximum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                }
                                /* clear any laser recovey offset */
                                if(laser_recovery_state > OFF && laser_recovery_state < RESET){
                                    laser_recovery_state = RESET;
                                }else if(laser_recovery_state == RESET){
                                    angle_x_y = atan2(laser_y_offset, laser_x_offset);
                                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                                    laser_recovery_state = RESETTING;
                                }else if(laser_recovery_state == RESETTING){
                                    if(x_offset_counts == x_offset && y_offset_counts == y_offset){
                                        laser_recovery_state = OFF;
                                    }else{
                                        if(x_offset_counts != x_offset){
                                            x_offset_counts = offset_move(x_offset_counts, x_velocity, x_offset);
                                        }
                                        if(y_offset_counts != y_offset){
                                            y_offset_counts = offset_move(y_offset_counts, y_velocity, y_offset);
                                        }
                                    }
                                /* laser recovery offset complete if required */
                                }else{
                                    state = PROBE_HEIGHT;
                                }
                            }
                        }
                    /* if we get a resume request and we are paused */
                    }else if(!program_is_paused && stop_type == PAUSE){
                        if(consumable_changing){
                            state = CONSUMABLE_CHANGE_OFF;
                        }else if(motion_type == 1){
                            feed_hold = FALSE;
                        }else{
                            feed_hold = TRUE;
                        }
                        stop_type = NONE;
                    /* if torch pulse requested */
                    }else if(torch_pulse_start && torch_enable && !breakaway && !float_switch && !ohmic_probe){
                        feed_hold = TRUE;
                        state = TORCHPULSE;
                    /* if ohmic probe shorted test requested */
                    }else if(ohmic_test && ohmic_probe_enable){
                        feed_hold = TRUE;
                        ohmic_enable = TRUE;
                        state = OHMIC_TEST;
                    /* if we get a air-scribe start request */
                    }else if(tool == SCRIBE && !probe_test && homed){
                        state = SCRIBING;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_pause = FALSE;
                    }else if(!cut_started){
                        feed_hold = FALSE;
                    }
                }
                break;
            case PROBE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                if(ohmic_probe_enable){
                    ohmic_enable = TRUE;
                }
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(probe_testing && breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected during probe test\n");
                    probe_test_error = TRUE;
                    state = PROBE_TEST;
                    break;
                }
                /* move probe to x/y offsets if required */
                if(offset_probing){
                    xy_offset_enable = TRUE;
                    if(x_offset_counts != op_x_target || y_offset_counts != op_y_target){
                        if(x_offset_counts != op_x_target){
                            x_offset_counts = offset_move(x_offset_counts, op_x_velocity, op_x_target);
                        }
                        if(y_offset_counts != op_y_target){
                            y_offset_counts = offset_move(y_offset_counts, op_y_velocity, op_y_target);
                        }
                    }
                }
                if((float_switch && !float_detected) || ohmic_detected){
                    z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                    z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(z_pierce > z_max){
                        if(probe_testing){
                          state = PROBE_TEST;
                          probe_test_error = TRUE;
                          if(float_switch){
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                          "condition found while moving to probe height during float switch probe testing");
                          }else{
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                          "condition found while moving to probe height during ohmic probe testing");
                          }
                        }else{
                          stop_type = PAUSE;
                          program_pause = TRUE;
                          state = MAX_HEIGHT;
                          if(float_switch){
                              rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                            "condition found while moving to probe height during float switch probing\n");
                          }else{
                              rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                            "condition found while moving to probe height during ohmic probing\n");
                          }
                        }
                        break;
                    }else if(ohmic_probe_enable && (x_offset_counts != op_x_target || y_offset_counts != op_y_target)){
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,"probe contact detected before probe offset reached\n"
                                                      "try increasing PROBE HEIGHT parameter\n");
                        state = MAX_HEIGHT;
                        break;
                    }
                    probe_retry = TRUE;
                    state = PROBE_UP;
                /* move to probe height at setup velocity */
                }else if(z_offset_counts != probe_start_target){
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, probe_start_target);
                }else{
                    if(float_detected){
                        if(!float_switch){
                            float_detected = FALSE;
                        }
                    }else{
                        /* test if probing offset is reached */
                        if(offset_probing){
                            if(x_offset_counts == op_x_target && y_offset_counts == op_y_target &&
                               z_offset_current - probe_start_target * offset_scale < 0.001){
                                state = PROBE_DOWN;
                            }
                        }else{
                            state = PROBE_DOWN;
                        }
                    }
                }
                probe_time += fperiod;
                break;
            case PROBE_DOWN:
                z_offset_enable = TRUE;
                stop_type = NONE;
                feed_hold = TRUE;
                if(ohmic_probe_enable){
                    ohmic_enable = TRUE;
                }
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(probe_testing && breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected during probe test\n");
                    probe_test_error = TRUE;
                    state = PROBE_TEST;
                    break;
                }
                if(ohmic_probe_enable && ohmic_probe_enable && offset_probe_timer < offset_probe_delay){
                    break;
                }
                if(float_switch && !float_detected){
                    if(ohmic_attempts >= ohmic_max_attempts || !ohmic_probe_enable){
                        z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                        z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                        if(z_pierce > z_max && !probe_testing){
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum safe height\n"
                                                          "condition found while float switch probing\n");
                            stop_type = PAUSE;
                            program_pause = TRUE;
                            state = MAX_HEIGHT;
                            break;
                        }
                        probe_type = FLOAT;
                        ohmic_attempts = 0;
                        float_detected = FALSE;
                        state = PROBE_UP;
                    }else{
                        ohmic_attempts += 1;
                        float_detected = TRUE;
                        state = PROBE_HEIGHT;
                    }
                }else if(ohmic_detected){
                    z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                    z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(z_pierce > z_max && !probe_testing){
                        rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum safe height\n"
                                                      "condition found while ohmic probing\n");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        state = MAX_HEIGHT;
                        break;
                    }
                    probe_type = OHMIC;
                    ohmic_attempts = 0;
                    state = PROBE_UP;
                }else if(!float_switch && !ohmic_detected){
                    if(axis_z_position - (probe_velocity * offset_scale) <= axis_z_min_limit + (0.25 * units_per_mm )){
                        if(probe_at_bottom - z_offset_current < 0.0001){
                            probe_at_bottom = 0;
                            if(!probe_test){
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probing down.\n"
                                                              "program is paused.\n");
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                state = MAX_HEIGHT;
                            }else{
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probe testing.\n");
                                state = PROBE_TEST;
                                probe_test_error = TRUE;
                            }
                        }else{
                            probe_at_bottom = z_offset_current;
                        }
                    }else{
                        z_offset_counts -= probe_velocity;
                    }
                }
                probe_time += fperiod;
                break;
            case PROBE_UP:
                z_offset_enable = TRUE;
                stop_type = NONE;
                offset_probe_timer = 0;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                /* probe up at minimum speed to find top of stock */
                if(float_switch || ohmic_detected){
                    if(probe_retry){
                        z_offset_counts += 10 * res;
                    }else{
                        if(probe_final_speed > 10){
                            z_offset_counts += 10 * res;
                        }else if(probe_final_speed < 1){
                            z_offset_counts += 1 * res;
                        }else{
                            z_offset_counts += probe_final_speed * res;
                        }
                    }
                }else{
                    if(probe_retry){
                        probe_retry = FALSE;
                        state = PROBE_DOWN;
                        break;
                    }
                    ohmic_enable = FALSE;
                    if(probe_type == OHMIC){
                        probe_offset = ohmic_probe_offset / offset_scale;
                    }else{
                        probe_offset = float_switch_travel / offset_scale;
                    }
                    zero_target = z_offset_counts + probe_offset;
                    cut_target = offset_datum = zero_target + (cut_height / offset_scale);
                    pierce_target = zero_target + (pierce_height / offset_scale);
                    puddle_jump_target = zero_target + ((pierce_height * puddle_jump_percent * 0.01) / offset_scale );
                    safe_min = pierce_target + ((1 * units_per_mm) / offset_scale);
                    safe_preferred = zero_target + (safe_height / offset_scale);
                    offset_min = z_offset_counts - ((axis_z_position - axis_z_min_limit) / offset_scale);
                    offset_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(!safe_available){
                        safe_available = safe_preferred - zero_target;
                    }
                    if(units_per_mm == 1){
                        safe_alarm = offset_max - (13 / offset_scale);
                    }else{
                        safe_alarm = offset_max - (0.5 / offset_scale);
                    }
                    if(!cut_height_first){
                        cut_height_first = cut_target;
                    }
                    if(safe_height == 0){
                        safe_target = offset_max;
                            axis_x_start = axis_x_position;
                            axis_y_start = axis_y_position;
                            state = ZERO_HEIGHT;
                    }else if(safe_min > offset_max && !probe_testing){
                        safe_target = offset_max;
                        rtapi_print_msg(RTAPI_MSG_ERR, "material is too high for safe traverse.\n"
                                                       "program is paused.\n");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        state = MAX_HEIGHT;
                    }else if(safe_preferred >= offset_max && !probe_testing){
                        safe_target = offset_max;
                        // warn if safe_height is less than available safe height{
                        if(offset_max - zero_target < safe_available){
                            if(units_per_mm == 1){
                                rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to %0.1fmm.\n",
                                                                (offset_max - zero_target) * offset_scale);
                            }else{
                                rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to %0.2fin.\n",
                                                                (offset_max - zero_target) * offset_scale);
                            }
                            safe_available = offset_max - zero_target;
                        }
                        axis_x_start = axis_x_position;
                        axis_y_start = axis_y_position;
                        state = ZERO_HEIGHT;
                    }else{
                        safe_target = safe_preferred;
                        axis_x_start = axis_x_position;
                        axis_y_start = axis_y_position;
                        state = ZERO_HEIGHT;
                    }
                }
                probe_time += fperiod;
                break;
            case ZERO_HEIGHT:
                /* this case is not used at present it is just a waypoint*/
                if(z_offset_counts == zero_target){
                    if((int)(z_offset_current * offset_res) == (int)(zero_target * offset_scale * offset_res)){
                        state = PIERCE_HEIGHT;
                    }
                /* move to zero height at setup velocity*/
                }else{
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, zero_target);
                }
                break;
            case PIERCE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                probe_required = FALSE;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                /* clear x/y probe offsets if required */
                if(offset_probing){
                    xy_offset_enable = TRUE;
                    if(x_offset_counts != op_x_start){
                        x_offset_counts = offset_move(x_offset_counts, op_x_velocity, op_x_start);
                    }
                    if(y_offset_counts != op_y_start){
                        y_offset_counts = offset_move(y_offset_counts, op_y_velocity, op_y_start);
                    }
                    if(ohmic_probe_enable && offset_probe_timer < offset_probe_delay){
                        break;
                    }
                }
                if(pierce_height && cut_height && (use_auto_volts || (!use_auto_volts && cut_volts))){
                    feed_hold = TRUE;
                    if(z_offset_counts == pierce_target){
                        if((int)(z_offset_current * offset_res) == (int)(pierce_target * offset_scale * offset_res) &&
                           (((offset_probing && x_offset_counts == op_x_start && y_offset_counts == op_y_start)) || !offset_probing)){
                            arc_starts = 0;
                            if(probe_testing){
                                state = PROBE_TEST;
                            }else if(!torch_enable){
                                pierce_timer = pierce_delay;
                                state = PIERCE_DELAY;
                            }else if((tool == CUTTING || tool == SPOTTING) &&
                                     (!offset_probing || (offset_probing &&
                                     (int)(x_offset_current * offset_res) == (int)(op_x_start * offset_scale * offset_res) &&
                                     (int)(y_offset_current * offset_res) == (int)(op_y_start * offset_scale * offset_res)))){
                                state = TORCH_ON;
                            }
                        }
                    /* move to pierce height at setup velocity*/
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, pierce_target);
                    }
                }else if(!probe_testing){
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                    rtapi_print_msg(RTAPI_MSG_ERR,"invalid pierce height.\n"
                                                  "or invalid cut height.\n"
                                                  "or invalid cut volts.\n"
                                                  "program is paused.\n");
                }
                break;
            case TORCH_ON:
                stop_type = NONE;
                /* turn torch on and start arc fail timer
                 * if too many attempts then turn torch off, pause program and return to idle state */
                feed_hold = TRUE;
                if(arc_starts > arc_max_starts - 1){
                    restart_timer = 0;
                    if(program_is_idle){
                        cutting_stop = 1;
                        state = MAX_HEIGHT;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nmanual cut is stopped.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }else{
                        program_pause = TRUE;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nprogram is paused.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }
                }else{
                    error_message = 0;
                    restart_timer -= fperiod;
                    if(restart_timer <= 0){
                        restart_timer = 0;
                        arc_fail_timer = arc_fail_delay;
                        if(torch_enable){
                            torch_on = TRUE;
                            pierce_count += 1;
                        }
                        spotting = FALSE;
                        /* clear arc voltage buffer */
                        memset(arc_voltage_buffer, 0, BUFFERSIZE * sizeof(*arc_voltage_buffer));
                        state = ARC_OK;
                    }
                }
                break;
            case ARC_OK:
                stop_type = NONE;
                /* wait for arc ok
                 * if timeout occurs turn torch off then return to TORCH_ON for another attempt */
                feed_hold = TRUE;
                if(tool == SPOTTING){
                    if(!spotting){
                        if(arc_voltage_out >= spotting_threshold){
                            spotting = TRUE;
                            spotting_timer = spotting_time * 0.001;
                        }
                    }else{
                        spotting_timer -= fperiod;
                        if(spotting_timer <= 0){
                            spotting = FALSE;
                            spotting_timer = 0;
                            torch_on = FALSE;
                            stop_type = WAIT;
                            state = SAFE_HEIGHT;
                        }
                    }
                }
                arc_fail_timer -= fperiod;
                if(arc_fail_timer <= 0){
                    torch_on = FALSE;
                    restart_timer = restart_delay;
                    arc_starts += 1;
                    state = TORCH_ON;
                }else if((arc_ok_out || ignore_arc_ok_0 || ignore_arc_ok_1) && tool != SPOTTING){
                        pierce_timer = pierce_delay;
                        state = PIERCE_DELAY;
                }
                break;
            case PIERCE_DELAY:
                stop_type = NONE;
                /* wait for arc to pierce stock */
                feed_hold = TRUE;
                if(pierce_timer > 0){
                    pierce_timer -= fperiod;
                }else if((puddle_jump_delay || puddle_jump_percent != 100) && !cut_recovering){
                    puddle_jump_timer = puddle_jump_delay;
                    state = PUDDLE_JUMP;
                }else{
                    state = CUT_HEIGHT;
                }
                break;
            case PUDDLE_JUMP:
                z_offset_enable = TRUE;
                feed_hold = FALSE;
                if(z_offset_counts == puddle_jump_target){
                    if((int)(z_offset_current * offset_res) == (int)(puddle_jump_target * offset_scale * offset_res)){
                        count = 0;
                        if(puddle_jump_timer > 0){
                            puddle_jump_timer -= fperiod;
                        }else{
                            puddle_jump_timer = 0;
                            state = CUT_HEIGHT;
                        }
                    }
                /* move to puddle_jump height at setup velocity*/
                }else{
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, puddle_jump_target);
                }
                break;
            case CUT_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
//                /* hold x/y motion until cut height reached */
//                if(!cut_recovering){
//                    feed_hold = FALSE;
//                }
                if(z_offset_counts == cut_target){
                    if((int)(z_offset_current * offset_res) == (int)(cut_target * offset_scale * offset_res)){
                        count = 0;
                        if(cut_recovering){
                            angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                            x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                            y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                            state = CUT_RECOVERY_OFF;
                        }else{
                            feed_hold = FALSE;
                            thc_delay_timer = thc_delay;
                            if(mode < 2){
                                voidlock_on_count = 0;
                                state = CUT_MODE_01;
                            }else{
                                state = CUT_MODE_2;
                            }
                        }
                    }
                /* move to cut height at setup velocity*/
                }else{
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, cut_target);
                }
                break;
            case CUT_MODE_01:
                /* thc control for modes 0 & 1 by arc voltage */
                /* if program is idle and spindle.0 is off then we shouldn't be here */
                if(program_is_idle && !cutting_start){
                    state = IDLE;
                }
                z_offset_enable = TRUE;
                /* use feed_upm if it has a value */
                if(feed_upm){
                    if(gcode_scale == 1){
                        requested_feed_rate = feed_upm / adaptive_feed;
                    }else{
                        requested_feed_rate = feed_upm / adaptive_feed / gcode_scale;
                    }
                /* otherwise fall back to cut feed rate parameter */
                }else{
                    if(gcode_scale == 1){
                        requested_feed_rate = cut_feed_rate * feed_override;
                    }else{
                        requested_feed_rate = cut_feed_rate * feed_override / gcode_scale;
                    }
                }
                /* while cutting and it is not a dry run and mesh mode is not enabled:
                 * if thc is enabled then vary the torch height to keep the arc voltage constant
                 * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity
                 * if voidlock is enabled, only allow THC if the voltage change is less than the threshold voltage
                 * adjust torch height and target voltage to suit if height override requested */
                if(torch_on && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1){
                    if(target_volts == 0){
                        cornerlock_is_locked = TRUE;
                        /* wait until velocity reaches 99.9% of requested velocity */
                        if(current_velocity * 60 > requested_feed_rate * 0.999){
                            if(thc_auto && use_auto_volts){
                                /* test the arc voltage buffer for a stable voltage */
                                double target = read_arc_voltage_buffer(READ_THC, thc_sampler_samples, arc_voltage_buffer_index - 1, arc_voltage_out, thc_sample_threshold);
                                if(target){
// should we use average voltage or current voltage???
//                                    target_volts = arc_voltage_out; // current voltage
                                    target_volts = target;            // average voltage
                                }
                            }else{
                                /* wait until thc delay is completed before setting target voltage */
                                if(thc_delay_timer <= 0){
                                    if(use_auto_volts){
                                        count += 1;
                                        target_total += arc_voltage_out;
                                        if(count == target_samples){
                                            target_volts = target_total / target_samples;
                                            last_arc_voltage = target_volts;
                                            count = 0;
                                            target_total = 0;
                                        }
                                    }else{
                                        target_volts = cut_volts;
                                    }
                                }else{
                                    thc_delay_timer -= fperiod;
                                }
                            }
                        }
                    /* height override setup*/
                    }else if(fabs(height_override - height_ovr_old) > 0.005){
                        height_ovr_counts -= (height_override - height_ovr_old) * height_per_volt / offset_scale;
                        height_ovr_old = height_override;
                    /* height override z motion */
                    }else if(height_ovr_counts != 0){
                        if((setup_velocity) < height_ovr_counts){
                            z_offset_counts -= setup_velocity;
                            height_ovr_counts -= setup_velocity;
                        }else{
                            z_offset_counts -= height_ovr_counts;
                            height_ovr_counts = 0;
                        }
                    /* torch height control */
                    }else if(thc_enabled){
                        /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                        if(cornerlock_enable){
                            if(current_velocity * 60 < requested_feed_rate * cornerlock_threshold * 0.01){
                                cornerlock_is_locked = TRUE;
                            }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * 0.99){
                                cornerlock_is_locked = FALSE;
                            }
                        }else{
                            cornerlock_is_locked = FALSE;
                        }
                        if(voidlock_enable){
                            voidlock_threshold = (voidlock_slope * voidlock_on_cycles * fperiod);
                            voidlock_change = fabs(arc_voltage_out - last_arc_voltage);
                            last_arc_voltage = arc_voltage_out;
                            if(voidlock_change > voidlock_threshold){
                                if(voidlock_on_count >= voidlock_on_cycles){
                                    voidlock_off_count = 0;
                                    voidlock_is_locked = TRUE;
                                }else{
                                    voidlock_on_count += 1;
                                }
                            }else if(voidlock_is_locked){
                                voidlock_off_count += 1;
                            }else{
                                voidlock_on_count = 0;
                            }
                            if(voidlock_is_locked && voidlock_off_count >= voidlock_off_cycles){
                                    voidlock_is_locked = FALSE;
                            }
                        }else{
                            voidlock_is_locked = FALSE;
                            voidlock_on_count = 0;
                            last_arc_voltage = arc_voltage_out;
                        }
                        /* do thc if ok to go */
                        if(!cornerlock_is_locked && !voidlock_is_locked){
                            pid_error_now = (target_volts + height_override - arc_voltage_out) * 0.1;
                            if(fabs(pid_error_now) < fabs(thc_threshold * 0.1)){
                                pid_error_now = 0;
                            }
                            pid_output = pid_error_now * pid_p_gain * res;
                            pid_output += pid_error_now * pid_i_gain * res * fperiod;
                            pid_output += (pid_error_now - pid_error_old) * pid_d_gain * res / fperiod;
                            pid_error_old = pid_error_now;
                            if(pid_output > thc_velocity){
                                pid_output = thc_velocity;
                            }else if(pid_output < -thc_velocity){
                                pid_output = -thc_velocity;
                            }
                            /* if we hit a soft limit during thc*/
                            if(z_offset_counts + pid_output <= offset_min || z_offset_counts + pid_output >= offset_max){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                if(z_offset_counts + pid_output <= offset_min){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                                  "program is paused.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                                  "program is paused.\n");
                                }
                                pid_output = 0;
                                state = MAX_HEIGHT;

                            }
                            z_offset_counts += pid_output;
                        }
                    }
                    if(pid_output > 0){
                        led_up = TRUE;
                    }else if((pid_output) < 0){
                        led_down = TRUE;
                    }else{
                        led_down = FALSE;
                        led_up = FALSE;
                    }
                    pid_output = 0;
                    /* check if safe height is below maximum offset */
                    if(z_offset_counts > offset_datum){
                        safe_target += z_offset_counts - offset_datum;
                        offset_datum = z_offset_counts;
                        if(safe_target > offset_max){
                            safe_target = offset_max;
                            // warn if safe height less than 10mm (0.4")
                            if(!safe_height_is_limited && z_offset_counts > safe_alarm){
                                safe_height_is_limited = TRUE;
                                if(units_per_mm == 1){
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 13mm.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 0.5in.\n");
                                }
                                safe_available = offset_max - z_offset_counts;
                            }
                        }
                    }
                }
                cut_height_last = z_offset_counts;
                cut_length = cut_length + current_velocity * fperiod;
                cut_time = cut_time + fperiod;
                break;
            case CUT_MODE_2:
                /* thc control for mode 2 by move-up and move-down inputs (no void lock in this mode) */
                /* if program is idle and spindle.0 is off then we shouldn't be here */
                if(program_is_idle && !cutting_start){
                    state = IDLE;
                }
                z_offset_enable = TRUE;
                /* use feed_upm if it has a value */
                if(feed_upm){
                    if(gcode_scale == 1){
                        requested_feed_rate = feed_upm / adaptive_feed;
                    }else{
                        requested_feed_rate = feed_upm / adaptive_feed / gcode_scale;
                    }
                /* otherwise fall back to cut feed rate parameter */
                }else{
                    if(gcode_scale == 1){
                        requested_feed_rate = cut_feed_rate * feed_override;
                    }else{
                        requested_feed_rate = cut_feed_rate * feed_override / gcode_scale;
                    }
                }
                /* while cutting and it is not a dry run and mesh mode is not enabled:
                 * if thc is enabled then vary the torch height to keep the arc voltage constant
                 * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity */
                if(torch_on && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1){
                    if(thc_enabled){
                        /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                        if(cornerlock_enable){
                            if(current_velocity * 60 < requested_feed_rate * cornerlock_threshold * 0.01){
                                cornerlock_is_locked = TRUE;
                            }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * 0.99){
                                cornerlock_is_locked = FALSE;
                            }
                        }else{
                            cornerlock_is_locked = FALSE;
                        }
                        if(move_down && !cornerlock_is_locked){
                            if(z_offset_counts - thc_velocity <= offset_min){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                              "program is paused.\n");
                                state = MAX_HEIGHT;
                            }else{ /* move down at requested velocity */
                                z_offset_counts -= thc_velocity;
                                led_down = TRUE;
                            }
                        }else if(move_up && !cornerlock_is_locked){
                            if(z_offset_counts + thc_velocity + safe_min >= offset_max){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                              "program is paused.\n");
                                state = MAX_HEIGHT;
                            }else{ /* move up at requested velocity */
                                z_offset_counts += thc_velocity;
                                led_up = TRUE;
                            }
                        }else{
                            led_down = FALSE;
                            led_up = FALSE;
                        }
                    }
                    /* check if safe height is below maximum offset */
                    if(z_offset_counts > offset_datum){
                        safe_target += z_offset_counts - offset_datum;
                        offset_datum = z_offset_counts;
                        if(safe_target > offset_max){
                            safe_target = offset_max;
                            // warn if safe height less than 10mm (0.4")
                            if(!safe_height_is_limited && z_offset_counts > safe_alarm){
                                safe_height_is_limited = TRUE;
                                if(units_per_mm == 1){
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 13mm.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 0.5in.\n");
                                }
                                safe_available = offset_max - z_offset_counts;
                            }
                        }
                    }
                }
                cut_height_last = z_offset_counts;
                cut_length = cut_length + current_velocity * fperiod;
                cut_time = cut_time + fperiod;
                break;
            case PAUSE_AT_END:
                feed_hold = TRUE;
                pause_at_end_timer -= fperiod;
                if(pause_at_end_timer <= 0){
                    pause_at_end_timer = 0;
                    torch_on = FALSE;
                    if(program_is_idle){
                        state = MAX_HEIGHT;
                    }else{
                        state = SAFE_HEIGHT;
                    }
                }
                break;
            case SAFE_HEIGHT:
                z_offset_enable = TRUE;
                feed_hold = TRUE;
                torch_on = FALSE;
                if(!torch_off_timer || !torch_on){
                    cornerlock_is_locked = FALSE;
                    if(!probe_test || probe_test_error){
                        if(z_offset_counts == safe_target){
                            if((int)(z_offset_current * offset_res) == (int)(safe_target * offset_scale * offset_res)){
                                if(stop_type == WAIT){
                                    feed_hold = FALSE;
                                }
                                first_cut_finished = TRUE;
                                /* do height override here for for remainder of job */
                                height_ovr_old = 0;
                                state = END_CUT;
                            }
                        /* move to safe height at setup velocity*/
                        }else{
                            z_offset_counts = offset_move(z_offset_counts, setup_velocity, safe_target);
                        }
                    }
                }
                break;
            case MAX_HEIGHT:
                z_offset_enable = TRUE;
                feed_hold = TRUE;
                torch_on = FALSE;
                cornerlock_is_locked = FALSE;
                if(!probe_test || probe_test_error){
                    if(z_offset_counts == 0){
                        if((int)(z_offset_current * offset_res) == 0){
                            if(stop_type == WAIT){
                                feed_hold = FALSE;
                            }
                            /* do height override here for remainder of job */
                            height_ovr_old = 0;
                            if(consumable_change){
                                state = CONSUMABLE_CHANGE_ON;
                            }else if(cut_recovery && stop_type != STOP){
                                state = CUT_RECOVERY_ON;
                            /* clear x/y probe offsets if required */
                            }else if((offset_probe_x || offset_probe_y) && (x_offset_counts || y_offset_counts)){
                                if(x_offset_counts != 0){
                                    x_offset_counts = offset_move(x_offset_counts, op_x_velocity, 0);
                                }
                                if(y_offset_counts != 0){
                                    y_offset_counts = offset_move(y_offset_counts, op_y_velocity, 0);
                                }
                            }else{
                                    state = END_CUT;
                            }
                        }
                    /* move to maximum height at setup velocity */
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    }
                }
                break;
            case END_CUT:
                /* clean up and return to idle state */
                target_volts = 0;
                cornerlock_is_locked = FALSE;
                voidlock_is_locked = FALSE;
                led_down = FALSE;
                led_up = FALSE;
                ohmic_enable = FALSE;
                probe_test_error = FALSE;
                cutting_stop = 0;
                if(program_is_idle){
                    state = END_JOB;
                }else{
                    state = IDLE;
                }
                break;
            case END_JOB:
                auto_cut = FALSE;
                manual_cut = FALSE;
                program_run = FALSE;
                paused_motion = FALSE;
                adaptive_feed = 1;
                cut_height_first = 0;
                cut_height_last = 0;
                if(program_is_idle){
                    z_offset_enable = TRUE;
                    if (z_offset_counts == 0){
                        if(!offsets_active){
                            first_cut_finished = FALSE;
                            stop_type = NONE;
                            safe_height_is_limited = FALSE;
                            safe_available = 0;
                            cut_started = FALSE;
                            /* do height override here for one cut only */
                            /* height_ovr_old = 0; */
                            if(consumable_changing){
                                state = CONSUMABLE_CHANGE_OFF;
                            }else if(cut_recovering){
                                angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                                x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                                y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                                state = CUT_RECOVERY_OFF;
                                cut_recovering = FALSE;
                                laser_recovery_state = OFF;
                            }else{
                                state = IDLE;
                            }
                        }
                    /* clear z offset at setup velocity */
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    }
                }
                break;
            case TORCHPULSE:
                /* single pulse the torch on and off */
                if(!torch_on){
                    torch_pulse_timer = torch_pulse_time;
                    if(torch_enable){
                        torch_on = TRUE;
                    }
                }else{
                    if(torch_pulse_time == 0){
                        torch_pulse_timer = 0;
                    }
                    if(torch_pulse_timer > 0){
                        torch_pulse_timer -= fperiod;
                    }else{
                        torch_on = FALSE;
                        if(!torch_pulse_start){
                            if(cut_recovering){
                                state = CUT_RECOVERY_ON;
                            }else{
                                state = IDLE;
                            }
                        }
                    }
                }
                break;
            case PAUSED_MOTION:
                if(paused_motion_speed){
                    paused_motion = TRUE;
                    adaptive_feed = paused_motion_speed;
                    program_resume = TRUE;
                    feed_hold = FALSE;
                }else if(program_is_running){
                    program_pause = TRUE;
                    feed_hold = TRUE;
                    adaptive_feed = 1;
                }else if(program_is_paused && feed_hold){
                    paused_motion = FALSE;
                    state = CUT_RECOVERY_ON;
                }
                break;
            case OHMIC_TEST:
                /* wait here until ohmic_test input released */
                if (!ohmic_test){
                    ohmic_enable = FALSE;
                    if(cut_recovering){
                        state = CUT_RECOVERY_ON;
                    }else{
                        state = IDLE;
                        }
                }
                break;
            case PROBE_TEST:
                z_offset_enable = TRUE;
                /* wait here until probe_test input released */
                if(!probe_test){
                    /* clear z offset at setup velocity */
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    if((offset_probe_x || offset_probe_y) && (x_offset_counts || y_offset_counts)){
                        x_offset_counts = offset_move(x_offset_counts, op_x_velocity, 0);
                        y_offset_counts = offset_move(y_offset_counts, op_y_velocity, 0);
                    }
                    if(!x_offset_counts && !y_offset_counts && !z_offset_counts){
                        probe_inhibit = FALSE;
                        probe_testing = FALSE;
                        probe_required = TRUE;
                        state = END_CUT;
                    }
                }
                break;
            case SCRIBING:
                if(tool == SCRIBE){
                    if(!program_is_paused){
                        scribe_arm = TRUE;

                        if(scribe_arm_timer){
                            feed_hold = TRUE;
                            scribe_arm_timer -= fperiod;
                            if(scribe_arm_timer < 0){
                                scribe_arm_timer = 0;
                            }
                        }else if(scribe_on_timer){
                            feed_hold = TRUE;
                            scribe_on_timer -= fperiod;
                            if(scribe_on_timer < 0){
                                scribe_on_timer = 0;
                            }
                        }else if(scribe_arm && !scribe_arm_timer && !scribe_on){
                            feed_hold = TRUE;
                            scribe_on_timer = scribe_on_delay;
                            scribe_on = TRUE;
                        }else if(scribe_on && !scribe_on_timer){
                            feed_hold = FALSE;
                        }
                    }else{
                        scribe_arm = FALSE;
                        scribe_on = FALSE;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_on_timer = 0;
                    }
                }else{
                    scribe_arm = FALSE;
                    scribe_on = FALSE;
                    scribe_arm_timer = 0;
                    scribe_on_timer = 0;
                    state = IDLE;
                }
                break;
            case CONSUMABLE_CHANGE_ON:
                xy_offset_enable = TRUE;
                feed_hold = TRUE;
                if(sensor_active){
                    if(!error_message){
                        error_message = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "breakaway, float, or ohmic activated during consumable change, motion paused.\n"
                                        "WARNING: MOTION WILL RESUME IMMEDIATELY UPON RESOLVING THIS CONDITION!\n");
                    }
                    break;
                }
                error_message = FALSE;
                if(!consumable_changing){
                    if(x_offset == 0 && y_offset == 0){
                        x_velocity = 0;
                        y_velocity = 0;
                    }else if(x_offset == 0){
                        x_velocity = 0;
                        y_velocity = xy_feed_rate * velocity_scale;
                    }else if(y_offset == 0){
                        x_velocity = xy_feed_rate * velocity_scale;
                    }else{
                        angle_x_y = atan2(y_offset, x_offset);
                        x_velocity = fabs(xy_feed_rate * velocity_scale * cos(angle_x_y));
                        y_velocity = fabs(xy_feed_rate * velocity_scale * sin(angle_x_y));
                    }
                    consumable_changing = TRUE;
                }else{
                    if(((int)(x_offset_current * offset_res) == (int)(x_offset * offset_scale * offset_res) &&
                      (int)(y_offset_current * offset_res) == (int)(y_offset * offset_scale * offset_res)) ||
                      !consumable_change){
                        state = IDLE;
                    }else if(consumable_change){
                        if(x_velocity && x_offset_counts != x_offset){
                            if(x_offset > 0){
                                if(x_offset_counts + x_velocity < x_offset){
                                    x_offset_counts += x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }else{
                                if(x_offset_counts - x_velocity > x_offset){
                                    x_offset_counts -= x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }
                        }
                        if(y_velocity && y_offset_counts != y_offset){
                            if(y_offset > 0){
                                if(y_offset_counts + y_velocity < y_offset){
                                    y_offset_counts += y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }else{
                                if(y_offset_counts - y_velocity > y_offset){
                                    y_offset_counts -= y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }
                        }
                    }
                }
                break;
            case CONSUMABLE_CHANGE_OFF:
                xy_offset_enable = TRUE;
                if(sensor_active){
                    if(!error_message){
                        error_message = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "breakaway, float, or ohmic activated during consumable change, motion paused.\n"
                                        "WARNING: MOTION WILL RESUME IMMEDIATELY UPON RESOLVING THIS CONDITION!\n");
                    }
                    break;
                }
                error_message = FALSE;
                if(x_offset_counts == 0 && y_offset_counts == 0){
                    if((int)(x_offset_current * offset_res) == 0 && (int)(y_offset_current * offset_res) == 0){
                        consumable_changing = FALSE;
                        cons_change_clear = FALSE;
                        feed_hold = FALSE;
                        state = IDLE;
                    }
                }else{
                    if(x_velocity && x_offset_counts != 0){
                        if(x_offset_counts > 0){
                            if(x_offset_counts - x_velocity > 0){
                                x_offset_counts -= x_velocity;
                            }else{
                                x_offset_counts = 0;
                            }
                        }else{
                            if(x_offset_counts + x_velocity < 0){
                                x_offset_counts += x_velocity;
                            }else{
                                x_offset_counts = 0;
                            }
                        }
                    }
                    if(y_velocity && y_offset_counts != 0){
                        if(y_offset_counts > 0){
                            if(y_offset_counts - y_velocity > 0){
                                y_offset_counts -= y_velocity;
                            }else{
                                y_offset_counts = 0;
                            }
                        }else{
                            if(y_offset_counts + y_velocity < 0){
                                y_offset_counts += y_velocity;
                            }else{
                                y_offset_counts = 0;
                            }
                        }
                    }
                }
                break;
            case CUT_RECOVERY_ON:
                xy_offset_enable = TRUE;
                if(program_is_running){
                    state = IDLE;
                }
                if(!cut_recovering){
                    cut_recovering = TRUE;
                    if(puddle_jump_delay || puddle_jump_percent != 100){
                        rtapi_print_msg(RTAPI_MSG_ERR, "Puddle Jump is disabled during Cut Recovery.\n");
                    }
                }
                if(torch_pulse_start && torch_enable && !breakaway && !float_switch && !ohmic_probe){
                    feed_hold = TRUE;
                    state = TORCHPULSE;
                }
                if(ohmic_test && ohmic_probe_enable){
                    feed_hold = TRUE;
                    ohmic_enable = TRUE;
                    state = OHMIC_TEST;
                }
                /* offset for laser recovery if required */
                if(laser_recovery_start && laser_recovery_state == OFF){
                    laser_recovery_state = SET;
                }else if(laser_recovery_state == SET){
                    angle_x_y = atan2(laser_y_offset, laser_x_offset);
                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                    laser_x_target = x_offset_counts + laser_x_offset;
                    laser_y_target = y_offset_counts + laser_y_offset;
                    laser_recovery_state = SETTING;
                }else if(laser_recovery_state == SETTING){
                    if(x_offset_counts == laser_x_target && y_offset_counts == laser_y_target){
                        laser_recovery_state = ON;
                    }else{
                        if(x_offset_counts != laser_x_target){
                            x_offset_counts = offset_move(x_offset_counts, x_velocity, laser_x_target);
                        }
                        if(y_offset_counts != laser_y_target){
                            y_offset_counts = offset_move(y_offset_counts, y_velocity, laser_y_target);
                        }
                    }
                /* laser recovery offset is clear */
                }else if(cut_recovery){
                    /* move x axis to recovery position at recovery velocity */
                    if(x_offset_counts != x_offset + laser_x_offset * (laser_recovery_state > 1)){
                        x_offset_counts = offset_move(x_offset_counts, recovery_velocity, x_offset + laser_x_offset * (laser_recovery_state > 1));
                    }
                    /* move y axis to recovery position at recovery velocity */
                    if(y_offset_counts != y_offset + laser_y_offset * (laser_recovery_state > 1)){
                        y_offset_counts = offset_move(y_offset_counts, recovery_velocity, y_offset + laser_y_offset * (laser_recovery_state > 1));
                    }
                }else{
                    state = CUT_RECOVERY_OFF;
                }
                if(paused_motion_speed){
                    state = PAUSED_MOTION;
                }
                break;
            case CUT_RECOVERY_OFF:
                xy_offset_enable = TRUE;
                angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                if(program_is_running){
                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                }else{
                    x_velocity = fabs(recovery_velocity * cos(angle_x_y));
                    y_velocity = fabs(recovery_velocity * sin(angle_x_y));
                }
                if(x_offset_counts == 0 && y_offset_counts == 0){
                    if((int)(x_offset_current * offset_res) == 0 && (int)(y_offset_current * offset_res) == 0){
                        laser_recovery_state = OFF;
                        if(cut_recovering){
                            cut_recovering = FALSE;
                            feed_hold = FALSE;
                            thc_delay_timer = thc_delay;
                            if(mode < 2){
                                voidlock_on_count = 0;
                                state = CUT_MODE_01;
                            }else{
                                state = CUT_MODE_2;
                            }
                        }else{
                            state = IDLE;
                        }
                    }
                }else{
                    /* clear x axis offset at recovery velocity */
                    if(x_offset_counts != 0){
                        x_offset_counts = offset_move(x_offset_counts, x_velocity, 0);
                    }
                    /* clear y axis offset at recovery velocity */
                    if(y_offset_counts != 0){
                        y_offset_counts = offset_move(y_offset_counts, y_velocity, 0);
                    }
                }
                break;
            case DEBUG:
                /* holding state for debugging */
                rtapi_print_msg(RTAPI_MSG_ERR, "We should never end up here...\n");
                break;
        }
    }

    /* set status pins */
    state_out = state;
    stop_type_out = stop_type;

    /* debug print */
    if(debug_print && state_old != state){
        state_old = state;
        switch(state){
            case 0:
                rtapi_print_msg(RTAPI_MSG_INFO, "IDLE\n");
                break;
            case 1:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_HEIGHT\n");
                break;
            case 2:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_DOWN\n");
                break;
            case 3:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_UP\n");
                break;
            case 4:
                rtapi_print_msg(RTAPI_MSG_INFO, "ZERO_HEIGHT\n");
                break;
            case 5:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_HEIGHT\n");
                break;
            case 6:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCH_ON\n");
                break;
            case 7:
                rtapi_print_msg(RTAPI_MSG_INFO, "ARC_OK\n");
                break;
            case 8:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_DELAY\n");
                break;
            case 9:
                rtapi_print_msg(RTAPI_MSG_INFO, "PUDDLE_JUMP\n");
                break;
            case 10:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_HEIGHT\n");
                break;
            case 11:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_MODE_01\n");
                break;
            case 12:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_MODE_2\n");
                break;
            case 13:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSE_AT_END\n");
                break;
            case 14:
                rtapi_print_msg(RTAPI_MSG_INFO, "SAFE_HEIGHT\n");
                break;
            case 15:
                rtapi_print_msg(RTAPI_MSG_INFO, "MAX_HEIGHT\n");
                break;
            case 16:
                rtapi_print_msg(RTAPI_MSG_INFO, "END_CUT\n");
                break;
            case 17:
                rtapi_print_msg(RTAPI_MSG_INFO, "END_JOB\n\n");
                break;
            case 18:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCHPULSE\n");
                break;
            case 19:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSED_MOTION\n");
                break;
            case 20:
                rtapi_print_msg(RTAPI_MSG_INFO, "OHMIC_TEST\n");
                break;
            case 21:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_TEST\n");
                break;
            case 22:
                rtapi_print_msg(RTAPI_MSG_INFO, "SCRIBING\n");
                break;
            case 23:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_ON\n");
                break;
            case 24:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_OFF\n");
                break;
            case 25:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_ON\n");
                break;
            case 26:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_OFF\n");
                break;
            case 27:
                rtapi_print_msg(RTAPI_MSG_INFO, "DEBUG\n");
                break;
        }
    }

}

static int __comp_get_data_size(void) { return 0; }
