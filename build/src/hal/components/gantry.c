/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:gantry:LinuxCNC HAL component for driving multiple joints from a single axis.");
MODULE_INFO(linuxcnc, "pin:joint.##.pos-cmd:float:(7, 'personality'):out:Per-joint commanded position:None:None");
MODULE_INFO(linuxcnc, "pin:joint.##.pos-fb:float:(7, 'personality'):in:Per-joint position feedback:None:None");
MODULE_INFO(linuxcnc, "pin:joint.##.home:bit:(7, 'personality'):in:Per-joint home switch:None:None");
MODULE_INFO(linuxcnc, "pin:joint.##.offset:float:(7, 'personality'):out:(debugging) Per-joint offset value, updated when homing.:None:None");
MODULE_INFO(linuxcnc, "pin:position-cmd:float:0:in:Commanded position from motion:None:None");
MODULE_INFO(linuxcnc, "pin:position-fb:float:0:out:Position feedback to motion:None:None");
MODULE_INFO(linuxcnc, "pin:home:bit:0:out:Combined home signal, true if all joint home inputs are true.:None:None");
MODULE_INFO(linuxcnc, "pin:limit:bit:0:out:Combined limit signal, true if any joint home input is true.:None:None");
MODULE_INFO(linuxcnc, "pin:search-vel:float:0:in:HOME_SEARCH_VEL from INI file:None:None");
MODULE_INFO(linuxcnc, "funct:read:1:Update position-fb and home/limit outputs based on joint values.");
MODULE_INFO(linuxcnc, "funct:write:1:Update joint pos-cmd outputs based on position-cmd in.");
MODULE_INFO(linuxcnc, "descr:\nDrives multiple physical motors (joints) from a single axis input\n.LP\nThe `personality' value is the number of joints to control.  Two is typical, but\nup to seven is supported (a three joint setup has been tested with hardware).\n.LP\nAll controlled joints track the commanded position (with a per-joint offset) unless in the process of homing.\nHoming is when the commanded position is moving towards the homing switches\n(as determined by the sign of search-vel)\nand the joint home switches are not all in the same state.\nWhen the system is homing and a joint home switch activates,\nthe command value sent to that joint is \"frozen\" and the joint offset value is updated instead.\nOnce all home switches are active,\nthere are no more adjustments made to the offset values and all joints run in lock-step once more.\n.LP\nFor best results, set HOME_SEARCH_VEL and HOME_LATCH_VEL to the same direction and as slow as practical.\nWhen a joint home switch trips, the commanded velocity will drop immediately from HOME_SEARCH_VEL to zero, with no limit on acceleration.\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Charles Steinkuehler");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_float_t *joint_pos_cmd_p[7];
    hal_float_t *joint_pos_fb_p[7];
    hal_bit_t *joint_home_p[7];
    hal_float_t *joint_offset_p[7];
    hal_float_t *position_cmd_p;
    hal_float_t *position_fb_p;
    hal_bit_t *home_p;
    hal_bit_t *limit_p;
    hal_float_t *search_vel_p;
    float offset_p[7];

    float prev_cmd_p;

    int fb_joint_p;

    int latching_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void read(struct __comp_state *__comp_inst, long period);
static void write(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    if((personality) > (7)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin joint.##.pos-cmd: Requested size %d exceeds max size %d\n",(int)personality, (int)7);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->joint_pos_cmd_p[j]), comp_id,
            "%s.joint.%02d.pos-cmd", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (7)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin joint.##.pos-fb: Requested size %d exceeds max size %d\n",(int)personality, (int)7);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->joint_pos_fb_p[j]), comp_id,
            "%s.joint.%02d.pos-fb", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (7)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin joint.##.home: Requested size %d exceeds max size %d\n",(int)personality, (int)7);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->joint_home_p[j]), comp_id,
            "%s.joint.%02d.home", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (7)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin joint.##.offset: Requested size %d exceeds max size %d\n",(int)personality, (int)7);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->joint_offset_p[j]), comp_id,
            "%s.joint.%02d.offset", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_float_newf(HAL_IN, &(inst->position_cmd_p), comp_id,
        "%s.position-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->position_fb_p), comp_id,
        "%s.position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->home_p), comp_id,
        "%s.home", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->limit_p), comp_id,
        "%s.limit", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->search_vel_p), comp_id,
        "%s.search-vel", prefix);
    if(r != 0) return r;
    for(j=0; j < 7; j++) {
        inst->offset_p[j] = 0.0;
    }
    inst->prev_cmd_p = 0.0;
    inst->fb_joint_p = 0.0;
    inst->latching_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s.read", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))read, inst, 1, 0, comp_id);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.write", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))write, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of gantry");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of gantry");
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each gantry");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("gantry");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "gantry.%d", i);
            r = export(buf, i, p_value("gantry", buf, i) );
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx, p_value("gantry", buf, idx) );
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef joint_pos_cmd
#undef joint_pos_cmd_ptr
#define joint_pos_cmd_ptr(i) (__comp_inst->joint_pos_cmd_p[i])
#define joint_pos_cmd(i) (*(__comp_inst->joint_pos_cmd_p[i]))
#undef joint_pos_fb
#undef joint_pos_fb_ptr
#define joint_pos_fb_ptr(i) (__comp_inst->joint_pos_fb_p[i])
#define joint_pos_fb(i) (0+*(__comp_inst->joint_pos_fb_p[i]))
#undef joint_home
#undef joint_home_ptr
#define joint_home_ptr(i) (__comp_inst->joint_home_p[i])
#define joint_home(i) (0+*(__comp_inst->joint_home_p[i]))
#undef joint_offset
#undef joint_offset_ptr
#define joint_offset_ptr(i) (__comp_inst->joint_offset_p[i])
#define joint_offset(i) (*(__comp_inst->joint_offset_p[i]))
#undef position_cmd
#undef position_cmd_ptr
#define position_cmd_ptr (__comp_inst->position_cmd_p)
#define position_cmd (0+*__comp_inst->position_cmd_p)
#undef position_fb
#undef position_fb_ptr
#define position_fb_ptr (__comp_inst->position_fb_p)
#define position_fb (*__comp_inst->position_fb_p)
#undef home
#undef home_ptr
#define home_ptr (__comp_inst->home_p)
#define home (*__comp_inst->home_p)
#undef limit
#undef limit_ptr
#define limit_ptr (__comp_inst->limit_p)
#define limit (*__comp_inst->limit_p)
#undef search_vel
#undef search_vel_ptr
#define search_vel_ptr (__comp_inst->search_vel_p)
#define search_vel (0+*__comp_inst->search_vel_p)
#undef offset
#define offset (__comp_inst->offset_p)
#undef prev_cmd
#define prev_cmd (__comp_inst->prev_cmd_p)
#undef fb_joint
#define fb_joint (__comp_inst->fb_joint_p)
#undef latching
#define latching (__comp_inst->latching_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 78 "/home/end/projects/linuxcnc/src/hal/components/gantry.comp"
FUNCTION(read) {
    int i=1;

    // First (or only) joint
    home=joint_home(0);
    limit=joint_home(0);

    // All other joints, if configured
    while (i < personality) {
        // Check to see if machine is in latching state
        if(latching==0)
        {
            // Don't assert home until all joints hit their home switches
            home  &= joint_home(i);
        }
        else
        {
            // Don't release home until all joints have backed off their
            // home switches
            home |= joint_home(i);
        }

        // Remember the home state for next time
        latching=home;

        // Limit is always asserted if any home switch is asserted
        limit |= joint_home(i);
        i++;
    }

    // Joint used for feedback is 'sticky', but we have to switch to
    // track active joints or motion gets upset with the sudden
    // stop.  If all joints are not homed, but the current joint used
    // for feedback is, find a joint that's still active
    if ((joint_home(fb_joint) == 1) && (home == 0)) {
        for (i=0; i < personality; i++) {
            if (joint_home(i) == 0) {
                position_fb = joint_pos_fb(i) + offset[i];
                fb_joint = i;
                break;
            }
        }
    } else {
        position_fb = joint_pos_fb(fb_joint) + offset[fb_joint];
    }
}

FUNCTION(write) {
    int i;
    float delta;

    // Determine if we're moving in the same direction as home search

    // First calculate the direction we're moving now
    delta = position_cmd - prev_cmd;

    // Stash current commanded position for next time
    prev_cmd = position_cmd;

    // Then multiply our delta value by the search velocity
    // If the signs match and neither is zero, the result will be positive
    // indicate we are moving towards home.  Otherwise, the result will be
    // zero or negative.
    //
    // If we're moving towards home and all home switches are not closed
    if ( ((delta * search_vel) > 0) && (home==0) ) {
        // Check each joint to see if it's home switch is active
        for (i=0; i < personality; i++) {
            // If home switch is active, update offset, not pos_cmd
            // so the other joints can catch up
            if (joint_home(i)==1) {
                offset[i] += delta;
            }
        }
    }

    // Update each joint's commanded position
    for (i=0; i < personality; i++) {
        joint_pos_cmd(i) = position_cmd - offset[i];
        joint_offset(i)  = offset[i];
    }
}


static int __comp_get_data_size(void) { return 0; }
