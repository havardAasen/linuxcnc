/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:latencybins:comp utility for scripts/latency-histogram\n\nUsage:\n  Read availablebins pin for the number of bins available.\n  Set the maxbinnumber pin for the number of \\(+- bins.\n    Ensure maxbinnumber <= availablebins\n    For maxbinnumber = N, the bins are numbered:\n       \\-N ... 0 ... + N bins\n    (the \\-0 bin is not populated)\n    (total effective bins = 2*maxbinnumber +1)\n  Set nsbinsize pin for the binsize (ns)\n  Iterate:\n    Set index pin to a bin number: 0 <= index <= maxbinnumber.\n    Read check pin and verify that check pin == index pin.\n    Read output pins:\n         pbinvalue is count for bin = +index\n         nbinvalue is count for bin = \\-index\n         pextra    is count for all bins > maxbinnumber\n         nextra    is count for all bins < maxbinnumber\n         latency-min is max negative latency\n         latency-max is max positive latency\n\n   If index is out of range ( index < 0 or index > maxbinnumber)\n   then pbinvalue = nbinvalue = \\-1.\n   The reset pin may be used to restart.\n   The latency pin outputs the instantaneous latency.\n\nMaintainers note: hardcoded for MAXBINNUMBER==1000\n");
MODULE_INFO(linuxcnc, "pin:maxbinnumber:s32:0:in::1000:None");
MODULE_INFO(linuxcnc, "pin:index:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:nsbinsize:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:check:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:latency:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:latency_max:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:latency_min:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:pbinvalue:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:nbinvalue:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:pextra:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:nextra:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:variance:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:availablebins:s32:0:out::1000:None");
MODULE_INFO(linuxcnc, "funct:_:0:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dewey Garrett");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_s32_t *maxbinnumber_p;
    hal_s32_t *index_p;
    hal_bit_t *reset_p;
    hal_s32_t *nsbinsize_p;
    hal_s32_t *check_p;
    hal_s32_t *latency_p;
    hal_s32_t *latency_max_p;
    hal_s32_t *latency_min_p;
    hal_s32_t *pbinvalue_p;
    hal_s32_t *nbinvalue_p;
    hal_s32_t *pextra_p;
    hal_s32_t *nextra_p;
    hal_s32_t *variance_p;
    hal_s32_t *availablebins_p;
    rtapi_s64 last_timer_p;

    int last_binmax_p;

    int first_p;

    int pbins_p[1001];

    int nbins_p[1001];

    int binmax_p;

    rtapi_u32 nsamples_p;

    rtapi_u64 sum_p;

    rtapi_u64 sq_sum_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_s32_newf(HAL_IN, &(inst->maxbinnumber_p), comp_id,
        "%s.maxbinnumber", prefix);
    if(r != 0) return r;
    *(inst->maxbinnumber_p) = 1000;
    r = hal_pin_s32_newf(HAL_IN, &(inst->index_p), comp_id,
        "%s.index", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset_p), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->nsbinsize_p), comp_id,
        "%s.nsbinsize", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->check_p), comp_id,
        "%s.check", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->latency_p), comp_id,
        "%s.latency", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->latency_max_p), comp_id,
        "%s.latency-max", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->latency_min_p), comp_id,
        "%s.latency-min", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->pbinvalue_p), comp_id,
        "%s.pbinvalue", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->nbinvalue_p), comp_id,
        "%s.nbinvalue", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->pextra_p), comp_id,
        "%s.pextra", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->nextra_p), comp_id,
        "%s.nextra", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->variance_p), comp_id,
        "%s.variance", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->availablebins_p), comp_id,
        "%s.availablebins", prefix);
    if(r != 0) return r;
    *(inst->availablebins_p) = 1000;
    inst->last_timer_p = 0.0;
    inst->last_binmax_p = 0.0;
    inst->first_p = 1.0;
    inst->binmax_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 0, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of latencybins");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of latencybins");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("latencybins");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "latencybins.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef maxbinnumber
#undef maxbinnumber_ptr
#define maxbinnumber_ptr (__comp_inst->maxbinnumber_p)
#define maxbinnumber (0+*__comp_inst->maxbinnumber_p)
#undef index
#undef index_ptr
#define index_ptr (__comp_inst->index_p)
#define index (0+*__comp_inst->index_p)
#undef reset
#undef reset_ptr
#define reset_ptr (__comp_inst->reset_p)
#define reset (0+*__comp_inst->reset_p)
#undef nsbinsize
#undef nsbinsize_ptr
#define nsbinsize_ptr (__comp_inst->nsbinsize_p)
#define nsbinsize (0+*__comp_inst->nsbinsize_p)
#undef check
#undef check_ptr
#define check_ptr (__comp_inst->check_p)
#define check (*__comp_inst->check_p)
#undef latency
#undef latency_ptr
#define latency_ptr (__comp_inst->latency_p)
#define latency (*__comp_inst->latency_p)
#undef latency_max
#undef latency_max_ptr
#define latency_max_ptr (__comp_inst->latency_max_p)
#define latency_max (*__comp_inst->latency_max_p)
#undef latency_min
#undef latency_min_ptr
#define latency_min_ptr (__comp_inst->latency_min_p)
#define latency_min (*__comp_inst->latency_min_p)
#undef pbinvalue
#undef pbinvalue_ptr
#define pbinvalue_ptr (__comp_inst->pbinvalue_p)
#define pbinvalue (*__comp_inst->pbinvalue_p)
#undef nbinvalue
#undef nbinvalue_ptr
#define nbinvalue_ptr (__comp_inst->nbinvalue_p)
#define nbinvalue (*__comp_inst->nbinvalue_p)
#undef pextra
#undef pextra_ptr
#define pextra_ptr (__comp_inst->pextra_p)
#define pextra (*__comp_inst->pextra_p)
#undef nextra
#undef nextra_ptr
#define nextra_ptr (__comp_inst->nextra_p)
#define nextra (*__comp_inst->nextra_p)
#undef variance
#undef variance_ptr
#define variance_ptr (__comp_inst->variance_p)
#define variance (*__comp_inst->variance_p)
#undef availablebins
#undef availablebins_ptr
#define availablebins_ptr (__comp_inst->availablebins_p)
#define availablebins (*__comp_inst->availablebins_p)
#undef last_timer
#define last_timer (__comp_inst->last_timer_p)
#undef last_binmax
#define last_binmax (__comp_inst->last_binmax_p)
#undef first
#define first (__comp_inst->first_p)
#undef pbins
#define pbins (__comp_inst->pbins_p)
#undef nbins
#define nbins (__comp_inst->nbins_p)
#undef binmax
#define binmax (__comp_inst->binmax_p)
#undef nsamples
#define nsamples (__comp_inst->nsamples_p)
#undef sum
#define sum (__comp_inst->sum_p)
#undef sq_sum
#define sq_sum (__comp_inst->sq_sum_p)


FUNCTION(_) {
#line 65 "/home/end/projects/linuxcnc/src/hal/components/latencybins.comp"

rtapi_s64     now = rtapi_get_time();
rtapi_s32   lat32 = (rtapi_s32)(now - last_timer - period);
                //(2^31-1)*1nS = 2.147 seconds max

int i;

last_timer = now;

binmax =  maxbinnumber;
if (binmax > availablebins) binmax = availablebins;
last_binmax = binmax;

if (reset) {first = 1;}

if (   first
     || binmax != last_binmax
     || nsbinsize == 0  // important to avoid divide by zero
  ) {
  first = 0;
  latency = 0;
  latency_min = 0x7FFFFFFF;
  latency_max = 0x80000000;
  pextra = 0; nextra = 0;
  for (i = 0; i <= binmax; i++) {
    pbins[i] = 0; nbins[i] = 0;
  }
  nsamples = 0;
  sum = 0;
  sq_sum = 0;
} else {
  latency = lat32;
  i = lat32/nsbinsize;
  if (lat32 > latency_max) latency_max = lat32;
  if (lat32 < latency_min) latency_min = lat32;
  if (i >= 0) {
     if (i > binmax) {
       pextra++;
     } else {
       pbins[i]++;
     }
  } else {
     i = -i;
     if (i > binmax) {
       nextra++;
     } else {
       nbins[i]++;
     }
  }
  nsamples++;
  sum    += lat32;
  sq_sum += lat32 * lat32;
  if (nsamples > 1) {
    // note: division required is: u64/u32
    rtapi_u64 dividend;
    rtapi_u64 divisor;
    dividend = sq_sum - rtapi_div_u64(sum * sum,nsamples);
    divisor  = nsamples -1;
    variance = rtapi_div_u64(dividend,divisor);
  }
}

check = index; // user should verify check==index for reading values
// -1 value indicates illegal index
if (index < 0) {
  pbinvalue = -1;
  nbinvalue = -1;
} else if (index <=binmax) {
  pbinvalue = pbins[index];
  nbinvalue = nbins[index];
} else {
  pbinvalue = -1;
  nbinvalue = -1;
}
}

static int __comp_get_data_size(void) { return 0; }
