/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:histobins:histogram bins utility for scripts/hal-histogram\n\nUsage:\n  Read availablebins pin for the number of bins available.\n  Set the minvalue, binsize, and nbins pins.\n    Ensure nbins <= availablebins\n    For nbins = N, the bins are numbered: 0 ... N\\-1 \n  Iterate:\n    Set index pin to a bin number: 0 <= index < nbins.\n    Read check pin and verify that check pin == index pin.\n    Read outputs: binvalue, pextra, nextra pins.\n         (binvalue is count for the indexed bin)\n         (pextra   is count for all inputs > maxvalue)\n         (nextra   is count for all bins   < minvalue)\n\n If index is out of range (index < 0 or index > maxbinnumber)\n then binvalue == \\-1.\n The input-error pin is set when input rules are violated\n and updates cease.\n The reset pin may be used to restart.\n The input used is selected based on pintype:\n   pintype  inputpin\n   -------  -----------\n         0  input\n         1  input-s32\n         2  input-u32\n         3  input-bit\n Additional output statistics pins:\n   input-min\n   input-max\n   nsamples\n   variance\n   mean\n The method input pin selects an alternate variance calculation.\n\nMaintainers note: hardcoded for MAXBINNUMBER==200\n");
MODULE_INFO(linuxcnc, "pin:pintype:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:input:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:input_s32:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:input_u32:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:input_bit:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:nbins:u32:0:in::20:None");
MODULE_INFO(linuxcnc, "pin:binsize:float:0:in::1:None");
MODULE_INFO(linuxcnc, "pin:minvalue:float:0:in::0:None");
MODULE_INFO(linuxcnc, "pin:index:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:check:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:method:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:input_error:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:binvalue:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:pextra:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:nextra:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:input_min:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:input_max:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:nsamples:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:variance:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:mean:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:availablebins:s32:0:out::200:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dewey Garrett");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_u32_t *pintype_p;
    hal_float_t *input_p;
    hal_s32_t *input_s32_p;
    hal_u32_t *input_u32_p;
    hal_bit_t *input_bit_p;
    hal_u32_t *nbins_p;
    hal_float_t *binsize_p;
    hal_float_t *minvalue_p;
    hal_s32_t *index_p;
    hal_s32_t *check_p;
    hal_bit_t *reset_p;
    hal_bit_t *method_p;
    hal_bit_t *input_error_p;
    hal_float_t *binvalue_p;
    hal_float_t *pextra_p;
    hal_float_t *nextra_p;
    hal_float_t *input_min_p;
    hal_float_t *input_max_p;
    hal_u32_t *nsamples_p;
    hal_float_t *variance_p;
    hal_float_t *mean_p;
    hal_s32_t *availablebins_p;
    int bin_p[200];

    int first_p;

    int last_nbins_p;

    hal_float_t maxvalue_p;

    hal_float_t last_binsize_p;

    hal_float_t last_minvalue_p;

    hal_float_t sum_p;

    hal_float_t sq_sum_p;

    hal_float_t m2_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_u32_newf(HAL_IN, &(inst->pintype_p), comp_id,
        "%s.pintype", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->input_p), comp_id,
        "%s.input", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->input_s32_p), comp_id,
        "%s.input-s32", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->input_u32_p), comp_id,
        "%s.input-u32", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->input_bit_p), comp_id,
        "%s.input-bit", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->nbins_p), comp_id,
        "%s.nbins", prefix);
    if(r != 0) return r;
    *(inst->nbins_p) = 20;
    r = hal_pin_float_newf(HAL_IN, &(inst->binsize_p), comp_id,
        "%s.binsize", prefix);
    if(r != 0) return r;
    *(inst->binsize_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->minvalue_p), comp_id,
        "%s.minvalue", prefix);
    if(r != 0) return r;
    *(inst->minvalue_p) = 0;
    r = hal_pin_s32_newf(HAL_IN, &(inst->index_p), comp_id,
        "%s.index", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->check_p), comp_id,
        "%s.check", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset_p), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->method_p), comp_id,
        "%s.method", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->input_error_p), comp_id,
        "%s.input-error", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->binvalue_p), comp_id,
        "%s.binvalue", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->pextra_p), comp_id,
        "%s.pextra", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->nextra_p), comp_id,
        "%s.nextra", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->input_min_p), comp_id,
        "%s.input-min", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->input_max_p), comp_id,
        "%s.input-max", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->nsamples_p), comp_id,
        "%s.nsamples", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->variance_p), comp_id,
        "%s.variance", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->mean_p), comp_id,
        "%s.mean", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->availablebins_p), comp_id,
        "%s.availablebins", prefix);
    if(r != 0) return r;
    *(inst->availablebins_p) = 200;
    inst->first_p = 1.0;
    inst->last_nbins_p = 0.0;
    inst->last_binsize_p = 0.0;
    inst->last_minvalue_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of histobins");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of histobins");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("histobins");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "histobins.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef pintype
#undef pintype_ptr
#define pintype_ptr (__comp_inst->pintype_p)
#define pintype (0+*__comp_inst->pintype_p)
#undef input
#undef input_ptr
#define input_ptr (__comp_inst->input_p)
#define input (0+*__comp_inst->input_p)
#undef input_s32
#undef input_s32_ptr
#define input_s32_ptr (__comp_inst->input_s32_p)
#define input_s32 (0+*__comp_inst->input_s32_p)
#undef input_u32
#undef input_u32_ptr
#define input_u32_ptr (__comp_inst->input_u32_p)
#define input_u32 (0+*__comp_inst->input_u32_p)
#undef input_bit
#undef input_bit_ptr
#define input_bit_ptr (__comp_inst->input_bit_p)
#define input_bit (0+*__comp_inst->input_bit_p)
#undef nbins
#undef nbins_ptr
#define nbins_ptr (__comp_inst->nbins_p)
#define nbins (0+*__comp_inst->nbins_p)
#undef binsize
#undef binsize_ptr
#define binsize_ptr (__comp_inst->binsize_p)
#define binsize (0+*__comp_inst->binsize_p)
#undef minvalue
#undef minvalue_ptr
#define minvalue_ptr (__comp_inst->minvalue_p)
#define minvalue (0+*__comp_inst->minvalue_p)
#undef index
#undef index_ptr
#define index_ptr (__comp_inst->index_p)
#define index (0+*__comp_inst->index_p)
#undef check
#undef check_ptr
#define check_ptr (__comp_inst->check_p)
#define check (*__comp_inst->check_p)
#undef reset
#undef reset_ptr
#define reset_ptr (__comp_inst->reset_p)
#define reset (0+*__comp_inst->reset_p)
#undef method
#undef method_ptr
#define method_ptr (__comp_inst->method_p)
#define method (0+*__comp_inst->method_p)
#undef input_error
#undef input_error_ptr
#define input_error_ptr (__comp_inst->input_error_p)
#define input_error (*__comp_inst->input_error_p)
#undef binvalue
#undef binvalue_ptr
#define binvalue_ptr (__comp_inst->binvalue_p)
#define binvalue (*__comp_inst->binvalue_p)
#undef pextra
#undef pextra_ptr
#define pextra_ptr (__comp_inst->pextra_p)
#define pextra (*__comp_inst->pextra_p)
#undef nextra
#undef nextra_ptr
#define nextra_ptr (__comp_inst->nextra_p)
#define nextra (*__comp_inst->nextra_p)
#undef input_min
#undef input_min_ptr
#define input_min_ptr (__comp_inst->input_min_p)
#define input_min (*__comp_inst->input_min_p)
#undef input_max
#undef input_max_ptr
#define input_max_ptr (__comp_inst->input_max_p)
#define input_max (*__comp_inst->input_max_p)
#undef nsamples
#undef nsamples_ptr
#define nsamples_ptr (__comp_inst->nsamples_p)
#define nsamples (*__comp_inst->nsamples_p)
#undef variance
#undef variance_ptr
#define variance_ptr (__comp_inst->variance_p)
#define variance (*__comp_inst->variance_p)
#undef mean
#undef mean_ptr
#define mean_ptr (__comp_inst->mean_p)
#define mean (*__comp_inst->mean_p)
#undef availablebins
#undef availablebins_ptr
#define availablebins_ptr (__comp_inst->availablebins_p)
#define availablebins (*__comp_inst->availablebins_p)
#undef bin
#define bin (__comp_inst->bin_p)
#undef first
#define first (__comp_inst->first_p)
#undef last_nbins
#define last_nbins (__comp_inst->last_nbins_p)
#undef maxvalue
#define maxvalue (__comp_inst->maxvalue_p)
#undef last_binsize
#define last_binsize (__comp_inst->last_binsize_p)
#undef last_minvalue
#define last_minvalue (__comp_inst->last_minvalue_p)
#undef sum
#define sum (__comp_inst->sum_p)
#undef sq_sum
#define sq_sum (__comp_inst->sq_sum_p)
#undef m2
#define m2 (__comp_inst->m2_p)


FUNCTION(_) {
#line 87 "/home/end/projects/linuxcnc/src/hal/components/histobins.comp"

hal_float_t invalue;
int i;
int idx;
check = index;
if (   (nbins > availablebins)
    || (nbins < 1)
   ) {
  input_error = 1;
  check = index; // allow continue with no updates
  return;
}
input_error = 0;
if (reset) {first = 1;}

//pintype    "0:float, 1:s32, 2:u32 3:bit";
switch (pintype) {
  case 0:  invalue = input;     break;
  case 1:  invalue = input_s32; break;
  case 2:  invalue = input_u32; break;
  case 3:  invalue = input_bit; break;
  default: invalue = input;     break;
}

if (  first
    || nbins    != last_nbins
    || binsize  != last_binsize
    || minvalue != last_minvalue
   ) {
  maxvalue = minvalue + nbins * binsize;
  first = 0;
  pextra = 0; nextra = 0;
  for (i = 0; i < nbins; i++) {
    bin[i] = 0;
  }
  nsamples = 0;
  mean = 0;
  sum = 0;
  sq_sum = 0;
  variance = 0;
  input_min =  1e99; //dng
  input_max = -1e99; //dng
  m2 = 0;
} else {
  
  if (invalue < minvalue) {
    nextra++;
  } else if (invalue > maxvalue) {
    pextra++;
  } else {
    idx = (invalue - minvalue)/binsize;
    bin[idx]++;
  }
}

check = index; // user should verify check==index for reading values
// -1 value indicates illegal index
if (index < 0) {
  binvalue = -1;
} else if (index < nbins) {
  binvalue = bin[index];
} else {
  binvalue = -1;
}

if (invalue < input_min) input_min = invalue;
if (invalue > input_max) input_max = invalue;

nsamples++;
if (nsamples >= 2) {
  if (method == 0 ) {
    hal_float_t delta;
    delta    = invalue - mean;
    mean     = mean + delta / nsamples;
    m2       = m2 + delta * (invalue - mean);
    variance = m2/(nsamples - 1);
  } else {
    sum     += invalue;
    sq_sum  += invalue * invalue;
    variance = (sq_sum - (sum * sum)/nsamples)/(nsamples -1);
    mean     = sum/nsamples;
  }
}

last_nbins = nbins;
last_binsize = binsize;
last_minvalue = minvalue;
}

static int __comp_get_data_size(void) { return 0; }
