/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:thcud:Torch Height Control Up/Down Input");
MODULE_INFO(linuxcnc, "descr:\nTorch Height Control\nThis THC takes either an up or a down input from a THC\n\nIf enabled and torch is on and X + Y velocity is within tolerance of set speed\nallow the THC to offset the Z axis as needed to maintain voltage.\n\nIf enabled and torch is off and the Z axis is moving up remove any correction\nat a rate not to exceed the rate of movement of the Z axis.\n\nIf enabled and torch is off and there is no correction \npass the Z position and feed back untouched.\n\nIf not enabled pass the Z position and feed back untouched.\n\nTypical Physical Connections using a Parallel Port\n.br\nParallel Pin 12 <= THC controller Plasma Up\n.br\nParallel Pin 13 <= THC controller Plasma Down\n.br\nParallel Pin 15  <= Plasma Torch Arc Ok Signal\n.br\nParallel Pin 16 => Plasma Torch Start Arc Contacts\n\nHAL Plasma Connections\n.br\nnet torch-up thcud.torch-up <= parport.0.pin-12-in\n.br\nnet torch-down thcud.torch-down <= parport.0.pin-13-in\n.br\nnet torch-on spindle.0.on => parport.0.pin-16-out (start the arc)\n.br\nnet arc-ok thcud.arc-ok <= motion.digital-in-00 <= parport.0.pin-15-in (arc ok signal)\n\nHAL Motion Connections\n.br\nnet requested-vel thcud.requested-vel <= motion.requested-vel\n.br\nnet current-vel thcud.current-vel <= motion.current-vel\n\nPyVCP Connections\nIn the XML file you need something like:\n\n  <pyvcp>\n  <checkbutton>\n    <text>\"THC Enable\"</text>\n    <halpin>\"thc-enable\"</halpin>\n  </checkbutton>\n  </pyvcp>\n\nConnect the PyVCP pins in the postgui.hal file like this:\n\nnet thc-enable thcud.enable <= pyvcp.thc-enable\n\n\n");
MODULE_INFO(linuxcnc, "author:John Thornton");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_INFO(linuxcnc, "pin:torch_up:bit:0:in:Connect to an input pin:None:None");
MODULE_INFO(linuxcnc, "pin:torch_down:bit:0:in:Connect to input pin:None:None");
MODULE_INFO(linuxcnc, "pin:current_vel:float:0:in:Connect to motion.current-vel:None:None");
MODULE_INFO(linuxcnc, "pin:requested_vel:float:0:in:Connect to motion.requested-vel:None:None");
MODULE_INFO(linuxcnc, "pin:torch_on:bit:0:in:Connect to spindle.N.on:None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok:bit:0:in:Arc Ok from Plasma Torch:None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:Enable the THC, if not enabled Z position is passed through:None:None");
MODULE_INFO(linuxcnc, "pin:z_pos_in:float:0:in:Z Motor Position Command in from axis.n.motor-pos-cmd:None:None");
MODULE_INFO(linuxcnc, "pin:z_pos_out:float:0:out:Z Motor Position Command Out:None:None");
MODULE_INFO(linuxcnc, "pin:z_fb_out:float:0:out:Z Position Feedback to Axis:None:None");
MODULE_INFO(linuxcnc, "pin:cur_offset:float:0:out:The Current Offset:None:None");
MODULE_INFO(linuxcnc, "pin:vel_status:bit:0:out:When the THC thinks we are at requested speed:None:None");
MODULE_INFO(linuxcnc, "pin:removing_offset:bit:0:out:Pin for testing:None:None");
MODULE_INFO(linuxcnc, "param:velocity_tol:float:0:rw:The deviation percent from planned velocity:None:None");
MODULE_INFO(linuxcnc, "param:correction_vel:float:0:rw:The Velocity to move Z to correct:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *torch_up_p;
    hal_bit_t *torch_down_p;
    hal_float_t *current_vel_p;
    hal_float_t *requested_vel_p;
    hal_bit_t *torch_on_p;
    hal_bit_t *arc_ok_p;
    hal_bit_t *enable_p;
    hal_float_t *z_pos_in_p;
    hal_float_t *z_pos_out_p;
    hal_float_t *z_fb_out_p;
    hal_float_t *cur_offset_p;
    hal_bit_t *vel_status_p;
    hal_bit_t *removing_offset_p;
    hal_float_t velocity_tol_p;
    hal_float_t correction_vel_p;
    float offset_p;

    float last_z_in_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_up_p), comp_id,
        "%s.torch-up", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_down_p), comp_id,
        "%s.torch-down", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->current_vel_p), comp_id,
        "%s.current-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->requested_vel_p), comp_id,
        "%s.requested-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_on_p), comp_id,
        "%s.torch-on", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->arc_ok_p), comp_id,
        "%s.arc-ok", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable_p), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->z_pos_in_p), comp_id,
        "%s.z-pos-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_pos_out_p), comp_id,
        "%s.z-pos-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_fb_out_p), comp_id,
        "%s.z-fb-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->cur_offset_p), comp_id,
        "%s.cur-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->vel_status_p), comp_id,
        "%s.vel-status", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->removing_offset_p), comp_id,
        "%s.removing-offset", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->velocity_tol_p), comp_id,
        "%s.velocity-tol", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->correction_vel_p), comp_id,
        "%s.correction-vel", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("thcud");
    if(comp_id < 0) return comp_id;
    r = export("thcud", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef torch_up
#undef torch_up_ptr
#define torch_up_ptr (__comp_inst->torch_up_p)
#define torch_up (0+*__comp_inst->torch_up_p)
#undef torch_down
#undef torch_down_ptr
#define torch_down_ptr (__comp_inst->torch_down_p)
#define torch_down (0+*__comp_inst->torch_down_p)
#undef current_vel
#undef current_vel_ptr
#define current_vel_ptr (__comp_inst->current_vel_p)
#define current_vel (0+*__comp_inst->current_vel_p)
#undef requested_vel
#undef requested_vel_ptr
#define requested_vel_ptr (__comp_inst->requested_vel_p)
#define requested_vel (0+*__comp_inst->requested_vel_p)
#undef torch_on
#undef torch_on_ptr
#define torch_on_ptr (__comp_inst->torch_on_p)
#define torch_on (0+*__comp_inst->torch_on_p)
#undef arc_ok
#undef arc_ok_ptr
#define arc_ok_ptr (__comp_inst->arc_ok_p)
#define arc_ok (0+*__comp_inst->arc_ok_p)
#undef enable
#undef enable_ptr
#define enable_ptr (__comp_inst->enable_p)
#define enable (0+*__comp_inst->enable_p)
#undef z_pos_in
#undef z_pos_in_ptr
#define z_pos_in_ptr (__comp_inst->z_pos_in_p)
#define z_pos_in (0+*__comp_inst->z_pos_in_p)
#undef z_pos_out
#undef z_pos_out_ptr
#define z_pos_out_ptr (__comp_inst->z_pos_out_p)
#define z_pos_out (*__comp_inst->z_pos_out_p)
#undef z_fb_out
#undef z_fb_out_ptr
#define z_fb_out_ptr (__comp_inst->z_fb_out_p)
#define z_fb_out (*__comp_inst->z_fb_out_p)
#undef cur_offset
#undef cur_offset_ptr
#define cur_offset_ptr (__comp_inst->cur_offset_p)
#define cur_offset (*__comp_inst->cur_offset_p)
#undef vel_status
#undef vel_status_ptr
#define vel_status_ptr (__comp_inst->vel_status_p)
#define vel_status (*__comp_inst->vel_status_p)
#undef removing_offset
#undef removing_offset_ptr
#define removing_offset_ptr (__comp_inst->removing_offset_p)
#define removing_offset (*__comp_inst->removing_offset_p)
#undef velocity_tol
#define velocity_tol (__comp_inst->velocity_tol_p)
#undef correction_vel
#define correction_vel (__comp_inst->correction_vel_p)
#undef offset
#define offset (__comp_inst->offset_p)
#undef last_z_in
#define last_z_in (__comp_inst->last_z_in_p)


#line 96 "/home/end/projects/linuxcnc/src/hal/components/thcud.comp"

#include "rtapi_math.h"

FUNCTION(_) {
    if(enable){
        float min_velocity = requested_vel -(requested_vel*(velocity_tol*0.01));
        if(current_vel > 0 && current_vel >= min_velocity){vel_status = 1;}
        else {vel_status =0;}
        
        if(torch_on && arc_ok && vel_status){ // allow correction
            if(torch_down){
                offset -= correction_vel;
            }
            if(torch_up){
                offset += correction_vel;
            }    
            last_z_in = 0;
        }
        if(!torch_on){ // remove any offset
            float z_diff;
            z_diff = z_pos_in - last_z_in;
            if(z_diff > 0 && offset != 0){ // torch is moving up
                removing_offset = 1;
                if(offset > 0){ // positive offset
                    if(offset > z_diff){ // remove some
                        offset -= z_diff;
                    }
                    else {offset = 0;}
                }
                if(offset < 0){ // negative offset
                    if(offset < z_diff){ // remove some
                        offset += z_diff;
                    }
                    else {offset = 0;}
                }
            }
            else {removing_offset = 0;}
            last_z_in = z_pos_in;
        }
        z_pos_out = z_pos_in + offset;
        z_fb_out = z_pos_in; // keep axis motor position fb from being confused
    }
    if(!enable){
        z_pos_out = z_pos_in;
        z_fb_out = z_pos_in; // keep axis motor position fb from being confused
    }
}


static int __comp_get_data_size(void) { return 0; }
