/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:moveoff:Component for HAL-only offsets");
MODULE_INFO(linuxcnc, "descr:\nThe moveoff component is used to offset joint positions using custom HAL connections.\nImplementing an offset-while-program-is-paused functionality is supported with appropriate connections for the input pins.\nNine joints are supported.\n\nThe axis offset pin values (offset-in-M) are continuously applied (respecting limits on value, velocity, and acceleration)\nto the output pins (offset-current-M, pos-plusoffset-M, fb-minusoffset-M) when both enabling input pins (apply-offsets and move-enable) are TRUE.\nThe two enabling inputs are anded internally.\nA \\fBwarning\\fR pin is set and a message issued if the apply-offsets pin is deasserted while offsets are applied.\nThe warning pin remains TRUE until the offsets are removed or the apply-offsets pin is set.\n\nTypically, the move-enable pin is connected to external controls and the apply-offsets pin is connected to halui.program.is-paused (for offsets only while paused) or set to TRUE (for continuously applied offsets).\n\nApplied offsets are \\fBautomatically returned\\fR to zero (respecting limits) when either of the enabling inputs is deactivated.\nThe zero value tolerance is specified by the epsilon input pin value.\n\nWaypoints are recorded when the moveoff component is enabled.\nWaypoints are managed with the waypoint-sample-secs and waypoint-threshold pins.\nWhen the backtrack-enable pin is TRUE, the auto-return path follows the recorded waypoints.\nWhen the memory available for waypoints is exhausted, offsets are frozen and the waypoint-limit pin is asserted.\nThis restriction applies regardless of the state of the backtrack-enable pin.\nAn enabling pin must be deasserted to allow a return to the original (non-offset position).\n\nBacktracking through waypoints results in \\fBslower\\fR movement rates as the moves are point-to-point respecting velocity and acceleration settings.\nThe velocity and acceleration limit pins can be managed dynamically to control offsets at all times.\n\nWhen backtrack-enable is FALSE, the auto-return move is \\fBNOT\\fR coordinated, each axis returns to zero at its own rate.\nIf a controlled path is wanted in this condition, each axis should be manually returned to zero before deasserting an enabling pin.\n\nThe waypoint-sample-secs, waypoint-threshold, and epsilon pins are evaluated only when the component is idle.\n\nThe offsets-applied output pin is provided to indicate the current state to a GUI so that program resumption can be managed.\nIf the offset(s) are non-zero when the apply-offsets pin is deasserted (for example when resuming a program when offsetting during a pause),\noffsets are returned to zero (respecting limits) and an \\fBError\\fR message is issued.\n\n\\fBCaution:\\fR If offsets are enabled and applied and the machine is turned off for any reason,\nany \\fBexternal\\fR HAL logic that manages the enabling pins and the offset-in-M inputs is responsible for their state when the machine is subsequently turned on again.\n\nThis HAL-only means of offsetting is typically not known to LinuxCNC nor available in GUI preview displays.\n\\fBNo protection is provided\\fR for offset moves that exceed soft limits managed by LinuxCNC.\nSince soft limits are not honored, an offset move may encounter hard limits (or \\fBCRASH\\fR if there are no limit switches).\nUse of the offset-min-M and offset-max-M inputs to limit travel is recommended.\nTriggering a hard limit will turn off the machine -- see \\fBCaution\\fR above.\n\nThe offset-in-M values may be set with inifile settings, controlled by a GUI, or managed by other HAL components and connections.\nFixed values may be appropriate in simple cases where the direction and amount of offset is well-defined but a control method is required to deactivate an enabling pin in order to return offsets to zero.\nGUIs may provide means for users to set, increment, decrement, and accumulate offset values for each axis and may set offset-in-M values to zero before deasserting an enabling pin.\n\nThe default values for accel, vel, min, max, epsilon, waypoint-sample-secs, and waypoint-threshold may not be suitable for any particular application.\nThis HAL component is unaware of limits enforced elsewhere by LinuxCNC.\nUsers should test usage in a simulator application and understand all hazards \\fBbefore\\fR use on hardware.\n\nThe module personality item sets the number of joints supported (default==3, maximum is 9).\n\nUse of the names= option for naming is \\fBrequired\\fR for compatibility with the gui provided as scripts/moveoff_gui:\n  loadrt moveoff names=\\fBmv\\fR personality=number_of_joints\n\n");
MODULE_INFO(linuxcnc, "see_also:\n\\fBmoveoff_gui\\fR(1)\n");
MODULE_INFO(linuxcnc, "examples:\nExample simulator configs that demonstrate the moveoff component and a simple gui\n(scripts/moveoff_gui) are located in configs/sim/axis/moveoff. The AXIS GUI is\nused for the demonstrations and the configs can be adapted for other GUIs like\nTouchy and Gscreen.  An example with the Touchy GUI is provided in configs/sim/touchy/ngcgui/.\n\n");
MODULE_INFO(linuxcnc, "pin:power_on:bit:0:in:Connect to motion.motion-enabled:None:None");
MODULE_INFO(linuxcnc, "pin:move_enable:bit:0:in:Enable offsets (Enabling requires apply-offset TRUE also):None:None");
MODULE_INFO(linuxcnc, "pin:apply_offsets:bit:0:in:Enable offsets (Enabling requires move-enable TRUE also):None:None");
MODULE_INFO(linuxcnc, "pin:backtrack-enable:bit:0:in:Enable backtrack on auto-return:1:None");
MODULE_INFO(linuxcnc, "pin:epsilon:float:0:in:When enabling pins are deactivated, return to un-offsetted position within epsilon units.  Warning: values that are too small in value may cause overshoot.  A minimum value of 0.0001 is \\fBsilently enforced\\fR.:0.0005:None");
MODULE_INFO(linuxcnc, "pin:waypoint-threshold:float:0:in:Minimum distance (in a single axis) for a new waypoint:0.02:None");
MODULE_INFO(linuxcnc, "pin:waypoint-sample-secs:float:0:in:Minimum sample interval (in seconds) for a new waypoint:0.02:None");
MODULE_INFO(linuxcnc, "pin:warning:bit:0:out:Set TRUE if apply-offsets is deasserted while offset-applied is TRUE.:None:None");
MODULE_INFO(linuxcnc, "pin:offset_applied:bit:0:out:TRUE if one or more offsets are applied.:None:None");
MODULE_INFO(linuxcnc, "pin:waypoint-limit:bit:0:out:Indicates waypoint limit reached (motion ceases), an enabling pin must be deasserted to initiate return to original position.:0:None");
MODULE_INFO(linuxcnc, "pin:waypoint-ct:s32:0:out:Waypoint count (for debugging):None:None");
MODULE_INFO(linuxcnc, "pin:waypoint-percent-used:s32:0:out:Percent of available waypoints used:None:None");
MODULE_INFO(linuxcnc, "pin:offset-in-#:float:(9, 'personality'):in:Joint offset input value:None:None");
MODULE_INFO(linuxcnc, "pin:pos-#:float:(9, 'personality'):in:Joint position (typ: axis.0.motor-pos-cmd):None:None");
MODULE_INFO(linuxcnc, "pin:fb-#:float:(9, 'personality'):in:Joint feedback (typ from encoder and input to pid controller (pid.feedback)):None:None");
MODULE_INFO(linuxcnc, "pin:offset-current-#:float:(9, 'personality'):out:Joint offset current value:None:None");
MODULE_INFO(linuxcnc, "pin:pos-plusoffset-#:float:(9, 'personality'):out:Computed joint position plus offset (typically connect to pid command input):None:None");
MODULE_INFO(linuxcnc, "pin:fb-minusoffset-#:float:(9, 'personality'):out:Computed Joint feedback minus offset (typically connected to axis.0.motor-pos-fb):None:None");
MODULE_INFO(linuxcnc, "pin:offset-vel-#:float:(9, 'personality'):in:Joint offset velocity limit:10:None");
MODULE_INFO(linuxcnc, "pin:offset-accel-#:float:(9, 'personality'):in:Joint offset acceleration limit:100:None");
MODULE_INFO(linuxcnc, "pin:offset-min-#:float:(9, 'personality'):in:Minimum limit for applied joint offset (typ negative):-1e20:None");
MODULE_INFO(linuxcnc, "pin:offset-max-#:float:(9, 'personality'):in:Maximum limit for applied offset (typ positive):1e20:None");
MODULE_INFO(linuxcnc, "pin:dbg_waypoint_limit_test:bit:0:in:Debug input to test with limited number of waypoints:None:None");
MODULE_INFO(linuxcnc, "pin:dbg_state:s32:0:out:Debug output for current state of state machine:None:None");
MODULE_INFO(linuxcnc, "funct:read_inputs:1:Read all inputs");
MODULE_INFO(linuxcnc, "funct:write_outputs:1:Write computed offset outputs\n(offset-current-M, pos-plusoffset-M, fb-minusoffset-M).\nAll other outputs are updated by read-inputs().");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dewey Garrett and Andy Pugh");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *power_on_p;
    hal_bit_t *move_enable_p;
    hal_bit_t *apply_offsets_p;
    hal_bit_t *backtrack_enable_p;
    hal_float_t *epsilon_p;
    hal_float_t *waypoint_threshold_p;
    hal_float_t *waypoint_sample_secs_p;
    hal_bit_t *warning_p;
    hal_bit_t *offset_applied_p;
    hal_bit_t *waypoint_limit_p;
    hal_s32_t *waypoint_ct_p;
    hal_s32_t *waypoint_percent_used_p;
    hal_float_t *offset_in_p[9];
    hal_float_t *pos_p[9];
    hal_float_t *fb_p[9];
    hal_float_t *offset_current_p[9];
    hal_float_t *pos_plusoffset_p[9];
    hal_float_t *fb_minusoffset_p[9];
    hal_float_t *offset_vel_p[9];
    hal_float_t *offset_accel_p[9];
    hal_float_t *offset_min_p[9];
    hal_float_t *offset_max_p[9];
    hal_bit_t *dbg_waypoint_limit_test_p;
    hal_s32_t *dbg_state_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void read_inputs(struct __comp_state *__comp_inst, long period);
static void write_outputs(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    personality = inst->_personality;
    r = hal_pin_bit_newf(HAL_IN, &(inst->power_on_p), comp_id,
        "%s.power-on", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->move_enable_p), comp_id,
        "%s.move-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->apply_offsets_p), comp_id,
        "%s.apply-offsets", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->backtrack_enable_p), comp_id,
        "%s.backtrack-enable", prefix);
    if(r != 0) return r;
    *(inst->backtrack_enable_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->epsilon_p), comp_id,
        "%s.epsilon", prefix);
    if(r != 0) return r;
    *(inst->epsilon_p) = 0.0005;
    r = hal_pin_float_newf(HAL_IN, &(inst->waypoint_threshold_p), comp_id,
        "%s.waypoint-threshold", prefix);
    if(r != 0) return r;
    *(inst->waypoint_threshold_p) = 0.02;
    r = hal_pin_float_newf(HAL_IN, &(inst->waypoint_sample_secs_p), comp_id,
        "%s.waypoint-sample-secs", prefix);
    if(r != 0) return r;
    *(inst->waypoint_sample_secs_p) = 0.02;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->warning_p), comp_id,
        "%s.warning", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->offset_applied_p), comp_id,
        "%s.offset-applied", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->waypoint_limit_p), comp_id,
        "%s.waypoint-limit", prefix);
    if(r != 0) return r;
    *(inst->waypoint_limit_p) = 0;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->waypoint_ct_p), comp_id,
        "%s.waypoint-ct", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->waypoint_percent_used_p), comp_id,
        "%s.waypoint-percent-used", prefix);
    if(r != 0) return r;
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-in-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->offset_in_p[j]), comp_id,
            "%s.offset-in-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin pos-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->pos_p[j]), comp_id,
            "%s.pos-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin fb-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->fb_p[j]), comp_id,
            "%s.fb-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-current-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->offset_current_p[j]), comp_id,
            "%s.offset-current-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin pos-plusoffset-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->pos_plusoffset_p[j]), comp_id,
            "%s.pos-plusoffset-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin fb-minusoffset-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->fb_minusoffset_p[j]), comp_id,
            "%s.fb-minusoffset-%01d", prefix, j);
        if(r != 0) return r;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-vel-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->offset_vel_p[j]), comp_id,
            "%s.offset-vel-%01d", prefix, j);
        if(r != 0) return r;
    *(inst->offset_vel_p[j]) = 10;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-accel-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->offset_accel_p[j]), comp_id,
            "%s.offset-accel-%01d", prefix, j);
        if(r != 0) return r;
    *(inst->offset_accel_p[j]) = 100;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-min-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->offset_min_p[j]), comp_id,
            "%s.offset-min-%01d", prefix, j);
        if(r != 0) return r;
    *(inst->offset_min_p[j]) = -1e20;
    }
    if((personality) > (9)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin offset-max-#: Requested size %d exceeds max size %d\n",(int)personality, (int)9);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->offset_max_p[j]), comp_id,
            "%s.offset-max-%01d", prefix, j);
        if(r != 0) return r;
    *(inst->offset_max_p[j]) = 1e20;
    }
    r = hal_pin_bit_newf(HAL_IN, &(inst->dbg_waypoint_limit_test_p), comp_id,
        "%s.dbg-waypoint-limit-test", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->dbg_state_p), comp_id,
        "%s.dbg-state", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.read-inputs", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))read_inputs, inst, 1, 0, comp_id);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.write-outputs", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))write_outputs, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of moveoff");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of moveoff");
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each moveoff");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("moveoff");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "moveoff.%d", i);
            r = export(buf, i, p_value("moveoff", buf, i) );
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx, p_value("moveoff", buf, idx) );
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef power_on
#undef power_on_ptr
#define power_on_ptr (__comp_inst->power_on_p)
#define power_on (0+*__comp_inst->power_on_p)
#undef move_enable
#undef move_enable_ptr
#define move_enable_ptr (__comp_inst->move_enable_p)
#define move_enable (0+*__comp_inst->move_enable_p)
#undef apply_offsets
#undef apply_offsets_ptr
#define apply_offsets_ptr (__comp_inst->apply_offsets_p)
#define apply_offsets (0+*__comp_inst->apply_offsets_p)
#undef backtrack_enable
#undef backtrack_enable_ptr
#define backtrack_enable_ptr (__comp_inst->backtrack_enable_p)
#define backtrack_enable (0+*__comp_inst->backtrack_enable_p)
#undef epsilon
#undef epsilon_ptr
#define epsilon_ptr (__comp_inst->epsilon_p)
#define epsilon (0+*__comp_inst->epsilon_p)
#undef waypoint_threshold
#undef waypoint_threshold_ptr
#define waypoint_threshold_ptr (__comp_inst->waypoint_threshold_p)
#define waypoint_threshold (0+*__comp_inst->waypoint_threshold_p)
#undef waypoint_sample_secs
#undef waypoint_sample_secs_ptr
#define waypoint_sample_secs_ptr (__comp_inst->waypoint_sample_secs_p)
#define waypoint_sample_secs (0+*__comp_inst->waypoint_sample_secs_p)
#undef warning
#undef warning_ptr
#define warning_ptr (__comp_inst->warning_p)
#define warning (*__comp_inst->warning_p)
#undef offset_applied
#undef offset_applied_ptr
#define offset_applied_ptr (__comp_inst->offset_applied_p)
#define offset_applied (*__comp_inst->offset_applied_p)
#undef waypoint_limit
#undef waypoint_limit_ptr
#define waypoint_limit_ptr (__comp_inst->waypoint_limit_p)
#define waypoint_limit (*__comp_inst->waypoint_limit_p)
#undef waypoint_ct
#undef waypoint_ct_ptr
#define waypoint_ct_ptr (__comp_inst->waypoint_ct_p)
#define waypoint_ct (*__comp_inst->waypoint_ct_p)
#undef waypoint_percent_used
#undef waypoint_percent_used_ptr
#define waypoint_percent_used_ptr (__comp_inst->waypoint_percent_used_p)
#define waypoint_percent_used (*__comp_inst->waypoint_percent_used_p)
#undef offset_in
#undef offset_in_ptr
#define offset_in_ptr(i) (__comp_inst->offset_in_p[i])
#define offset_in(i) (0+*(__comp_inst->offset_in_p[i]))
#undef pos
#undef pos_ptr
#define pos_ptr(i) (__comp_inst->pos_p[i])
#define pos(i) (0+*(__comp_inst->pos_p[i]))
#undef fb
#undef fb_ptr
#define fb_ptr(i) (__comp_inst->fb_p[i])
#define fb(i) (0+*(__comp_inst->fb_p[i]))
#undef offset_current
#undef offset_current_ptr
#define offset_current_ptr(i) (__comp_inst->offset_current_p[i])
#define offset_current(i) (*(__comp_inst->offset_current_p[i]))
#undef pos_plusoffset
#undef pos_plusoffset_ptr
#define pos_plusoffset_ptr(i) (__comp_inst->pos_plusoffset_p[i])
#define pos_plusoffset(i) (*(__comp_inst->pos_plusoffset_p[i]))
#undef fb_minusoffset
#undef fb_minusoffset_ptr
#define fb_minusoffset_ptr(i) (__comp_inst->fb_minusoffset_p[i])
#define fb_minusoffset(i) (*(__comp_inst->fb_minusoffset_p[i]))
#undef offset_vel
#undef offset_vel_ptr
#define offset_vel_ptr(i) (__comp_inst->offset_vel_p[i])
#define offset_vel(i) (0+*(__comp_inst->offset_vel_p[i]))
#undef offset_accel
#undef offset_accel_ptr
#define offset_accel_ptr(i) (__comp_inst->offset_accel_p[i])
#define offset_accel(i) (0+*(__comp_inst->offset_accel_p[i]))
#undef offset_min
#undef offset_min_ptr
#define offset_min_ptr(i) (__comp_inst->offset_min_p[i])
#define offset_min(i) (0+*(__comp_inst->offset_min_p[i]))
#undef offset_max
#undef offset_max_ptr
#define offset_max_ptr(i) (__comp_inst->offset_max_p[i])
#define offset_max(i) (0+*(__comp_inst->offset_max_p[i]))
#undef dbg_waypoint_limit_test
#undef dbg_waypoint_limit_test_ptr
#define dbg_waypoint_limit_test_ptr (__comp_inst->dbg_waypoint_limit_test_p)
#define dbg_waypoint_limit_test (0+*__comp_inst->dbg_waypoint_limit_test_p)
#undef dbg_state
#undef dbg_state_ptr
#define dbg_state_ptr (__comp_inst->dbg_state_p)
#define dbg_state (*__comp_inst->dbg_state_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 138 "/home/end/projects/linuxcnc/src/hal/components/moveoff.comp"

#include "rtapi_math.h"
#define NCHANNELS         9
#define NWAYPOINTS     1000
#define TST_NWAYPOINTS   50
#define MIN_EPSILON       0.0001

typedef enum {
  IDLE,
  MOVE_AWAY,
  MOVE_BACK,
} the_state;

typedef struct {
int state[NCHANNELS];
    hal_float_t old_in[NCHANNELS];
    hal_float_t old_out[NCHANNELS];
    hal_float_t old_v[NCHANNELS];
    hal_float_t old_limited_in[NCHANNELS];
} old_values_t;

struct lim3_input {
    hal_float_t  minlimit;
    hal_float_t  maxlimit;
    hal_float_t  maxvlimit;
    hal_float_t  maxalimit;
    hal_float_t  in;
    hal_float_t  old_in;
    hal_float_t  old_out;
    hal_float_t  old_v;
};

static void reset_old(int nchan, old_values_t* d) {
    int i;
    for (i = 0;i < nchan; i++) {
        d->old_in[i]         = 0;
        d->old_out[i]        = 0;
        d->old_v[i]          = 0;
        d->old_limited_in[i] = 0;
    }
}

static int offset_removed(int nchan, old_values_t d, hal_float_t eps) {
    int removed = 1;
    int i;
    for (i = 0 ; i < nchan ; i++) {
        if (fabs(d.old_out[i]) > eps) {
            removed = 0;
            break;
        }
    }
    return removed;
}

static int at_waypoint(int nchan,
                       hal_float_t g[],
                       hal_float_t p[],hal_float_t eps) {
    int within_eps = 1;
    int i;

    for (i = 0 ; i < nchan ; i++) {
        if ( fabs(p[i] - g[i]) > eps ) {
            within_eps = 0;
            break;
        }
    }
    return within_eps;
}

static long theperiod;
static void lim3(struct lim3_input input,
                 hal_float_t* old_in,
                 hal_float_t* limited_out,
                 hal_float_t* old_v
                ) {
    /* following code is adapted from limit3.comp */
    hal_float_t dt = theperiod * 1e-9;
    hal_float_t in_v, min_v, max_v, avg_v;
    hal_float_t min_out,max_out;
    hal_float_t ramp_a, match_time, est_in, est_out;
    hal_float_t err, dv, dp;
    hal_float_t limited_in;

    /* apply first order limit */
    limited_in = input.in;
    if (input.in < input.minlimit) {
        limited_in = input.minlimit;
    }
    if (input.in > input.maxlimit) {
         limited_in = input.maxlimit;
    }
    *old_in = limited_in;

    /* calculate input derivative */
    in_v = (limited_in - input.old_in) / dt;

    /* determine v and out that can be reached in one period */
    min_v = input.old_v - input.maxalimit * dt;
    if (min_v < -input.maxvlimit) {
        min_v = -input.maxvlimit;
    }
    max_v = input.old_v + input.maxalimit * dt;
    if (max_v > input.maxvlimit) {
        max_v = input.maxvlimit;
    }

    min_out = input.old_out + min_v * dt;
    max_out = input.old_out + max_v * dt;
    if (   ( limited_in >= min_out ) && ( limited_in <= max_out )
        && ( in_v >= min_v ) && ( in_v <= max_v ) ) {
        /* we can follow the command without hitting a limit */
        *limited_out = limited_in;
        *old_v = ( *limited_out - input.old_out ) / dt;
    } else {
        /* can't follow commanded path while obeying limits */
        /* determine which way we need to ramp to match v */
        if ( in_v > input.old_v ) {
            ramp_a = input.maxalimit;
        } else {
            ramp_a = -input.maxalimit;
        }
        /* determine how long the match would take */
        match_time = ( in_v - input.old_v ) / ramp_a;
        /* where we will be at the end of the match */

        avg_v = ( in_v + input.old_v + ramp_a * dt ) * 0.5;
        est_out = input.old_out + avg_v * match_time;
        /* calculate the expected command position at that time */
        est_in = input.old_in + in_v * match_time;
        /* calculate position error at that time */
        err = est_out - est_in;
        /* calculate change in final position if we ramp in the
        opposite direction for one period */
        dv = -2.0 * ramp_a * dt;
        dp = dv * match_time;
        /* decide what to do */
        if ( fabs(err + dp*2.0) < fabs(err) ) {
            ramp_a = -ramp_a;
        }
        if ( ramp_a < 0.0 ) {
            *limited_out = min_out;
            *old_v = min_v;
        } else {
            *limited_out = max_out;
            *old_v = max_v;
        }
    }
    return;
}

static the_state    state = IDLE;
static int          next_waypoint_index;
static rtapi_s64    last_waypoint_time;
static rtapi_s64    now;
static hal_float_t  time_since_last_sample;
static hal_float_t  move_threshold;
static hal_float_t  min_sample_interval;
static bool         backtrack;
static bool         gave_msg;
static int          max_waypoints = NWAYPOINTS;
static struct       lim3_input input;
static hal_float_t  goal[NCHANNELS];
static hal_float_t  waypoints[NCHANNELS][NWAYPOINTS];
static old_values_t data;

static hal_float_t  eps_in_use;
static bool         move_in_progress = 0;
static the_state    next_state;

//compile time setting:
static const bool   allow_backtrack_enable_change = 1;
// 1 ==> backtrack-enable can be changed while enabled
//       waypoints are always accumulated and waypoint_limit enforced
// 0 ==> backtrack-enable is sampled only while IDLE
//       if backtrack-enable == 0, no waypoints and no waypoint_limit
//       (e.g., unlimited no. of offset samples)

FUNCTION(read_inputs) {
    hal_float_t last,delta;
    int r;
    bool all_enables  = power_on && move_enable && apply_offsets;

    if (allow_backtrack_enable_change) {
      backtrack = backtrack_enable;
      // change at any time (controls auto-return)
    }

    theperiod = period;
    now = rtapi_get_time();
    if (state == IDLE) {
        backtrack = backtrack_enable; // ref: allow_backtrack_enable_change
        // allow changes only when IDLE for these inputs:
        move_threshold = waypoint_threshold;
        min_sample_interval = waypoint_sample_secs;
        eps_in_use = epsilon;
        if (eps_in_use < MIN_EPSILON) { eps_in_use = MIN_EPSILON; }


        if (dbg_waypoint_limit_test) {
            max_waypoints = TST_NWAYPOINTS; // tiny limit for testing
        } else {
            max_waypoints = NWAYPOINTS;
        }
    }

    if (backtrack || allow_backtrack_enable_change) {
        int r;
        bool sufficient_movement_for_new_waypoint = 0;

        time_since_last_sample = (hal_float_t)(now - last_waypoint_time)/1e9;
        switch (state) {
            case IDLE:
                  next_waypoint_index = 0;
                  break;
            case MOVE_AWAY:
                //note: gui must handle waypoint_limit -- here we just stop
                if (waypoint_limit) break; // no more room for waypoints

                if (time_since_last_sample < min_sample_interval) break;
                for (r=0; r < personality; r++) {
                    last  = waypoints[r][next_waypoint_index - 1];
                    delta = fabs(offset_current(r) - last);
                    if (delta > move_threshold) {
                        sufficient_movement_for_new_waypoint = 1;
                        break; //for loop
                    }
                }
                if (!sufficient_movement_for_new_waypoint) break;
                for (r=0; r < personality; r++) {
                    waypoints[r][next_waypoint_index] = offset_current(r);
                }
                last_waypoint_time = now;
                next_waypoint_index++;
                if (next_waypoint_index > max_waypoints - 1) {
                    waypoint_limit = 1;
                } else {
                    waypoint_limit = 0;
                }
                break;
            case MOVE_BACK: break;
       }
    } //end save waypoints

    //{begin state control
    switch (state) {
      case IDLE:
            last_waypoint_time = now;
            if ( all_enables ) {
                next_state = MOVE_AWAY;
                move_in_progress = 1;
                for (r = 0; r < personality; r++) {
                    goal[r] = offset_in(r);
                }
            }
            break;
      case MOVE_AWAY:
            move_in_progress = 1;
            if ( all_enables ) {
               // allow offset movements
               for (r = 0; r < personality; r++) {
                    goal[r] = offset_in(r);
               }
               break;
            }
            // one (or more) enablers is gone
            next_state = MOVE_BACK;
            if (!power_on) {
                reset_old(personality, &data);
                move_in_progress = 0;
                offset_applied = 0;
                next_state = IDLE;
                break;
            }
            for (r = 0; r < personality; r++) {
                goal[r] = 0; // default (eg not waypoint backtrack)
            }
            if (backtrack) {
                if ( next_waypoint_index > 0 ) {
                    for (r = 0; r < personality; r++) {
                        goal[r] = waypoints[r][next_waypoint_index-1];
                    }
                    waypoint_limit = 0;
                    next_waypoint_index--;
                }
            }
            break;

      case  MOVE_BACK:
            if (!power_on) {
                reset_old(personality, &data);
                move_in_progress = 0;
                offset_applied = 0;
                next_state = IDLE;
                break;
            }
            move_in_progress = 1;
            if (backtrack) {
                if ( next_waypoint_index > 0 ) {
                    hal_float_t pcur[NCHANNELS];
                    for (r=0; r < personality; r++) {
                        pcur[r] = offset_current(r);
                    }
                    if (at_waypoint(personality, goal, pcur, eps_in_use)) {
                        for (r = 0; r < personality; r++) {
                            goal[r] = waypoints[r][next_waypoint_index];
                        }
                        next_waypoint_index--;
                    }
                } else {
                    for (r = 0; r < personality; r++) {
                        goal[r] = 0; //final goal
                    }
                }
            }

            if (!offset_applied) {
                // offsets gone, return to IDLE
                next_state = IDLE;
                move_in_progress = 0;
                reset_old(personality, &data);
            }
            break;
    }

    if (   !apply_offsets
        &&  offset_applied
        ) {
        warning = 1;
        if (!gave_msg) {
            // apply_offsets deasserted while offset_applied
            // for example:
            //   1) program stopped with offsets applied
            //   2) (no *.resume-inhibit pin) or (-no_resume_inhibit option)
            //      and program resumed with offsets applied
            for (r = 0; r < personality; r++) {
                rtapi_print_msg(RTAPI_MSG_ERR,
                           "Index: %i, offset=%f",
                           r, data.old_out[r]);
            }
            rtapi_print_msg(RTAPI_MSG_ERR,
            "apply_offsets deasserted before offsets removed "
            "moveoff.comp: WARNING"
            );
            gave_msg = 1;
        }
    } else {
        gave_msg = 0;
        warning = 0;
    }
    //}end state control
} //read_inputs

FUNCTION(write_outputs) {
    int r;
    // move with limits on position, velocity, acceleration
    for (r = 0; r < personality; r++) {
        if (move_in_progress) {
            input.in = goal[r];
            input.minlimit   = offset_min(r);
            input.maxlimit   = offset_max(r);
            input.maxvlimit  = offset_vel(r);
            input.maxalimit  = offset_accel(r);
            input.old_in     = data.old_in[r];
            input.old_out    = data.old_out[r];
            input.old_v      = data.old_v[r];

            if ( waypoint_limit && (state == MOVE_AWAY) ) {
                // no movement in MOVE_AWAY (require: remove enable)
            } else {
                hal_float_t last_old = data.old_out[r];
                lim3(input,
                     &data.old_in[r],
                     &data.old_out[r],
                     &data.old_v[r]
                     );
                offset_current(r) = data.old_out[r];
                fb_minusoffset(r) = fb(r)  - offset_current(r)
                                  - (last_old - data.old_out[r]);
                pos_plusoffset(r) = pos(r) + offset_current(r);
            }
        } else {
            pos_plusoffset(r) = pos(r);
            offset_current(r) = 0;
            fb_minusoffset(r) = fb(r);
        }
    }

    offset_applied = ! offset_removed(personality, data, eps_in_use);
    if ( !offset_applied ) {
        // reset backtrack
        next_waypoint_index = 0;
        waypoint_limit = 0;
    }

    waypoint_ct = next_waypoint_index;
    waypoint_percent_used = 100*next_waypoint_index/max_waypoints;

    dbg_state = state;
    state = next_state;
} //write_outputs

EXTRA_SETUP() {
    if (personality == 0) personality = 3;
    return 0;
}

static int __comp_get_data_size(void) { return 0; }
