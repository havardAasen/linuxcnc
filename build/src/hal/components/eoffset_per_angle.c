/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:eoffset_per_angle:Compute External Offset Per Angle");
MODULE_INFO(linuxcnc, "descr:\n\nAn offset is computed (from one of several functions) based on\nan input angle in degrees.  The angle could be a rotary\ncoordinate value or a spindle angle.\n\nThe computed offset is represented as an s32 \\fBkcounts\\fR output\npin that is a compatible input to external offset pins like\n\\fBaxis.L.eoffset-counts\\fR where \\fBL\\fR is the coordinate\nletter.  Scaling of the s32 \\fBkcounts\\fR is controlled by the\ninput (\\fBk\\fR) -- its reciprocal value is presented on an output pin\n(\\fBkreciprocal\\fR) for connection to \\fBaxis.L.eoffset-scale\\fR.\nThe default value for \\fBk\\fR should be suitable for most uses.\n\nThe built-in functions use pins \\fBfmult\\fR and \\fBrfraction\\fR\nto control the output frequency (or number of polygon sides)\nand amplitude respectively.  The  \\fBrfraction\\fR pin controls\nthe offset amplitude as a fraction of the \\fBradius-ref\\fR pin.\n\nOne of the four built-in functions is specified by the \\fBfnum\\fR pin:\n  \\fB0\\fR: f0 inside  polygon  (requires \\fBfmult\\fR == nsides >= 3)\n  \\fB1\\fR: f1 outside polygon  (requires \\fBfmult\\fR == nsides >= 3)\n  \\fB2\\fR: f2 sinusoid\n  \\fB3\\fR: f3 square wave\n\nUnsupported \\fBfnum\\fR values default to use function f0.\n");
MODULE_INFO(linuxcnc, "notes:\n\\fBradius-ref\\fR:\nThe computed offsets are based on the \\fBradius-ref\\fR pin\nvalue.  This pin may be set to a constant radius value or\ncontrolled by a user interface or by g code program (using\n\\fBM68\\fR and a \\fBmotion.analog-out-NN pin for instance).\n\n\\fBStopping\\fR:\nWhen the \\fBenable-in\\fR pin is deasserted, the offset is\nreturned to zero respecting the allocated acceleration\nand velocity limits.  The allocations for coordinate \\fBL\\fR\nare typically controlled by an ini file setting:\n\\fB[AXIS_L]OFFSET_AV_RATIO\\fR.\n\nIf unsupported parameters are supplied to a function (for instance\na polygon with fewer than three sides), the current offset\nwill be returned to zero (respecting velocity and acceleration\nconstraints).  After correcting the offending parameter, the\n\\fBenable-in\\fR pin must be toggled to resume offset\ncomputations.\n");
MODULE_INFO(linuxcnc, "examples:\nAn example simulation configuration is provided at:\n\\fBconfigs/sim/axis/external_offsets/opa.ini\\fR.  A\nsimulated XZC machine uses the \\fBC\\fR coordinate angle to\noffset the transverse \\fBX\\fR coordinate according to\nthe selected \\fBfnum\\fR function.\n");
MODULE_INFO(linuxcnc, "pin:active:bit:0:in:From: motion.eoffset-active:0:None");
MODULE_INFO(linuxcnc, "pin:is_on:bit:0:in:From: halui.machine.is-on:0:None");
MODULE_INFO(linuxcnc, "pin:enable_in:bit:0:in:Enable Input:0:None");
MODULE_INFO(linuxcnc, "pin:radius_ref:float:0:in:Radius reference (see notes):1:None");
MODULE_INFO(linuxcnc, "pin:angle:float:0:in:Input angle (in degrees):0:None");
MODULE_INFO(linuxcnc, "pin:start_angle:float:0:in:Start angle (in degrees):0:None");
MODULE_INFO(linuxcnc, "pin:fnum:s32:0:in:Function selector (default 0):0:None");
MODULE_INFO(linuxcnc, "pin:rfraction:float:0:in:Offset amplitude (+/- fraction of radius_ref):0.1:None");
MODULE_INFO(linuxcnc, "pin:fmult:float:0:in:Offset frequency multiplier:6:None");
MODULE_INFO(linuxcnc, "pin:k:u32:0:in:Scaling Factor (if 0, use 10000):10000:None");
MODULE_INFO(linuxcnc, "pin:is_off:bit:0:out:invert is_on (for convenience):None:None");
MODULE_INFO(linuxcnc, "pin:enable_out:bit:0:out:To: axis.L.eoffset-enable:None:None");
MODULE_INFO(linuxcnc, "pin:clear:bit:0:out:To: axis.L.eoffset-clear:None:None");
MODULE_INFO(linuxcnc, "pin:kcounts:s32:0:out:To: axis.L.eoffset-counts:None:None");
MODULE_INFO(linuxcnc, "pin:kreciprocal:float:0:out:To: axis.L.eoffset-scale (1/k):None:None");
MODULE_INFO(linuxcnc, "pin:eoffset_dbg:float:0:out:offset (debug pin--use kcounts & kreciprocal):None:None");
MODULE_INFO(linuxcnc, "pin:state_dbg:u32:0:out:state  (debug pin):None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dewey Garrett");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *active_p;
    hal_bit_t *is_on_p;
    hal_bit_t *enable_in_p;
    hal_float_t *radius_ref_p;
    hal_float_t *angle_p;
    hal_float_t *start_angle_p;
    hal_s32_t *fnum_p;
    hal_float_t *rfraction_p;
    hal_float_t *fmult_p;
    hal_u32_t *k_p;
    hal_bit_t *is_off_p;
    hal_bit_t *enable_out_p;
    hal_bit_t *clear_p;
    hal_s32_t *kcounts_p;
    hal_float_t *kreciprocal_p;
    hal_float_t *eoffset_dbg_p;
    hal_u32_t *state_dbg_p;
    int run_ct_p;

    int delay_ct_p;

    int messaged_p;

    int err_stop_p;

    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = hal_pin_bit_newf(HAL_IN, &(inst->active_p), comp_id,
        "%s.active", prefix);
    if(r != 0) return r;
    *(inst->active_p) = 0;
    r = hal_pin_bit_newf(HAL_IN, &(inst->is_on_p), comp_id,
        "%s.is-on", prefix);
    if(r != 0) return r;
    *(inst->is_on_p) = 0;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable_in_p), comp_id,
        "%s.enable-in", prefix);
    if(r != 0) return r;
    *(inst->enable_in_p) = 0;
    r = hal_pin_float_newf(HAL_IN, &(inst->radius_ref_p), comp_id,
        "%s.radius-ref", prefix);
    if(r != 0) return r;
    *(inst->radius_ref_p) = 1;
    r = hal_pin_float_newf(HAL_IN, &(inst->angle_p), comp_id,
        "%s.angle", prefix);
    if(r != 0) return r;
    *(inst->angle_p) = 0;
    r = hal_pin_float_newf(HAL_IN, &(inst->start_angle_p), comp_id,
        "%s.start-angle", prefix);
    if(r != 0) return r;
    *(inst->start_angle_p) = 0;
    r = hal_pin_s32_newf(HAL_IN, &(inst->fnum_p), comp_id,
        "%s.fnum", prefix);
    if(r != 0) return r;
    *(inst->fnum_p) = 0;
    r = hal_pin_float_newf(HAL_IN, &(inst->rfraction_p), comp_id,
        "%s.rfraction", prefix);
    if(r != 0) return r;
    *(inst->rfraction_p) = 0.1;
    r = hal_pin_float_newf(HAL_IN, &(inst->fmult_p), comp_id,
        "%s.fmult", prefix);
    if(r != 0) return r;
    *(inst->fmult_p) = 6;
    r = hal_pin_u32_newf(HAL_IN, &(inst->k_p), comp_id,
        "%s.k", prefix);
    if(r != 0) return r;
    *(inst->k_p) = 10000;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_off_p), comp_id,
        "%s.is-off", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->enable_out_p), comp_id,
        "%s.enable-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->clear_p), comp_id,
        "%s.clear", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->kcounts_p), comp_id,
        "%s.kcounts", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->kreciprocal_p), comp_id,
        "%s.kreciprocal", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->eoffset_dbg_p), comp_id,
        "%s.eoffset-dbg", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->state_dbg_p), comp_id,
        "%s.state-dbg", prefix);
    if(r != 0) return r;
    inst->run_ct_p = 0.0;
    inst->delay_ct_p = 0.0;
    inst->messaged_p = 0.0;
    inst->err_stop_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of eoffset_per_angle");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of eoffset_per_angle");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("eoffset_per_angle");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "eoffset-per-angle.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef active
#undef active_ptr
#define active_ptr (__comp_inst->active_p)
#define active (0+*__comp_inst->active_p)
#undef is_on
#undef is_on_ptr
#define is_on_ptr (__comp_inst->is_on_p)
#define is_on (0+*__comp_inst->is_on_p)
#undef enable_in
#undef enable_in_ptr
#define enable_in_ptr (__comp_inst->enable_in_p)
#define enable_in (0+*__comp_inst->enable_in_p)
#undef radius_ref
#undef radius_ref_ptr
#define radius_ref_ptr (__comp_inst->radius_ref_p)
#define radius_ref (0+*__comp_inst->radius_ref_p)
#undef angle
#undef angle_ptr
#define angle_ptr (__comp_inst->angle_p)
#define angle (0+*__comp_inst->angle_p)
#undef start_angle
#undef start_angle_ptr
#define start_angle_ptr (__comp_inst->start_angle_p)
#define start_angle (0+*__comp_inst->start_angle_p)
#undef fnum
#undef fnum_ptr
#define fnum_ptr (__comp_inst->fnum_p)
#define fnum (0+*__comp_inst->fnum_p)
#undef rfraction
#undef rfraction_ptr
#define rfraction_ptr (__comp_inst->rfraction_p)
#define rfraction (0+*__comp_inst->rfraction_p)
#undef fmult
#undef fmult_ptr
#define fmult_ptr (__comp_inst->fmult_p)
#define fmult (0+*__comp_inst->fmult_p)
#undef k
#undef k_ptr
#define k_ptr (__comp_inst->k_p)
#define k (0+*__comp_inst->k_p)
#undef is_off
#undef is_off_ptr
#define is_off_ptr (__comp_inst->is_off_p)
#define is_off (*__comp_inst->is_off_p)
#undef enable_out
#undef enable_out_ptr
#define enable_out_ptr (__comp_inst->enable_out_p)
#define enable_out (*__comp_inst->enable_out_p)
#undef clear
#undef clear_ptr
#define clear_ptr (__comp_inst->clear_p)
#define clear (*__comp_inst->clear_p)
#undef kcounts
#undef kcounts_ptr
#define kcounts_ptr (__comp_inst->kcounts_p)
#define kcounts (*__comp_inst->kcounts_p)
#undef kreciprocal
#undef kreciprocal_ptr
#define kreciprocal_ptr (__comp_inst->kreciprocal_p)
#define kreciprocal (*__comp_inst->kreciprocal_p)
#undef eoffset_dbg
#undef eoffset_dbg_ptr
#define eoffset_dbg_ptr (__comp_inst->eoffset_dbg_p)
#define eoffset_dbg (*__comp_inst->eoffset_dbg_p)
#undef state_dbg
#undef state_dbg_ptr
#define state_dbg_ptr (__comp_inst->state_dbg_p)
#define state_dbg (*__comp_inst->state_dbg_p)
#undef run_ct
#define run_ct (__comp_inst->run_ct_p)
#undef delay_ct
#define delay_ct (__comp_inst->delay_ct_p)
#undef messaged
#define messaged (__comp_inst->messaged_p)
#undef err_stop
#define err_stop (__comp_inst->err_stop_p)
#undef data
#define data (*(the_data*)(__comp_inst->_data))


#line 106 "/home/end/projects/linuxcnc/src/hal/components/eoffset_per_angle.comp"

#include <rtapi_math.h>

#define FINISH_DELAY 0
#define TO_RAD       M_PI/180

typedef enum {
    OFF,
    READY,
    RUNNING,
    STOPPING,
    FINISH,
} state;

typedef struct ofunc_data {
  state  thestate;
  double adeg;
  double astart;
  double r_ref;
  double r_frac;
  double fmultiplier;
  double ovalue;
} the_data;

typedef int ofunc(struct ofunc_data*);
static      ofunc func0,func1,func2,func3;

#define OPA_DEBUG
#undef  OPA_DEBUG
#ifdef  OPA_DEBUG
  #define LVL RTAPI_MSG_INFO
  #define dprint(msg,n) do { \
    rtapi_set_msg_level(LVL); \
    rtapi_print_msg(LVL,"%20s %5d\n",msg,n); \
  } while (0)
#else
  #define dprint(msg,n)
#endif

FUNCTION(_) {
    struct ofunc_data* dptr = &data;
#define STATE dptr->thestate

    int    kfactor;
    ofunc* thefunc;

    run_ct++;
    state_dbg = STATE;
    kfactor = k;
    if (k == 0) {kfactor = 10000;}
    kreciprocal = 1/((float)kfactor);

    is_off = !is_on; // convenience pin

    if (is_off) {
        // note: the external_offsets implementation defines
        //       axis.L.eoffset as zero when machine is off
        err_stop   = 0;
        enable_out = 0;
        kcounts    = 0; eoffset_dbg = 0;
        messaged   = 0;
        STATE      = OFF;
        return;
    }

    switch (STATE) {
    case OFF:
        // require an enable_in 0-->1 transition to advance to READY
        if (enable_in) {
            if (!messaged) {
                rtapi_print_msg(RTAPI_MSG_ERR,
                "eoffset_per_angle: active enable-in not honored at start");
                messaged = 1;
            }
            return;
        }
        err_stop = 0;
        messaged = 1;
        kcounts  = 0;
        STATE    = READY;
        dprint("OFF->READY",kcounts);
        return;
        break;
    case READY:
        if (!enable_in) {return;}
        kcounts    = 0; eoffset_dbg = 0;
        enable_out = 0;
        delay_ct   = 0;
        STATE      = RUNNING;
        dprint("READY->RUNNING",kcounts);
        return;
        break;
    case RUNNING:
        if (enable_in) {
            enable_out = 1;
            STATE      = RUNNING;
        } else {
            /*
            ** When the enable_in pin is deasserted, kcounts are set to
            ** zero and the simple trajectory planner removes the offset to
            ** within its stopping criterion.  Under some conditions, a
            ** residual offset may remain.  Connecting the clear pin to
            ** axis.L.eoffset-clear forces the axis->ext_offset_tp.pos_cmd
            ** to zero to remove any residual with no modifications to
            ** simple_tp.c
            */
            clear    = 1;
            kcounts  = 0; eoffset_dbg = 0;
            STATE    = STOPPING;
            delay_ct = run_ct;
            dprint("RUNNING->STOPPING",kcounts);
            return;
        }
        break;
    case STOPPING:
        if (active) {
            STATE = STOPPING;
        } else {
            // !active ==> stopping criterion met
            delay_ct = run_ct;
            STATE    = FINISH;
            dprint("STOPPING->FINISH",kcounts);
        }
        return;
        break;
    case FINISH:
        // provision for delay if needed
        if (run_ct < (FINISH_DELAY + delay_ct) ) {
            STATE = FINISH;
        } else {
            enable_out = 0;
            if (err_stop) {
                STATE = OFF;
                dprint("FINISH->OFF",kcounts);
            } else {
                STATE = READY;
                dprint("FINISH->READY",kcounts);
            }
        }
        clear = 0;
        return;
        break;
    } //switch (STATE)

    switch (fnum) {
      case  0: thefunc = func0; break;
      case  1: thefunc = func1; break;
      case  2: thefunc = func2; break;
      case  3: thefunc = func3; break;
      default: thefunc = func0; break;
    }
    dptr->adeg        = angle;
    dptr->astart      = start_angle;
    dptr->r_ref       = radius_ref;
    dptr->r_frac      = rfraction;
    dptr->fmultiplier = fmult;

    if (thefunc(dptr) ) {
        // thefunc returned nonzero (problem)
        err_stop     = 1;
        dptr->ovalue = 0;
        kcounts      = 0; eoffset_dbg = 0;
        STATE        = STOPPING;
        rtapi_print_msg(RTAPI_MSG_ERR,
             "eoffset_per_angle stopping:func%d problem\n",fnum);
        return;
    }

    kcounts     = kfactor * dptr->ovalue;
    eoffset_dbg = kcounts * kreciprocal; // debug pin
    return;
}

static int func0 (struct ofunc_data* d)
{
    // for cutting an inside polygon
    // (start with negative rfraction, and gradually increase to zero)
    // polygon outscribed by circle of radius r_ref
    // (fmultiplier > 2)
    double uangle,divisor;

    if (d->fmultiplier <= 2) {
        rtapi_print_msg(RTAPI_MSG_ERR,
             "func0 bad fmultiplier: %g\n",d->fmultiplier);
        return -1;
    }

    divisor   = 360/d->fmultiplier;
    uangle    = d->adeg + divisor/2 - d->astart;
    d->ovalue = (1 + d->r_frac)
              * d->r_ref/cos((divisor/2 - fmod(uangle,divisor))*TO_RAD)
              - d->r_ref;
    return 0;
}

static int func1 (struct ofunc_data* d)
{
    // for cutting an outside polygon
    // (start with positive rfraction, and gradually reduce to zero)
    // polygon inscribed by circle of radius r_ref
    // (fmultiplier > 2)
    double uangle,divisor;

    if (d->fmultiplier <= 2) {
        rtapi_print_msg(RTAPI_MSG_ERR,
             "func1 bad fmultiplier: %g\n",d->fmultiplier);
        return -1;
    }

    divisor   = 360/d->fmultiplier;
    uangle    = d->adeg + divisor/2 - d->astart;
    d->ovalue = (1 + d->r_frac)
              * d->r_ref*cos(M_PI/d->fmultiplier)/cos((divisor/2 - fmod(uangle,divisor))*TO_RAD)
              - d->r_ref;
    return 0;
}

static int func2 (struct ofunc_data* d)
{
    // sin() -90 ==> start at zero amplitude
    double uangle;
    uangle    = d->fmultiplier * (d->adeg - d->astart) + -90;
    d->ovalue = (0.5 * d->r_frac* d->r_ref) * (1 + sin(uangle * TO_RAD));
    return 0;
}

static int func3 (struct ofunc_data* d)
{
    // square() -90 ==> start at zero amplitude
    // useful for looking at affects of ini settings
    // max vel & accel and offset_av_ratio
    double uangle;
    double value = -1;
    uangle = d->fmultiplier * (d->adeg - d->astart) + -90;
    if (sin(uangle * TO_RAD) >= 0) {value = 1;}
    d->ovalue = (0.5 * d->r_frac* d->r_ref) * (1 + value);
    return 0;
}

static int __comp_get_data_size(void) { return sizeof(the_data); }
