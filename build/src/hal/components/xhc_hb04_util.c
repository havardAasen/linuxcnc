/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:xhc_hb04_util:xhc-hb04 convenience utility");
MODULE_INFO(linuxcnc, "descr:Provides logic for a start/pause button and an interface\nto \\fBhalui.program.is_paused\\fR, \\fBis_idle\\fR, \\fBis_running\\fR to generate outputs for \\fBhalui.program.pause\\fR, \\fBresume\\fR, \\fBrun\\fR.\n\nIncludes 4 simple lowpass filters with \\fBcoef\\fR and \\fBscale\\fR pins.  The coef value should\nbe 0 <= coef <=1, smaller coef values slow response.  See the lowpass manpage for\ncalculating the filter time constant ($ man lowpass).\n\n");
MODULE_INFO(linuxcnc, "pin:start_or_pause:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:is_paused:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:is_idle:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:is_running:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:pause:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:resume:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:run:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:in0:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in1:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in2:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in3:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:out0:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:out1:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:out2:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:out3:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:scale0:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:scale1:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:scale2:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:scale3:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:coef0:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:coef1:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:coef2:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:coef3:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "pin:divide_by_k_in:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:divide_by_k_out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:k:float:0:in::1.0:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dewey Garrett");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *start_or_pause_p;
    hal_bit_t *is_paused_p;
    hal_bit_t *is_idle_p;
    hal_bit_t *is_running_p;
    hal_bit_t *pause_p;
    hal_bit_t *resume_p;
    hal_bit_t *run_p;
    hal_s32_t *in0_p;
    hal_s32_t *in1_p;
    hal_s32_t *in2_p;
    hal_s32_t *in3_p;
    hal_s32_t *out0_p;
    hal_s32_t *out1_p;
    hal_s32_t *out2_p;
    hal_s32_t *out3_p;
    hal_float_t *scale0_p;
    hal_float_t *scale1_p;
    hal_float_t *scale2_p;
    hal_float_t *scale3_p;
    hal_float_t *coef0_p;
    hal_float_t *coef1_p;
    hal_float_t *coef2_p;
    hal_float_t *coef3_p;
    hal_float_t *divide_by_k_in_p;
    hal_float_t *divide_by_k_out_p;
    hal_float_t *k_p;
    double value0_p;

    double value1_p;

    double value2_p;

    double value3_p;

    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = hal_pin_bit_newf(HAL_IN, &(inst->start_or_pause_p), comp_id,
        "%s.start-or-pause", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->is_paused_p), comp_id,
        "%s.is-paused", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->is_idle_p), comp_id,
        "%s.is-idle", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->is_running_p), comp_id,
        "%s.is-running", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->pause_p), comp_id,
        "%s.pause", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->resume_p), comp_id,
        "%s.resume", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->run_p), comp_id,
        "%s.run", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->in0_p), comp_id,
        "%s.in0", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->in1_p), comp_id,
        "%s.in1", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->in2_p), comp_id,
        "%s.in2", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->in3_p), comp_id,
        "%s.in3", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->out0_p), comp_id,
        "%s.out0", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->out1_p), comp_id,
        "%s.out1", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->out2_p), comp_id,
        "%s.out2", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->out3_p), comp_id,
        "%s.out3", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->scale0_p), comp_id,
        "%s.scale0", prefix);
    if(r != 0) return r;
    *(inst->scale0_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->scale1_p), comp_id,
        "%s.scale1", prefix);
    if(r != 0) return r;
    *(inst->scale1_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->scale2_p), comp_id,
        "%s.scale2", prefix);
    if(r != 0) return r;
    *(inst->scale2_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->scale3_p), comp_id,
        "%s.scale3", prefix);
    if(r != 0) return r;
    *(inst->scale3_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->coef0_p), comp_id,
        "%s.coef0", prefix);
    if(r != 0) return r;
    *(inst->coef0_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->coef1_p), comp_id,
        "%s.coef1", prefix);
    if(r != 0) return r;
    *(inst->coef1_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->coef2_p), comp_id,
        "%s.coef2", prefix);
    if(r != 0) return r;
    *(inst->coef2_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->coef3_p), comp_id,
        "%s.coef3", prefix);
    if(r != 0) return r;
    *(inst->coef3_p) = 1.0;
    r = hal_pin_float_newf(HAL_IN, &(inst->divide_by_k_in_p), comp_id,
        "%s.divide-by-k-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->divide_by_k_out_p), comp_id,
        "%s.divide-by-k-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->k_p), comp_id,
        "%s.k", prefix);
    if(r != 0) return r;
    *(inst->k_p) = 1.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of xhc_hb04_util");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of xhc_hb04_util");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("xhc_hb04_util");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "xhc-hb04-util.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef start_or_pause
#undef start_or_pause_ptr
#define start_or_pause_ptr (__comp_inst->start_or_pause_p)
#define start_or_pause (0+*__comp_inst->start_or_pause_p)
#undef is_paused
#undef is_paused_ptr
#define is_paused_ptr (__comp_inst->is_paused_p)
#define is_paused (0+*__comp_inst->is_paused_p)
#undef is_idle
#undef is_idle_ptr
#define is_idle_ptr (__comp_inst->is_idle_p)
#define is_idle (0+*__comp_inst->is_idle_p)
#undef is_running
#undef is_running_ptr
#define is_running_ptr (__comp_inst->is_running_p)
#define is_running (0+*__comp_inst->is_running_p)
#undef pause
#undef pause_ptr
#define pause_ptr (__comp_inst->pause_p)
#define pause (*__comp_inst->pause_p)
#undef resume
#undef resume_ptr
#define resume_ptr (__comp_inst->resume_p)
#define resume (*__comp_inst->resume_p)
#undef run
#undef run_ptr
#define run_ptr (__comp_inst->run_p)
#define run (*__comp_inst->run_p)
#undef in0
#undef in0_ptr
#define in0_ptr (__comp_inst->in0_p)
#define in0 (0+*__comp_inst->in0_p)
#undef in1
#undef in1_ptr
#define in1_ptr (__comp_inst->in1_p)
#define in1 (0+*__comp_inst->in1_p)
#undef in2
#undef in2_ptr
#define in2_ptr (__comp_inst->in2_p)
#define in2 (0+*__comp_inst->in2_p)
#undef in3
#undef in3_ptr
#define in3_ptr (__comp_inst->in3_p)
#define in3 (0+*__comp_inst->in3_p)
#undef out0
#undef out0_ptr
#define out0_ptr (__comp_inst->out0_p)
#define out0 (*__comp_inst->out0_p)
#undef out1
#undef out1_ptr
#define out1_ptr (__comp_inst->out1_p)
#define out1 (*__comp_inst->out1_p)
#undef out2
#undef out2_ptr
#define out2_ptr (__comp_inst->out2_p)
#define out2 (*__comp_inst->out2_p)
#undef out3
#undef out3_ptr
#define out3_ptr (__comp_inst->out3_p)
#define out3 (*__comp_inst->out3_p)
#undef scale0
#undef scale0_ptr
#define scale0_ptr (__comp_inst->scale0_p)
#define scale0 (0+*__comp_inst->scale0_p)
#undef scale1
#undef scale1_ptr
#define scale1_ptr (__comp_inst->scale1_p)
#define scale1 (0+*__comp_inst->scale1_p)
#undef scale2
#undef scale2_ptr
#define scale2_ptr (__comp_inst->scale2_p)
#define scale2 (0+*__comp_inst->scale2_p)
#undef scale3
#undef scale3_ptr
#define scale3_ptr (__comp_inst->scale3_p)
#define scale3 (0+*__comp_inst->scale3_p)
#undef coef0
#undef coef0_ptr
#define coef0_ptr (__comp_inst->coef0_p)
#define coef0 (0+*__comp_inst->coef0_p)
#undef coef1
#undef coef1_ptr
#define coef1_ptr (__comp_inst->coef1_p)
#define coef1 (0+*__comp_inst->coef1_p)
#undef coef2
#undef coef2_ptr
#define coef2_ptr (__comp_inst->coef2_p)
#define coef2 (0+*__comp_inst->coef2_p)
#undef coef3
#undef coef3_ptr
#define coef3_ptr (__comp_inst->coef3_p)
#define coef3 (0+*__comp_inst->coef3_p)
#undef divide_by_k_in
#undef divide_by_k_in_ptr
#define divide_by_k_in_ptr (__comp_inst->divide_by_k_in_p)
#define divide_by_k_in (0+*__comp_inst->divide_by_k_in_p)
#undef divide_by_k_out
#undef divide_by_k_out_ptr
#define divide_by_k_out_ptr (__comp_inst->divide_by_k_out_p)
#define divide_by_k_out (*__comp_inst->divide_by_k_out_p)
#undef k
#undef k_ptr
#define k_ptr (__comp_inst->k_p)
#define k (0+*__comp_inst->k_p)
#undef value0
#define value0 (__comp_inst->value0_p)
#undef value1
#define value1 (__comp_inst->value1_p)
#undef value2
#define value2 (__comp_inst->value2_p)
#undef value3
#define value3 (__comp_inst->value3_p)
#undef data
#define data (*(xhc_data*)(__comp_inst->_data))


#line 52 "/home/end/projects/linuxcnc/src/hal/components/xhc_hb04_util.comp"
#include <rtapi_math.h>

typedef struct { int old_start_or_pause; } xhc_data;

FUNCTION(_) {

    if (k == 0) {
      divide_by_k_out = 1e99;
    } else {
      divide_by_k_out = divide_by_k_in / k;
    }

    // protect so that 0 <= coef <= 1
    value0 += (in0 - value0) * (fabs(coef0) < 1 ? fabs(coef0) : 1);
    value1 += (in1 - value1) * (fabs(coef1) < 1 ? fabs(coef1) : 1);
    value2 += (in2 - value2) * (fabs(coef2) < 1 ? fabs(coef2) : 1);
    value3 += (in3 - value3) * (fabs(coef3) < 1 ? fabs(coef3) : 1);

    out0 =  ceil(value0 * scale0 - .5);
    out1 =  ceil(value1 * scale1 - .5);
    out2 =  ceil(value2 * scale2 - .5);
    out3 =  ceil(value3 * scale3 - .5);

    if (data.old_start_or_pause == start_or_pause) return;
    data.old_start_or_pause = start_or_pause;
    if (!start_or_pause) {
        pause = run = resume = 0;
        return;
    }
    if (is_paused)  {pause = 0; run = 0; resume = 1; }
    if (is_running) {pause = 1; run = 0; resume = 0; }
    if (is_idle)    {pause = 0; run = 1; resume = 0; }
}

static int __comp_get_data_size(void) { return sizeof(xhc_data); }
