/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:orient:Provide a PID command input for orientation mode based on current spindle position, target angle and orient mode");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:enable angular output for orientation mode:None:None");
MODULE_INFO(linuxcnc, "pin:mode:s32:0:in:0: rotate - shortest move; 1: always rotate clockwise; 2: always rotate counterclockwise:None:None");
MODULE_INFO(linuxcnc, "pin:position:float:0:in:spindle position input, unit 1 rev:None:None");
MODULE_INFO(linuxcnc, "pin:angle:float:0:in:orient target position in degrees, 0 <= angle < 360:None:None");
MODULE_INFO(linuxcnc, "pin:command:float:0:out:target spindle position, input to PID command:None:None");
MODULE_INFO(linuxcnc, "pin:poserr:float:0:out:in degrees - aid for PID tuning:None:None");
MODULE_INFO(linuxcnc, "pin:is-oriented:bit:0:out:This pin goes high when poserr < tolerance. Use to drive spindle.N.is-oriented:None:None");
MODULE_INFO(linuxcnc, "pin:tolerance:float:0:in:The tolerance in degrees for considering the align completed:0.5:None");
MODULE_INFO(linuxcnc, "funct:_:1:Update \\fBcommand\\fR based on \\fBenable\\fR, \\fBposition\\fR, \\fBmode\\fR and \\fBangle\\fR.");
MODULE_INFO(linuxcnc, "author:Michael Haberler");
MODULE_INFO(linuxcnc, "descr:\nThis component is designed to support a spindle orientation PID loop by providing a \ncommand value, and fit with the motion spindle-orient support pins to support the M19 code.\n\nThe spindle is assumed to have stopped in an arbitrary position. The spindle\nencoder position is linked to the  \\fBposition\\fR pin.\nThe  current value of the position pin is sampled on a positive edge on the \\fBenable\\fR pin, and \n\\fBcommand\\fR is computed and set as follows: floor(number of \nfull spindle revolutions \nin the \\fBposition\\fR sampled on positive edge) \nplus \\fBangle\\fR/360 (the fractional revolution) +1/-1/0 depending on \\fBmode\\fR.\n\nThe \\fBmode\\fR pin is interpreted as follows:\n\n0: the spindle rotates in the direction with the lesser angle, \nwhich may be clockwise or counterclockwise.\n\n1: the spindle rotates always rotates clockwise to the new angle.\n\n2: the spindle rotates always rotates counterclockwise to the new angle.\n \n\n.SH HAL USAGE\n\nOn \\fBspindle.N.orient\\fR disconnect the spindle control and connect to the orient-pid \nloop:\n\nloadrt orient names=orient\n.br\nloadrt pid names=orient-pid\n.br\nnet orient-angle spindle.N.orient-angle orient.angle\n.br\nnet orient-mode spindle.N.orient-mode orient.mode\n.br\nnet orient-enable spindle.N.orient orient.enable orient-pid.enable\n.br\nnet spindle-in-pos orient.is-oriented spindle.N.is-oriented\n.br\nnet spindle-pos encoder.position orient.position orient-pid.feedback\n.br\nnet orient-command orient.command orient-pid.command\n.br\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *enable_p;
    hal_s32_t *mode_p;
    hal_float_t *position_p;
    hal_float_t *angle_p;
    hal_float_t *command_p;
    hal_float_t *poserr_p;
    hal_bit_t *is_oriented_p;
    hal_float_t *tolerance_p;
    int last_enable_p;

    int debounce_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable_p), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->mode_p), comp_id,
        "%s.mode", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->position_p), comp_id,
        "%s.position", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->angle_p), comp_id,
        "%s.angle", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->command_p), comp_id,
        "%s.command", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->poserr_p), comp_id,
        "%s.poserr", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_oriented_p), comp_id,
        "%s.is-oriented", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->tolerance_p), comp_id,
        "%s.tolerance", prefix);
    if(r != 0) return r;
    *(inst->tolerance_p) = 0.5;
    inst->last_enable_p = 0.0;
    inst->debounce_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of orient");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of orient");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("orient");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "orient.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef enable
#undef enable_ptr
#define enable_ptr (__comp_inst->enable_p)
#define enable (0+*__comp_inst->enable_p)
#undef mode
#undef mode_ptr
#define mode_ptr (__comp_inst->mode_p)
#define mode (0+*__comp_inst->mode_p)
#undef position
#undef position_ptr
#define position_ptr (__comp_inst->position_p)
#define position (0+*__comp_inst->position_p)
#undef angle
#undef angle_ptr
#define angle_ptr (__comp_inst->angle_p)
#define angle (0+*__comp_inst->angle_p)
#undef command
#undef command_ptr
#define command_ptr (__comp_inst->command_p)
#define command (*__comp_inst->command_p)
#undef poserr
#undef poserr_ptr
#define poserr_ptr (__comp_inst->poserr_p)
#define poserr (*__comp_inst->poserr_p)
#undef is_oriented
#undef is_oriented_ptr
#define is_oriented_ptr (__comp_inst->is_oriented_p)
#define is_oriented (*__comp_inst->is_oriented_p)
#undef tolerance
#undef tolerance_ptr
#define tolerance_ptr (__comp_inst->tolerance_p)
#define tolerance (0+*__comp_inst->tolerance_p)
#undef last_enable
#define last_enable (__comp_inst->last_enable_p)
#undef debounce
#define debounce (__comp_inst->debounce_p)


#line 68 "/home/end/projects/linuxcnc/src/hal/components/orient.comp"
#include <rtapi_math.h>

FUNCTION(_) {

    double target_angle;
    double latched_position;
    is_oriented = 0; // spindle.is-oriented inhibits spindle.orient
    if (enable) {
       if (enable ^ last_enable) {     // positive edge on enable
           is_oriented = 0;
            debounce = 0;
            latched_position = position; // sample now
            target_angle =  angle/360.0;
            switch (mode) {
            case 0: // shortest move
                command = floor(latched_position+0.5-target_angle) + target_angle;
                break;
            case 1: // always cw
                command = ceil(latched_position-target_angle)  + target_angle;
                break;
            case 2: // always ccw
                command = floor(latched_position-target_angle) + target_angle ;
                break;
            }
       }
       poserr = (position - command) * 360.0;
       debounce += (fabs(poserr) < tolerance && debounce <=100);
       is_oriented = (debounce > 100);
    }
    last_enable = enable;
}


static int __comp_get_data_size(void) { return 0; }
