/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:time:Time on in Hours, Minutes, Seconds");
MODULE_INFO(linuxcnc, "descr:\nTime\n\nWhen either the time.N.start or time.N.pause bits goes true the cycle\ntimer resets and starts to time until time.N.start AND time.N.pause go\nfalse. When the time.N.pause bit goes true timing is paused until\ntime.N.pause goes false. If you connect time.N.start to\nhalui.program.is-running and leave time.N.pause unconnected the timer\nwill reset during a pause. See the example connections below for more\ninformation.\n\nTime returns the hours, minutes, and seconds that time.N.start is true.\n\nSample PyVCP code to display the hours:minutes:seconds.\n\n<pyvcp>\n  <hbox>\n  <label>\n    <text>\"Cycle Time\"</text>\n    <font>(\"Helvetica\",14)</font>\n  </label>\n  <u32> \n      <halpin>\"time-hours\"</halpin>\n      <font>(\"Helvetica\",14)</font>\n      <format>\"2d\"</format>\n  </u32>\n  <label>\n    <text>\":\"</text>\n    <font>(\"Helvetica\",14)</font>\n  </label>\n  <u32> \n      <halpin>\"time-minutes\"</halpin>\n      <font>(\"Helvetica\",14)</font>\n      <format>\"2d\"</format>\n  </u32>\n  <label>\n    <text>\":\"</text>\n    <font>(\"Helvetica\",14)</font>\n  </label>\n  <u32> \n      <halpin>\"time-seconds\"</halpin>\n      <font>(\"Helvetica\",14)</font>\n      <format>\"2d\"</format>\n  </u32>\n  </hbox>\n</pyvcp>\n\nIn your post-gui.hal file you might use one of the following to connect\nthis timer:\n \n For a new config:\n \n loadrt time\n addf time.0 servo-thread\n net cycle-timer        time.0.start <= halui.program.is-running\n net cycle-timer-pause  time.0.pause <= halui.program.is-paused\n net cycle-seconds pyvcp.time-seconds <= time.0.seconds\n net cycle-minutes pyvcp.time-minutes <= time.0.minutes\n net cycle-hours pyvcp.time-hours <= time.0.hours\n\n\n Previous to this version if you wanted the timer to continue running\n during a pause instead of resetting, you had to use a HAL NOT component\n to invert the halui.program.is-idle pin and connect to time.N.start as\n shown below:\n\n loadrt time\n loadrt not\n addf time.0 servo-thread\n addf not.0 servo-thread\n net prog-running not.0.in <= halui.program.is-idle\n net cycle-timer time.0.start <= not.0.out\n net cycle-seconds pyvcp.time-seconds <= time.0.seconds\n net cycle-minutes pyvcp.time-minutes <= time.0.minutes\n net cycle-hours pyvcp.time-hours <= time.0.hours\n \n For those who have this setup already, you can simply add a net connecting\n time.N.pause to halui.program.is-paused:\n\n net cycle-timer-pause time.0.pause <= halui.program.is-paused\n\n\n");
MODULE_INFO(linuxcnc, "author:John Thornton, itaib, Moses McKnight");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "pin:start:bit:0:in:Timer On:None:None");
MODULE_INFO(linuxcnc, "pin:pause:bit:0:in:Pause:0:None");
MODULE_INFO(linuxcnc, "pin:seconds:u32:0:out:Seconds:None:None");
MODULE_INFO(linuxcnc, "pin:minutes:u32:0:out:Minutes:None:None");
MODULE_INFO(linuxcnc, "pin:hours:u32:0:out:Hours:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *start_p;
    hal_bit_t *pause_p;
    hal_u32_t *seconds_p;
    hal_u32_t *minutes_p;
    hal_u32_t *hours_p;
    double totalnsec_p;

    int old_start_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->start_p), comp_id,
        "%s.start", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->pause_p), comp_id,
        "%s.pause", prefix);
    if(r != 0) return r;
    *(inst->pause_p) = 0;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->seconds_p), comp_id,
        "%s.seconds", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->minutes_p), comp_id,
        "%s.minutes", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->hours_p), comp_id,
        "%s.hours", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of time");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of time");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("time");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "time.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef start
#undef start_ptr
#define start_ptr (__comp_inst->start_p)
#define start (0+*__comp_inst->start_p)
#undef pause
#undef pause_ptr
#define pause_ptr (__comp_inst->pause_p)
#define pause (0+*__comp_inst->pause_p)
#undef seconds
#undef seconds_ptr
#define seconds_ptr (__comp_inst->seconds_p)
#define seconds (*__comp_inst->seconds_p)
#undef minutes
#undef minutes_ptr
#define minutes_ptr (__comp_inst->minutes_p)
#define minutes (*__comp_inst->minutes_p)
#undef hours
#undef hours_ptr
#define hours_ptr (__comp_inst->hours_p)
#define hours (*__comp_inst->hours_p)
#undef totalnsec
#define totalnsec (__comp_inst->totalnsec_p)
#undef old_start
#define old_start (__comp_inst->old_start_p)


#line 108 "/home/end/projects/linuxcnc/src/hal/components/time.comp"

#include "rtapi_math.h"

FUNCTION(_) {
    rtapi_u32 totalseconds;
    int running = start | pause;
    if(running && !old_start) totalnsec = 0;

    if(start && !pause){
    totalnsec = totalnsec + period;
    totalseconds = totalnsec * 0.000000001;
    seconds = totalseconds % 60;
	minutes = (totalseconds / 60) % 60;
	hours = (totalseconds / 3600);
	}
	old_start = running;
}


static int __comp_get_data_size(void) { return 0; }
