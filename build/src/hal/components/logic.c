/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:logic:LinuxCNC HAL component providing configurable logic functions\n\n.B loadrt logic\n.B [count=N|names=name1[,name2...]]\n.B personality=0xXXXX[,0xXXXX...]\n\n.TP\n\\fBcount\\fR The number of logical gates.\n.TP\n\\fBnames\\fR The named logical gates to create.\n.TP\n\\fBpersonality\\fR Comma separated list of hexadecimal number.\nEach number defines the behaviour of the individual logic gate.  The\nlist must have the same number of personalities as the N count.\n\n");
MODULE_INFO(linuxcnc, "pin:in-##:bit:(16, 'personality & 0xff'):in::None:None");
MODULE_INFO(linuxcnc, "pin:and:bit:0:out::None:personality & 0x100");
MODULE_INFO(linuxcnc, "pin:or:bit:0:out::None:personality & 0x200");
MODULE_INFO(linuxcnc, "pin:xor:bit:0:out::None:personality & 0x400");
MODULE_INFO(linuxcnc, "pin:nand:bit:0:out::None:personality & 0x800");
MODULE_INFO(linuxcnc, "pin:nor:bit:0:out::None:personality & 0x1000");
MODULE_INFO(linuxcnc, "funct:_:0:Read the inputs and toggle the output bit.");
MODULE_INFO(linuxcnc, "descr:\nGeneral `logic function' component.  Can perform `and', `or',\n`nand', `nor' and `xor' of up to 16 inputs.\n.LP\nDetermine the proper value for `personality'\nby adding the inputs and outputs then convert to hex:\n.IP \\(bu 4\nThe number of input pins, usually from 2 to 16\n.IP \\(bu\n256 (0x100)  if the `and' output is desired\n.IP \\(bu\n512 (0x200)  if the `or' output is desired\n.IP \\(bu\n1024 (0x400)  if the `xor' (exclusive or) output is desired\n.IP \\(bu\n2048 (0x800)  if the `nand' output is desired\n.IP \\(bu\n4096 (0x1000)  if the `nor' output is desired\n.LP\nOutputs can be combined, for example 2 + 256 + 1024 = 1282 converted to hex\nwould be 0x502 and would have two inputs and have both `xor' and `and' outputs.\n");
MODULE_INFO(linuxcnc, "examples:\n.PP\nThis is an OR circuit connected to three different signals, two inputs\nnamed sig-in-0 and sig-in-1, and one output named sig-out.  First the\ncircuit is defined, then its function is connected to the servo real\ntime thread, last, its pins are connected to the wanted signals.\n.IP\n.nf\nloadrt logic count=1 personality=0x202\naddf logic.0 servo-thread\nnet sig-in-0 => logic.0.in-00\nnet sig-in-1 => logic.0.in-01\nnet sig-out  <= logic.0.or\n.fi\n\n.PP\nThis is a named AND circuit with two inputs and one output.\n.IP\n.nf\nloadrt logic names=both personality=0x102\naddf both servo-thread\nnet sig-in-0 => both.in-00\nnet sig-in-1 => both.in-01\nnet sig-out  <= both.and\n.fi\n\n");
MODULE_INFO(linuxcnc, "see_also:\n\\fBand2\\fR(9),\n\\fBlut5\\fR(9),\n\\fBnot\\fR(9),\n\\fBor2\\fR(9),\n\\fBxor2\\fR(9)\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Jeff Epler");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *in_p[16];
    hal_bit_t *and_p;
    hal_bit_t *or_p;
    hal_bit_t *xor_p;
    hal_bit_t *nand_p;
    hal_bit_t *nor_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    if((personality & 0xff) > (16)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin in-##: Requested size %d exceeds max size %d\n",(int)personality & 0xff, (int)16);
        return -ENOSPC;
    }
    for(j=0; j < (personality & 0xff); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->in_p[j]), comp_id,
            "%s.in-%02d", prefix, j);
        if(r != 0) return r;
    }
if(personality & 0x100) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->and_p), comp_id,
        "%s.and", prefix);
    if(r != 0) return r;
}
if(personality & 0x200) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->or_p), comp_id,
        "%s.or", prefix);
    if(r != 0) return r;
}
if(personality & 0x400) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->xor_p), comp_id,
        "%s.xor", prefix);
    if(r != 0) return r;
}
if(personality & 0x800) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->nand_p), comp_id,
        "%s.nand", prefix);
    if(r != 0) return r;
}
if(personality & 0x1000) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->nor_p), comp_id,
        "%s.nor", prefix);
    if(r != 0) return r;
}
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 0, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of logic");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of logic");
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each logic");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("logic");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "logic.%d", i);
            r = export(buf, i, p_value("logic", buf, i) );
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx, p_value("logic", buf, idx) );
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#undef in_ptr
#define in_ptr(i) (__comp_inst->in_p[i])
#define in(i) (0+*(__comp_inst->in_p[i]))
#undef and
#undef and_ptr
#define and_ptr (__comp_inst->and_p)
#define and (*__comp_inst->and_p)
#undef or
#undef or_ptr
#define or_ptr (__comp_inst->or_p)
#define or (*__comp_inst->or_p)
#undef xor
#undef xor_ptr
#define xor_ptr (__comp_inst->xor_p)
#define xor (*__comp_inst->xor_p)
#undef nand
#undef nand_ptr
#define nand_ptr (__comp_inst->nand_p)
#define nand (*__comp_inst->nand_p)
#undef nor
#undef nor_ptr
#define nor_ptr (__comp_inst->nor_p)
#define nor (*__comp_inst->nor_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 83 "/home/end/projects/linuxcnc/src/hal/components/logic.comp"
FUNCTION(_) {
    int i, a=1, o=0, x=0;
    for(i=0; i < (personality & 0xff); i++) {
        if(in(i)) { o = 1; x = !x; }
        else { a = 0; }
    }
    if(personality & 0x100) and = a;
    if(personality & 0x200) or = o;
    if(personality & 0x400) xor = x;
    if(personality & 0x800) nand = !a;
    if(personality & 0x1000) nor = !o;
}

static int __comp_get_data_size(void) { return 0; }
