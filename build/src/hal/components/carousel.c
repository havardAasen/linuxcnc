/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#include "rtapi_math.h"
#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:carousel:Orient a toolchanger carousel using various encoding schemes\n\n.B loadrt carousel pockets=\\fIN\\fR[,\\fIN\\fR]\n.B encoding=\\fIssss\\fR[,\\fIsss\\fR]\\fB\n.B num_sense=\\fIN\\fR[,\\fIN\\fR]\n.B dir=\\fIN\\fR[,\\fIN]\n\n.RS 4\n.TP\n\\fBpockets\\fR The number of pockets in each toolchanger.\nUse up to 8 numbers separated by commas to create multiple carousel components.\n.TP\n\\fBencoding\\fR The position encoding.\ngray, binary, bcd, index, edge, counts or single. Default = 'gray'\n.TP\n\\fBnum_sense\\fR The number of position sense pins.\nDefault = 4.\n.TP\n\\fBdir\\fR Set to 1 for unidirectional or  2 for bidirectional operation.\nDefault = bidirectional\n.TP\n\\fBparity\\fR Set to 1 for odd parity, 0 for even parity checking.\nDefault = 0 (even)\n.RE");
MODULE_INFO(linuxcnc, "descr:This component is intended to help operate various types of\ncarousel-type toolchangers. \n\nThe component can be configured to operate with binary, binary-coded decimal (BCD)\nor gray-coded position feedback ('binary;, 'bcd' and 'gray' modes)\nIt can alternatively work with an individual sensor for each tool position\n('single' mode) or with a sensor at each tool position and a separate index\n('index' mode). Systems using a stepper motor or quadrature encoder are\nalso supported ('counts' mode).\n\\fBedge\\fR is a special case of index mode for tool\nchangers with pockets on both the rising and falling edges of the position sensor.\n(Seen on at least one Denford Orac.)\n\nBoth unidirectional and bidirectional systems are supported and those that reverse\nagainst a stop when in position. \n\nThe number of carousel component instances created depends on the number of\nentries in the 'pockets' modparam. For example\n\n.B loadrt carousel pockets=10,10,8\n\nWould create 3 carousel instances with 10, 10 and 8 pockets. The other \nparameters are optional. If absent then defaults will be used. Any missing\nentry will assume the previous value.\n\nWhen the enable pin is set to true the component will immediately set the \n\"active\" pin to true and then (for a bidirectional instance) calculate the\nshortest path to the requested pocket number. The appropriate motor direction\noutput pins will then be set. Bit outputs for forward and reverse are provided\nas well as a three-state velocity output for driving a DC motor PWM or a\nvelocity-mode stepgen.\n\nThe component will monitor the carousel position and, when the correct position\nis reached, set the motor-control pins to 0, set \"active\" to 0 and set \"ready\"\nto 1.\n\nIn 'index', 'edge' or 'counts'mode there is a need to find the initial\nhome position of the carousel.\nThe first time that the \"enable\" pin is set; the carousel will rotate forwards\nsearching for a home signal. In 'index' and 'edge' mode this is when\nboth the index and pulse inputs are true. In 'counts' mode only the index\ninput needs to be set to set home. Additionally in 'counts' mode the usual index-enable\nlogic of the encoder counters is supported.\n\nWith some carousel designs the carousel will not stop immediately. To allow for\nthis set the \\fBlign-dc\\fR pin to a low velocity to be used for a final latching move, and\nset the\\fBdecel-time\\fR to a suitable value.\nOnce the decel-time has expired the carousel will, if it was moving forwards, reverse back on\nto the position marker, off of the arker and then bak on to the FWD edge. If moving in reverse\nit will continue off the marker and then reverse slowly on to the FWD edge.\nThis algnment is only possible with a motor-vel controlled bidirectional carousel,\nOther combinations will be acepted but probably won't have the desired behaviour.\nSome tuning will be needed of align-dc and decel-time to achieve reliable operation.\n\nIn the unusual case that the index and pulse signals do not align it is\npossible to use HAL logic to achieve the desired pin switching during homing.\n\nSetting \"enable\" low does not halt the homing move, so if\nhoming on first tool change is not needed then the enable pin can be toggled by\nan axis homing pin or a script and the homing process will continue even if that\ndriving signal resets during the carousel homing move.\n\nTo operate the component with an encoder or stepgen use mode \"C\". The \\fBscale\\fR\npin should be the number of steps or encoder counts between pocket centres. The\n\\fBwidth\\fR pin can be used to stop the motor some distance before the centre of\nthe pocket to allow the motor time to decelerate.\nIn mode \"C\" it is possible to use either the speed/direction control used in other\nmodes or to use direct position mode using the counts-target pin. The\ninternal scaling of the encoder or stepgen should be set to 1.0. A PID\nhal component will be needed for encoder applications whereas stepgen\nconfigurations can use a stepgen in position control mode or in velocity\ncontrol mode with a PID.\n\nFor tool changers which lock the carousel against a stop the \\fBrev-pulse\\fR pin can\nbe set to a non-zero value. The motor-rev pin will then be set for this many seconds\nat the completion of the tool search and at the same time the reverse duty/cycle\nvelocity value will be sent to the motor-vel pin.\n");
MODULE_INFO(linuxcnc, "pin:pocket-number:s32:0:in:The pocket to move to when the .enable pin goes high. If the value\npassed is higher than the number of pockets specified in the \"pockets\" modparam then modulo arithmetic\nis used. This is intended to allow the use of multiple tools in the same holder, as is sometimes\nuseful with lathes.:None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:Set this pin high to start movement. Setting it low will stop movement:None:None");
MODULE_INFO(linuxcnc, "pin:active:bit:0:out:indicates that the component is active:None:None");
MODULE_INFO(linuxcnc, "pin:ready:bit:0:out:This pin goes high when the carousel is in-position:None:None");
MODULE_INFO(linuxcnc, "pin:strobe:bit:0:in:Use this pin to indicate that the position feedback is valid. Often\nprovided by binary encoders:1:None");
MODULE_INFO(linuxcnc, "pin:parity_:bit:0:in:Some encoders supply a parity bit, if this is connected then the\nparity-error output bit will indicate parity errors:None:None");
MODULE_INFO(linuxcnc, "pin:sense-#:bit:(32, 'personality'):in:Carousel position feedback pins. In 'index' mode there \nwill be only 2 pins. sense-0 is the index and sense-1 is the pocket sensor.:None:None");
MODULE_INFO(linuxcnc, "pin:rev-pulse:float:0:in:The duration in seconds for which a ratchet changer (Boxford, Emco)\nshould pulse the reverse pin to lock the holder:None:None");
MODULE_INFO(linuxcnc, "pin:fwd-dc:float:0:in:Velocity or duty cycle when forwards rotation is desired:None:None");
MODULE_INFO(linuxcnc, "pin:rev-dc:float:0:in:Velocity or duty cycle when reverse rotation is desired:None:None");
MODULE_INFO(linuxcnc, "pin:hold-dc:float:0:in:Duty cycle when carousel is in-position (to hold against stop):None:None");
MODULE_INFO(linuxcnc, "pin:align-dc:float:0:in:Use this pin to set the speed of a slower alignment move once the changer is in position. Such a system almost\ncertainly needs decel-time setting too:None:None");
MODULE_INFO(linuxcnc, "pin:decel-time:float:0:in:Time to wait for carousel to stop before final alignment and position check:None:None");
MODULE_INFO(linuxcnc, "pin:counts:s32:0:in:Connect to the rawcounts of an encoder or a stepgen in 'counts' mode:None:None");
MODULE_INFO(linuxcnc, "pin:scale:s32:0:in:The number of stepgen or encoder counts between successive pockets:100:None");
MODULE_INFO(linuxcnc, "pin:width:s32:0:in:How far each side of the exact scale to signal a new pocket:10:None");
MODULE_INFO(linuxcnc, "pin:home-offset:s32:0:in:The offset (in counts) between the index and pocket 1:0:None");
MODULE_INFO(linuxcnc, "pin:index-enable:bit:0:io:Used to home to an encoder index:None:None");
MODULE_INFO(linuxcnc, "pin:jog-fwd:bit:0:in:Jog the carousel forwards one tool position:None:None");
MODULE_INFO(linuxcnc, "pin:jog-rev:bit:0:in:Jog the carousel in reverse (only if dir = 2).\nIt is very important that these pins should be debounced and should probably\nalso be interlocked to only operate when the machine is idle.:None:None");
MODULE_INFO(linuxcnc, "pin:motor-fwd:bit:0:out:Indicates the motor should run forwards (bigger numbers):None:None");
MODULE_INFO(linuxcnc, "pin:motor-rev:bit:0:out:Indicates the motor should run reverse.:None:None");
MODULE_INFO(linuxcnc, "pin:parity-error:bit:0:out:Indicates a parity error:None:None");
MODULE_INFO(linuxcnc, "pin:current-position:s32:0:out:This pin indicates the current position feedback:None:None");
MODULE_INFO(linuxcnc, "pin:motor-vel:float:0:out:The duty-cycle or velocity to drive a DC motor or stepgen:None:None");
MODULE_INFO(linuxcnc, "pin:homed:bit:0:out:Shows that homing is complete. Only used in index and edge modes:0:None");
MODULE_INFO(linuxcnc, "pin:unhome:bit:0:in:Should only really be necessary for testing:0:None");
MODULE_INFO(linuxcnc, "pin:counts-target:float:0:out:Target position for a stepgen or external PID controller:None:None");
MODULE_INFO(linuxcnc, "param:state:s32:0:r:Current component state:0:None");
MODULE_INFO(linuxcnc, "param:homing:bit:0:r:Shows that homing is in progress. Only used for index mode:0:None");
MODULE_INFO(linuxcnc, "param:timer:float:0:r:Shows the value of the internal timer:None:None");
MODULE_INFO(linuxcnc, "param:motor-dir:s32:0:r:Internal tag for search direction:None:None");
MODULE_INFO(linuxcnc, "param:counts-offset:s32:0:r:Internal offset of index pin:None:None");
MODULE_INFO(linuxcnc, "param:debounce:u32:0:rw:How many thread cycles to wait for the position to stabilise:None:None");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Andy Pugh");
MODULE_INFO(linuxcnc, "param:base_counts:s32:0:r::0:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_s32_t *pocket_number_p;
    hal_bit_t *enable_p;
    hal_bit_t *active_p;
    hal_bit_t *ready_p;
    hal_bit_t *strobe_p;
    hal_bit_t *parity__p;
    hal_bit_t *sense_p[32];
    hal_float_t *rev_pulse_p;
    hal_float_t *fwd_dc_p;
    hal_float_t *rev_dc_p;
    hal_float_t *hold_dc_p;
    hal_float_t *align_dc_p;
    hal_float_t *decel_time_p;
    hal_s32_t *counts_p;
    hal_s32_t *scale_p;
    hal_s32_t *width_p;
    hal_s32_t *home_offset_p;
    hal_bit_t *index_enable_p;
    hal_bit_t *jog_fwd_p;
    hal_bit_t *jog_rev_p;
    hal_bit_t *motor_fwd_p;
    hal_bit_t *motor_rev_p;
    hal_bit_t *parity_error_p;
    hal_s32_t *current_position_p;
    hal_float_t *motor_vel_p;
    hal_bit_t *homed_p;
    hal_bit_t *unhome_p;
    hal_float_t *counts_target_p;
    hal_s32_t state_p;
    hal_bit_t homing_p;
    hal_float_t timer_p;
    hal_s32_t motor_dir_p;
    hal_s32_t counts_offset_p;
    hal_u32_t debounce_p;
    hal_s32_t base_counts_p;
    int inst_sense_p;

    int inst_dir_p;

    int inst_pockets_p;

    int inst_code_p;

    int inst_parity_p;

    int old_index_p;

    int target_p;

    int old_unhome_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    personality = inst->_personality;
    r = hal_pin_s32_newf(HAL_IN, &(inst->pocket_number_p), comp_id,
        "%s.pocket-number", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable_p), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->active_p), comp_id,
        "%s.active", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->ready_p), comp_id,
        "%s.ready", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->strobe_p), comp_id,
        "%s.strobe", prefix);
    if(r != 0) return r;
    *(inst->strobe_p) = 1;
    r = hal_pin_bit_newf(HAL_IN, &(inst->parity__p), comp_id,
        "%s.parity", prefix);
    if(r != 0) return r;
    if((personality) > (32)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin sense-#: Requested size %d exceeds max size %d\n",(int)personality, (int)32);
        return -ENOSPC;
    }
    for(j=0; j < (personality); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->sense_p[j]), comp_id,
            "%s.sense-%01d", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_float_newf(HAL_IN, &(inst->rev_pulse_p), comp_id,
        "%s.rev-pulse", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->fwd_dc_p), comp_id,
        "%s.fwd-dc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->rev_dc_p), comp_id,
        "%s.rev-dc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->hold_dc_p), comp_id,
        "%s.hold-dc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->align_dc_p), comp_id,
        "%s.align-dc", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->decel_time_p), comp_id,
        "%s.decel-time", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->counts_p), comp_id,
        "%s.counts", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->scale_p), comp_id,
        "%s.scale", prefix);
    if(r != 0) return r;
    *(inst->scale_p) = 100;
    r = hal_pin_s32_newf(HAL_IN, &(inst->width_p), comp_id,
        "%s.width", prefix);
    if(r != 0) return r;
    *(inst->width_p) = 10;
    r = hal_pin_s32_newf(HAL_IN, &(inst->home_offset_p), comp_id,
        "%s.home-offset", prefix);
    if(r != 0) return r;
    *(inst->home_offset_p) = 0;
    r = hal_pin_bit_newf(HAL_IO, &(inst->index_enable_p), comp_id,
        "%s.index-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->jog_fwd_p), comp_id,
        "%s.jog-fwd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->jog_rev_p), comp_id,
        "%s.jog-rev", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->motor_fwd_p), comp_id,
        "%s.motor-fwd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->motor_rev_p), comp_id,
        "%s.motor-rev", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->parity_error_p), comp_id,
        "%s.parity-error", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->current_position_p), comp_id,
        "%s.current-position", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->motor_vel_p), comp_id,
        "%s.motor-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->homed_p), comp_id,
        "%s.homed", prefix);
    if(r != 0) return r;
    *(inst->homed_p) = 0;
    r = hal_pin_bit_newf(HAL_IN, &(inst->unhome_p), comp_id,
        "%s.unhome", prefix);
    if(r != 0) return r;
    *(inst->unhome_p) = 0;
    r = hal_pin_float_newf(HAL_OUT, &(inst->counts_target_p), comp_id,
        "%s.counts-target", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->state_p), comp_id,
        "%s.state", prefix);
    inst->state_p = 0;
    if(r != 0) return r;
    r = hal_param_bit_newf(HAL_RO, &(inst->homing_p), comp_id,
        "%s.homing", prefix);
    inst->homing_p = 0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RO, &(inst->timer_p), comp_id,
        "%s.timer", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->motor_dir_p), comp_id,
        "%s.motor-dir", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->counts_offset_p), comp_id,
        "%s.counts-offset", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->debounce_p), comp_id,
        "%s.debounce", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->base_counts_p), comp_id,
        "%s.base-counts", prefix);
    inst->base_counts_p = 0;
    if(r != 0) return r;
    inst->old_index_p = 0.0;
    inst->old_unhome_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int get_count(void);
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each carousel");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    int count = get_count();
    comp_id = hal_init("carousel");
    if(comp_id < 0) return comp_id;
    for(i=0; i<count; i++) {
        char buf[HAL_NAME_LEN + 1];
        rtapi_snprintf(buf, sizeof(buf), "carousel.%d", i);
        r = export(buf, i, p_value("carousel", buf, i) );
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef pocket_number
#undef pocket_number_ptr
#define pocket_number_ptr (__comp_inst->pocket_number_p)
#define pocket_number (0+*__comp_inst->pocket_number_p)
#undef enable
#undef enable_ptr
#define enable_ptr (__comp_inst->enable_p)
#define enable (0+*__comp_inst->enable_p)
#undef active
#undef active_ptr
#define active_ptr (__comp_inst->active_p)
#define active (*__comp_inst->active_p)
#undef ready
#undef ready_ptr
#define ready_ptr (__comp_inst->ready_p)
#define ready (*__comp_inst->ready_p)
#undef strobe
#undef strobe_ptr
#define strobe_ptr (__comp_inst->strobe_p)
#define strobe (0+*__comp_inst->strobe_p)
#undef parity_
#undef parity__ptr
#define parity__ptr (__comp_inst->parity__p)
#define parity_ (0+*__comp_inst->parity__p)
#undef sense
#undef sense_ptr
#define sense_ptr(i) (__comp_inst->sense_p[i])
#define sense(i) (0+*(__comp_inst->sense_p[i]))
#undef rev_pulse
#undef rev_pulse_ptr
#define rev_pulse_ptr (__comp_inst->rev_pulse_p)
#define rev_pulse (0+*__comp_inst->rev_pulse_p)
#undef fwd_dc
#undef fwd_dc_ptr
#define fwd_dc_ptr (__comp_inst->fwd_dc_p)
#define fwd_dc (0+*__comp_inst->fwd_dc_p)
#undef rev_dc
#undef rev_dc_ptr
#define rev_dc_ptr (__comp_inst->rev_dc_p)
#define rev_dc (0+*__comp_inst->rev_dc_p)
#undef hold_dc
#undef hold_dc_ptr
#define hold_dc_ptr (__comp_inst->hold_dc_p)
#define hold_dc (0+*__comp_inst->hold_dc_p)
#undef align_dc
#undef align_dc_ptr
#define align_dc_ptr (__comp_inst->align_dc_p)
#define align_dc (0+*__comp_inst->align_dc_p)
#undef decel_time
#undef decel_time_ptr
#define decel_time_ptr (__comp_inst->decel_time_p)
#define decel_time (0+*__comp_inst->decel_time_p)
#undef counts
#undef counts_ptr
#define counts_ptr (__comp_inst->counts_p)
#define counts (0+*__comp_inst->counts_p)
#undef scale
#undef scale_ptr
#define scale_ptr (__comp_inst->scale_p)
#define scale (0+*__comp_inst->scale_p)
#undef width
#undef width_ptr
#define width_ptr (__comp_inst->width_p)
#define width (0+*__comp_inst->width_p)
#undef home_offset
#undef home_offset_ptr
#define home_offset_ptr (__comp_inst->home_offset_p)
#define home_offset (0+*__comp_inst->home_offset_p)
#undef index_enable
#undef index_enable_ptr
#define index_enable_ptr (__comp_inst->index_enable_p)
#define index_enable (*__comp_inst->index_enable_p)
#undef jog_fwd
#undef jog_fwd_ptr
#define jog_fwd_ptr (__comp_inst->jog_fwd_p)
#define jog_fwd (0+*__comp_inst->jog_fwd_p)
#undef jog_rev
#undef jog_rev_ptr
#define jog_rev_ptr (__comp_inst->jog_rev_p)
#define jog_rev (0+*__comp_inst->jog_rev_p)
#undef motor_fwd
#undef motor_fwd_ptr
#define motor_fwd_ptr (__comp_inst->motor_fwd_p)
#define motor_fwd (*__comp_inst->motor_fwd_p)
#undef motor_rev
#undef motor_rev_ptr
#define motor_rev_ptr (__comp_inst->motor_rev_p)
#define motor_rev (*__comp_inst->motor_rev_p)
#undef parity_error
#undef parity_error_ptr
#define parity_error_ptr (__comp_inst->parity_error_p)
#define parity_error (*__comp_inst->parity_error_p)
#undef current_position
#undef current_position_ptr
#define current_position_ptr (__comp_inst->current_position_p)
#define current_position (*__comp_inst->current_position_p)
#undef motor_vel
#undef motor_vel_ptr
#define motor_vel_ptr (__comp_inst->motor_vel_p)
#define motor_vel (*__comp_inst->motor_vel_p)
#undef homed
#undef homed_ptr
#define homed_ptr (__comp_inst->homed_p)
#define homed (*__comp_inst->homed_p)
#undef unhome
#undef unhome_ptr
#define unhome_ptr (__comp_inst->unhome_p)
#define unhome (0+*__comp_inst->unhome_p)
#undef counts_target
#undef counts_target_ptr
#define counts_target_ptr (__comp_inst->counts_target_p)
#define counts_target (*__comp_inst->counts_target_p)
#undef state
#define state (__comp_inst->state_p)
#undef homing
#define homing (__comp_inst->homing_p)
#undef timer
#define timer (__comp_inst->timer_p)
#undef motor_dir
#define motor_dir (__comp_inst->motor_dir_p)
#undef counts_offset
#define counts_offset (__comp_inst->counts_offset_p)
#undef debounce
#define debounce (__comp_inst->debounce_p)
#undef base_counts
#define base_counts (__comp_inst->base_counts_p)
#undef inst_sense
#define inst_sense (__comp_inst->inst_sense_p)
#undef inst_dir
#define inst_dir (__comp_inst->inst_dir_p)
#undef inst_pockets
#define inst_pockets (__comp_inst->inst_pockets_p)
#undef inst_code
#define inst_code (__comp_inst->inst_code_p)
#undef inst_parity
#define inst_parity (__comp_inst->inst_parity_p)
#undef old_index
#define old_index (__comp_inst->old_index_p)
#undef target
#define target (__comp_inst->target_p)
#undef old_unhome
#define old_unhome (__comp_inst->old_unhome_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 171 "/home/end/projects/linuxcnc/src/hal/components/carousel.comp"

int default_pockets = 8;
int default_code = 'G';
int default_dir = 2;
int default_sense = 4;
int default_parity = 0;

static bool err_once = 0;

#define MAX_CHAN 8
static int pockets[MAX_CHAN] = {-1};
RTAPI_MP_ARRAY_INT(pockets, MAX_CHAN, "The number of pockets in each carousel")
static char *encoding[MAX_CHAN];
RTAPI_MP_ARRAY_STRING(encoding, MAX_CHAN, "Position feedback type")
static int dir[MAX_CHAN] = {-1};
RTAPI_MP_ARRAY_INT(dir, MAX_CHAN, 
                    "set to 2 if the carousel is bidirectional")
static int num_sense[MAX_CHAN] = {-1};
RTAPI_MP_ARRAY_INT(num_sense, MAX_CHAN, "The number of sense pins to create")
// We have a hal pin and a modparam with the same name. From the user
// point of view I think that makes sense. In the code parity[] is the modparam,
// parity_ is the hal pin.
static int parity[MAX_CHAN] = {-1};
RTAPI_MP_ARRAY_INT(parity, MAX_CHAN, "0 for even parity, 1 for odd")

FUNCTION(_){
    int i, d, pow;
    static int deb = 0;
    int pcalc = 0;
    int mod_pocket = 0;
    int new_pos = 0;
    unsigned int mask;
    int align_pin = 0; // used for slow align move, input depends on mode for historical reasons

    switch inst_code{
    case 'G': // Gray Code
        align_pin = strobe;
        for (i = 0; i < inst_sense ; i++) {
            new_pos += sense(i) << i;
        pcalc ^= sense(i);
        }
        for(mask = new_pos >> 1 ; mask != 0 ; mask = mask >> 1){
            new_pos ^= mask;
        }
        if (new_pos == 0) new_pos = inst_pockets; // all zeros != pocket zero
        break;
    case 'B': // Straight Binary
        align_pin = strobe;
        for (i = 0; i < inst_sense ; i++) {
            new_pos += sense(i) << i;
        pcalc ^= sense(i);
        }
        break;
    case 'D': // BCD
        align_pin = strobe;
        i = 0;
        pow = 1;
        while (i < inst_sense){
            int lim;
            d = 0;
            for (lim = i + 4; i < lim && i < inst_sense; i++) {
                d += sense(i) << (i % 4);
                pcalc ^= sense(i);
            }
            new_pos += d * pow;
            pow *= 10;
        }
        break;
    case 'S': // individual sensors
        for (i = inst_sense - 1; sense(i) == 0 && i > 0 ; i--) {}
        if (sense(i)) {
            new_pos = i + 1;
        }
        align_pin = sense(current_position - 1);
        break;
    case 'I': // index + position.
        align_pin = sense(1);
        new_pos = current_position;
        if (homed && (state == 2 || state == 20)){ // Ignore transitions during home, align etc
            if ( !old_index && sense(1) ){
                if (motor_fwd){
                    new_pos += 1;
                    if (new_pos > inst_pockets) new_pos -= inst_pockets;
                }
                if (motor_rev) {
                    new_pos -= 1;
                    if (new_pos < 1) new_pos += inst_pockets;
                }
            }
            old_index = sense(1);
        }
        break;
    case 'E': // index + position, both edges.
        align_pin = ! align_pin; // Not supported, but wiggle the pin to escape
        new_pos = current_position;
        if (homed){
            if ( old_index != sense(1) ){
                if (motor_fwd){
                    new_pos += 1;
                    if (new_pos > inst_pockets) new_pos -= inst_pockets;
                }
                if (motor_rev) {
                    new_pos -= 1;
                    if (new_pos < 1) new_pos += inst_pockets;
                }
            }
            old_index = sense(1);
        }
        break;
    case 'C': // encoder or stepgen counts.
        new_pos = current_position;
        if (homed){
            int c;
            int t;
            int w = width / 2;
            c = (counts - base_counts);
            t = floor(((float)c + w) / scale);
            if (c >= (t * scale - w)  && c <= (t * scale + w)) {
                new_pos = 1 + (t % inst_pockets);
                // C modulus of negative numbers is inconvenient
                if (new_pos < 1) new_pos += inst_pockets;
            }
            align_pin = (c % scale <= 2 && c % scale >= -2); // don't try to align to an exact count.
        }
    }

    if (strobe) {
        current_position = new_pos;
        parity_error = (pcalc != (inst_parity ^ parity_));
    }
    mod_pocket = ((pocket_number - 1) % inst_pockets) + 1;
    // mod is odd with negatives, so just in case
    if (mod_pocket < 1) mod_pocket = 1;
    if (mod_pocket > inst_pockets) mod_pocket = inst_pockets;

    if (unhome && ! old_unhome) homed = 0;
    old_unhome = unhome;

    switch (state){
    case 0: // waiting at start
        motor_dir = 0;
        if (jog_fwd || (jog_rev && inst_dir == 2))  {
            if ((inst_code == 'I' || inst_code == 'E' || inst_code == 'C') && ! homed){
                state = 10;
                break;
            }
            target = current_position + jog_fwd - jog_rev;
            if (target > inst_pockets ) target = 1;
            if (target < 1) target = inst_pockets;
            if (jog_fwd){
                motor_fwd = 1;
                motor_rev = 0;
                motor_vel = fwd_dc;
                motor_dir = 1;
            }
            if (jog_rev){
                motor_fwd = 0;
                motor_rev = 1;
                motor_vel = rev_dc;
                motor_dir = -1;
            }
            active = 1;
            state = 20;
            break;
        }
        motor_vel = hold_dc;
        if (! enable) return ;
        active = 1;
        if ((inst_code == 'I' || inst_code == 'E' || inst_code == 'C') && ! homed){
            state = 10;
            break;
        }
        state = 1;
        ready = 0;
    case 1: // choose direction
        if (mod_pocket < 1 || mod_pocket > inst_pockets) {
            state = 0;
            return;
        }
        if (inst_dir == 2){
            if (current_position < mod_pocket){
                if (mod_pocket - current_position > (inst_pockets / 2)) {
                    motor_fwd = 0;
                    motor_rev = 1;
                    motor_vel = rev_dc;
                    motor_dir = -1;
                    counts_target += (mod_pocket - current_position - inst_pockets) * scale;
                } else {
                    motor_fwd = 1;
                    motor_rev = 0;
                    motor_vel = fwd_dc;
                    motor_dir = 1;
                    counts_target += (mod_pocket - current_position ) * scale;
                }
            } else {
                if (current_position - mod_pocket > (inst_pockets / 2)) {
                    motor_fwd = 1;
                    motor_rev = 0;
                    motor_vel = fwd_dc;
                    motor_dir = 1;
                    counts_target += (mod_pocket - current_position + inst_pockets) * scale;
                } else {
                    motor_fwd = 0;
                    motor_rev = 1;
                    motor_vel = rev_dc;
                    motor_dir = -1;
                    counts_target += (mod_pocket - current_position) * scale;
                }
            }
        } else {
            counts_target += (mod_pocket - current_position) * scale;
            if (counts_target < counts ) {
                counts_target += scale * inst_pockets;
            }
            motor_fwd = 1;
            motor_rev = 0;
            motor_vel = fwd_dc;
            motor_dir = 1;
        }
        state = 2;
    case 2: // moving
        if ((current_position != mod_pocket) && enable){
            deb = debounce;
            return;
        } else if (deb-- > 0) {
            return;
        }
        if (rev_pulse > 0){
            motor_fwd = 0;
            motor_rev = 1;
            motor_vel = rev_dc;
            timer = rev_pulse;        
            state = 3;
        } else if (decel_time > 0) {
            // stop and prepare for alignment
            motor_vel = 0;
            timer = decel_time;
            state = 5;
        } else {
            motor_fwd = 0;
            motor_rev = 0;
            motor_vel = hold_dc;
            active = 0;
            if (enable && current_position == mod_pocket) ready = 1;
            state = 9;
        }
        break;
    case 3: // timed reverse pulse
        timer -= fperiod;
        if (timer > 0) return;
        state = 9;
        motor_fwd = 0;
        motor_rev = 0;
        motor_vel = hold_dc;
        active = 0;
        if (enable) ready = 1;
        break;
    case 5: //Waiting for carousel to stop
        timer -= fperiod;
        if (timer > 0) return;
        if (align_dc == 0){
            state = 8;
            break;
        }
        motor_vel = -align_dc;
        if (motor_dir == 1) {
            state = 6;
        } else {
            state = 7;
        }
        break;
    case 6: //backing up to index
        if ( align_pin == 0 ) return;
        state = 7;
        break;
    case 7: //backing back off of index
        if ( align_pin != 0 ) return;
        motor_vel = align_dc;
        state = 8;
        break;
    case 8: // final move back to index
        if ( align_pin == 0 ) return;
        motor_fwd = 0;
        motor_rev = 0;
        motor_vel = hold_dc;
        active = 0;
        // final safety check for in-position
        if (enable && current_position == mod_pocket) ready = 1;
        state = 9;
        break;
    case 9: //waiting for enable to go false
        if (! ready && ! err_once){
            rtapi_print_msg(RTAPI_MSG_ERR, "The toolchanger has failed the final alignment check");
            err_once = 1;
        }
        if (enable) return;
        err_once = 0;
        state = 0;
        break;
    case 10: // start of homing
        homed = 0;
        homing = 1;
        motor_fwd = 1;
        motor_rev = 0;
        motor_vel = fwd_dc;
        motor_dir = 1;
        index_enable = 1;
        counts_target += scale * inst_pockets;
        old_index = 1; // ensure 0->1 cycle of home sensor
        state = 11;
    case 11: ;// waiting for index & pulse
        int ind = 0;
        if (inst_code == 'C'){
            ind = sense(0);
        } else {
            ind = (sense(0) && sense(1));
        }
        if  ( ! index_enable || ((! old_index) && ind)){ // index found
            current_position = 1;
            homed = 1;
            homing = 0;
            active = 0;
            motor_fwd = 0;
            motor_rev = 0;
            motor_vel = 0;
            base_counts = counts - home_offset;
            counts_target = base_counts;
            if ( align_dc == 0) {
                state = 0;
            } else { 
                timer = decel_time;
                state = 5;
            }
        }
        old_index = ind;
        break; // So that we don't see the tool1 pulse twice
    case 20: //jogging fwd/rev
        if (current_position != target){
            deb = debounce;
            return;
        } else if (deb-- > 0) {
            return;
        }
        if (align_dc != 0 && ! align_pin) return;
        motor_fwd = 0;
        motor_rev = 0;
        motor_vel = hold_dc;
        active = 0;
        if (jog_fwd || jog_rev) return; // require button release to jog again
        if (align_dc != 0) {
            motor_vel = -align_dc;
            timer = decel_time;
            state = 5;
        } else {
            state = 0;
        }
        break;
    }
}

EXTRA_SETUP(){
    if (pockets[extra_arg] > 0) default_pockets = pockets[extra_arg];
    if (encoding[extra_arg] == NULL) {
        //it's already default_code
    } else if (strncmp(encoding[extra_arg], "gray", 4) == 0) {
        default_code = 'G';
    } else if (strncmp(encoding[extra_arg], "binary", 6) == 0) {
        default_code = 'B';
    } else if (strncmp(encoding[extra_arg], "bcd", 3) == 0) {
        default_code = 'D';
    } else if (strncmp(encoding[extra_arg], "single", 6) == 0) {
        default_code = 'S';
    } else if (strncmp(encoding[extra_arg], "index", 5) == 0) {
        default_code = 'I';
    } else if (strncmp(encoding[extra_arg], "edge", 4) == 0) {
        default_code = 'E';
    } else if (strncmp(encoding[extra_arg], "counts", 6) == 0) {
        default_code = 'C';
    }

    if (dir[extra_arg] > 0)  default_dir = (dir[extra_arg] > 1)? 2:1;

    if (parity[extra_arg] != -1) default_parity = parity[extra_arg];
    
    if (default_code == 'I') {
        default_sense = 2;
    } else if (num_sense[extra_arg] > 0 ) {
        default_sense = num_sense[extra_arg];
    }
    
    inst_pockets = default_pockets;
    inst_code = default_code;
    inst_dir = default_dir;
    inst_sense = default_sense;
    inst_parity = default_parity;

    if (inst_code == 'S' && inst_sense < inst_pockets) inst_sense = inst_pockets;
    personality = inst_sense;

    return 0;
}

int get_count(void){
    int i;
    for (i = 0; pockets[i] != 0 && i < MAX_CHAN; i++){}
    if (i == 0) return 1 ;
    return i;
}

static int __comp_get_data_size(void) { return 0; }
