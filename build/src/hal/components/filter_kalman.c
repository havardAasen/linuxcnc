/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:filter_kalman:Unidimensional Kalman filter, also known as linear quadratic estimation (LQE)");
MODULE_INFO(linuxcnc, "license:GPL-2.0-or-later");
MODULE_INFO(linuxcnc, "author:Dmian Wrobel <dwrobel@ertelnet.rybnik.pl>");
MODULE_INFO(linuxcnc, "descr:\nUseful for reducing input signal noise (e.g. from the voltage or temperature sensor).\n\nMore information can be found at https://en.wikipedia.org/wiki/Kalman_filter.\n\nAdjusting \\fBQr\\fR and \\fBQk\\fR covariances:\n\nDefault values of \\fBRk\\fR and \\fBQk\\fR are given for informational purpose only. The nature of the\nfilter requires the parameters to be individually computed.\n\nOne of the possible and quite practical method (probably far from being the best) of\nestimating the \\fBRk\\fR covariance is to collect the raw data from the sensor by\neither asserting the \\fBdebug\\fR pin or using \\fBhalscope\\fR and then compute the covariance\nusing \\fBcov()\\fR function from \\fBOctave\\fR package. Ready to use script can be found at\nhttps://github.com/dwrobel/TrivialKalmanFilter/blob/master/examples/DS18B20Test/covariance.m.\n\nAdjusting \\fBQk\\fR covariance mostly depends on the required response time of the filter.\nThere is a relationship between \\fBQk\\fR and response time of the filter that the lower\nthe \\fBQk\\fR covariance is the slower the response of the filter is.\n\nCommon practice is also to conservatively set \\fBRk\\fR and \\fBQk\\fR slightly larger then computed\nones to get robustness.\n");
MODULE_INFO(linuxcnc, "pin:debug:bit:0:in:When asserted, prints out measured and estimated values.:FALSE:None");
MODULE_INFO(linuxcnc, "pin:passthrough:bit:0:in:When asserted, copies measured value into estimated value.:FALSE:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in:When asserted, resets filter to its initial state and returns 0 as an estimated value (\\fBreset\\fR pin\nhas higher priority than \\fBpassthrough\\fR pin).:FALSE:None");
MODULE_INFO(linuxcnc, "pin:zk:float:0:in:Measured value.:None:None");
MODULE_INFO(linuxcnc, "pin:xk_out:float:0:out:Estimated value.:None:None");
MODULE_INFO(linuxcnc, "param:Rk:float:0:rw:Estimation of the noise covariances (process).:1.17549e-38:None");
MODULE_INFO(linuxcnc, "param:Qk:float:0:rw:Estimation of the noise covariances (observation).:1.17549e-38:None");
MODULE_INFO(linuxcnc, "funct:_:1:Update \\fBxk-out\\fR based on \\fBzk\\fR input.");
MODULE_LICENSE("GPL-2.0-or-later");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *debug_p;
    hal_bit_t *passthrough_p;
    hal_bit_t *reset_p;
    hal_float_t *zk_p;
    hal_float_t *xk_out_p;
    hal_float_t Rk_p;
    hal_float_t Qk_p;
    float xk_last_p;

    float Pk_last_p;

    bool initialized_p;

    int cidx_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->debug_p), comp_id,
        "%s.debug", prefix);
    if(r != 0) return r;
    *(inst->debug_p) = FALSE;
    r = hal_pin_bit_newf(HAL_IN, &(inst->passthrough_p), comp_id,
        "%s.passthrough", prefix);
    if(r != 0) return r;
    *(inst->passthrough_p) = FALSE;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset_p), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    *(inst->reset_p) = FALSE;
    r = hal_pin_float_newf(HAL_IN, &(inst->zk_p), comp_id,
        "%s.zk", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->xk_out_p), comp_id,
        "%s.xk-out", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->Rk_p), comp_id,
        "%s.Rk", prefix);
    inst->Rk_p = 1.17549e-38;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->Qk_p), comp_id,
        "%s.Qk", prefix);
    inst->Qk_p = 1.17549e-38;
    if(r != 0) return r;
    inst->initialized_p = 0;
    inst->cidx_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of filter_kalman");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of filter_kalman");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("filter_kalman");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "filter-kalman.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef debug
#undef debug_ptr
#define debug_ptr (__comp_inst->debug_p)
#define debug (0+*__comp_inst->debug_p)
#undef passthrough
#undef passthrough_ptr
#define passthrough_ptr (__comp_inst->passthrough_p)
#define passthrough (0+*__comp_inst->passthrough_p)
#undef reset
#undef reset_ptr
#define reset_ptr (__comp_inst->reset_p)
#define reset (0+*__comp_inst->reset_p)
#undef zk
#undef zk_ptr
#define zk_ptr (__comp_inst->zk_p)
#define zk (0+*__comp_inst->zk_p)
#undef xk_out
#undef xk_out_ptr
#define xk_out_ptr (__comp_inst->xk_out_p)
#define xk_out (*__comp_inst->xk_out_p)
#undef Rk
#define Rk (__comp_inst->Rk_p)
#undef Qk
#define Qk (__comp_inst->Qk_p)
#undef xk_last
#define xk_last (__comp_inst->xk_last_p)
#undef Pk_last
#define Pk_last (__comp_inst->Pk_last_p)
#undef initialized
#define initialized (__comp_inst->initialized_p)
#undef cidx
#define cidx (__comp_inst->cidx_p)


#line 68 "/home/end/projects/linuxcnc/src/hal/components/filter_kalman.comp"
#include <rtapi_math.h>

typedef hal_float_t D; // to Keep code synchronized with C++ based TrivialKalmanFilter implementation.

// Based on: https://github.com/dwrobel/TrivialKalmanFilter/blob/master/src/TrivialKalmanFilter.h
// Assumes simplified model
static const D k    = 1;
static const D Bk   = 0;
static const D uk   = 0;
static const D Fk   = 1;
static const D T    = 1;
static const D Fk_T = 1; // pow(Fk, T);
static const D Hk   = 1;
static const D Hk_T = 1; // pow(Hk, T);
static const D I    = 1;

static void print_info(const int id, const D in_val, const D out_val) {
    // TODO: add support for using component names when they will be more easily available.
    rtapi_print_msg(RTAPI_MSG_ERR, "filter-kalman.%d %f %f\n", id, in_val, out_val);
}

EXTRA_SETUP() {
    cidx = extra_arg; // Let us hope 'extra_arg' will forever contain component index.
    return 0;
}

FUNCTION(_) {
    if (reset || !initialized) {
        xk_last      = 0;
        Pk_last      = 1;

        initialized = TRUE;

        if (reset) {
            xk_out = 0;

            if (debug) {
                print_info(cidx, zk, xk_out);
            }

            return;
        }
    }

    if (passthrough) {
        xk_out = zk;

        if (debug) {
            print_info(cidx, zk, xk_out);
        }

        return;
    }

    {
        D xk       = (Fk * xk_last) + (Bk * uk); // Predicted (a priori) state estimate
        D Pk       = (Fk * Pk_last * Fk_T) + Qk; // Predicted (a priori) error covariance
        D yk       = zk - (Hk * xk);             // Innovation or measurement pre-fit residual
        const D Sk = Rk + (Hk * Pk * Hk_T);      // Innovation (or pre-fit residual) covariance
        const D Kk = (Pk * Hk_T) / Sk;           // Optimal Kalman gain
        xk         = xk + (Kk * yk);             // Updated (a posteriori) state estimate
        Pk         = (I - (Kk * Hk)) * Pk;       // Updated (a posteriori) estimate covariance (a.k.a Joseph form)

#       if 0                                     // unused part
            yk     = zk - (Hk_T * xk);           // Measurement post-fit residual
#       endif

        xk_last    = xk;
        Pk_last    = Pk;
        xk_out     = xk;

        if (debug) {
            print_info(cidx, zk, xk_out);
        }
    }
}

static int __comp_get_data_size(void) { return 0; }
