/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:multiclick:Single-, double-, triple-, and quadruple-click detector");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Sebastian Kuzminsky");
MODULE_INFO(linuxcnc, "pin:in:bit:0:in:The input line, this is where we look for clicks.:None:None");
MODULE_INFO(linuxcnc, "pin:single_click:bit:0:out:Goes high briefly when a single-click is detected on the 'in' pin.:None:None");
MODULE_INFO(linuxcnc, "pin:single_click_only:bit:0:out:Goes high briefly when a single-click is detected on the 'in' pin\nand no second click followed it.:None:None");
MODULE_INFO(linuxcnc, "pin:double_click:bit:0:out:Goes high briefly when a double-click is detected on the 'in' pin.:None:None");
MODULE_INFO(linuxcnc, "pin:double_click_only:bit:0:out:Goes high briefly when a double-click is detected on the 'in' pin\nand no third click followed it.:None:None");
MODULE_INFO(linuxcnc, "pin:triple_click:bit:0:out:Goes high briefly when a triple-click is detected on the 'in' pin.:None:None");
MODULE_INFO(linuxcnc, "pin:triple_click_only:bit:0:out:Goes high briefly when a triple-click is detected on the 'in' pin\nand no fourth click followed it.:None:None");
MODULE_INFO(linuxcnc, "pin:quadruple_click:bit:0:out:Goes high briefly when a quadruple-click is detected on the 'in' pin.:None:None");
MODULE_INFO(linuxcnc, "pin:quadruple_click_only:bit:0:out:Goes high briefly when a quadruple-click is detected on the 'in'\npin and no fifth click followed it.:None:None");
MODULE_INFO(linuxcnc, "pin:state:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "param:invert_input:bit:0:rw:If FALSE (the default), clicks start with rising edges.  If TRUE,\nclicks start with falling edges.:FALSE:None");
MODULE_INFO(linuxcnc, "param:max_hold_ns:u32:0:rw:If the input is held down longer than this, it's not part of a\nmulti-click.  (Default 250,000,000 ns, 250 ms.):250000000:None");
MODULE_INFO(linuxcnc, "param:max_space_ns:u32:0:rw:If the input is released longer than this, it's not part of a\nmulti-click.  (Default 250,000,000 ns, 250 ms.):250000000:None");
MODULE_INFO(linuxcnc, "param:output_hold_ns:u32:0:rw:Positive pulses on the output pins last this long.  (Default\n100,000,000 ns, 100 ms.):100000000:None");
MODULE_INFO(linuxcnc, "descr:A click is defined as a rising edge on the 'in' pin,\nfollowed by the 'in' pin being True for at most 'max-hold-ns' nanoseconds,\nfollowed by a falling edge.\n\nA double-click is defined as two clicks, separated by at\nmost 'max-space-ns' nanoseconds with the 'in' pin in the False state.\n\nI bet you can guess the definition of triple- and quadruple-click.\n\nYou probably want to run the input signal through a debounce component\nbefore feeding it to the multiclick detector, if the input is at all\nnoisy.\n\nThe '*-click' pins go high as soon as the input detects the correct\nnumber of clicks.\n\nThe '*-click-only' pins go high a short while after the click, after\nthe click separator space timeout has expired to show that no further\nclick is coming.  This is useful for triggering halui MDI commands.");
MODULE_INFO(linuxcnc, "funct:_:0:Detect single-, double-, triple-, and quadruple-clicks");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *in_p;
    hal_bit_t *single_click_p;
    hal_bit_t *single_click_only_p;
    hal_bit_t *double_click_p;
    hal_bit_t *double_click_only_p;
    hal_bit_t *triple_click_p;
    hal_bit_t *triple_click_only_p;
    hal_bit_t *quadruple_click_p;
    hal_bit_t *quadruple_click_only_p;
    hal_s32_t *state_p;
    hal_bit_t invert_input_p;
    hal_u32_t max_hold_ns_p;
    hal_u32_t max_space_ns_p;
    hal_u32_t output_hold_ns_p;
    int click_state_p;

    unsigned timer_p;

    unsigned timeout_p;

    unsigned single_click_hold_timer_p;

    unsigned single_click_only_hold_timer_p;

    unsigned double_click_hold_timer_p;

    unsigned double_click_only_hold_timer_p;

    unsigned triple_click_hold_timer_p;

    unsigned triple_click_only_hold_timer_p;

    unsigned quadruple_click_hold_timer_p;

    unsigned quadruple_click_only_hold_timer_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_p), comp_id,
        "%s.in", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->single_click_p), comp_id,
        "%s.single-click", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->single_click_only_p), comp_id,
        "%s.single-click-only", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->double_click_p), comp_id,
        "%s.double-click", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->double_click_only_p), comp_id,
        "%s.double-click-only", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->triple_click_p), comp_id,
        "%s.triple-click", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->triple_click_only_p), comp_id,
        "%s.triple-click-only", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->quadruple_click_p), comp_id,
        "%s.quadruple-click", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->quadruple_click_only_p), comp_id,
        "%s.quadruple-click-only", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->state_p), comp_id,
        "%s.state", prefix);
    if(r != 0) return r;
    r = hal_param_bit_newf(HAL_RW, &(inst->invert_input_p), comp_id,
        "%s.invert-input", prefix);
    inst->invert_input_p = FALSE;
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->max_hold_ns_p), comp_id,
        "%s.max-hold-ns", prefix);
    inst->max_hold_ns_p = 250000000;
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->max_space_ns_p), comp_id,
        "%s.max-space-ns", prefix);
    inst->max_space_ns_p = 250000000;
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->output_hold_ns_p), comp_id,
        "%s.output-hold-ns", prefix);
    inst->output_hold_ns_p = 100000000;
    if(r != 0) return r;
    inst->click_state_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 0, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of multiclick");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of multiclick");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("multiclick");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "multiclick.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#undef in_ptr
#define in_ptr (__comp_inst->in_p)
#define in (0+*__comp_inst->in_p)
#undef single_click
#undef single_click_ptr
#define single_click_ptr (__comp_inst->single_click_p)
#define single_click (*__comp_inst->single_click_p)
#undef single_click_only
#undef single_click_only_ptr
#define single_click_only_ptr (__comp_inst->single_click_only_p)
#define single_click_only (*__comp_inst->single_click_only_p)
#undef double_click
#undef double_click_ptr
#define double_click_ptr (__comp_inst->double_click_p)
#define double_click (*__comp_inst->double_click_p)
#undef double_click_only
#undef double_click_only_ptr
#define double_click_only_ptr (__comp_inst->double_click_only_p)
#define double_click_only (*__comp_inst->double_click_only_p)
#undef triple_click
#undef triple_click_ptr
#define triple_click_ptr (__comp_inst->triple_click_p)
#define triple_click (*__comp_inst->triple_click_p)
#undef triple_click_only
#undef triple_click_only_ptr
#define triple_click_only_ptr (__comp_inst->triple_click_only_p)
#define triple_click_only (*__comp_inst->triple_click_only_p)
#undef quadruple_click
#undef quadruple_click_ptr
#define quadruple_click_ptr (__comp_inst->quadruple_click_p)
#define quadruple_click (*__comp_inst->quadruple_click_p)
#undef quadruple_click_only
#undef quadruple_click_only_ptr
#define quadruple_click_only_ptr (__comp_inst->quadruple_click_only_p)
#define quadruple_click_only (*__comp_inst->quadruple_click_only_p)
#undef state
#undef state_ptr
#define state_ptr (__comp_inst->state_p)
#define state (*__comp_inst->state_p)
#undef invert_input
#define invert_input (__comp_inst->invert_input_p)
#undef max_hold_ns
#define max_hold_ns (__comp_inst->max_hold_ns_p)
#undef max_space_ns
#define max_space_ns (__comp_inst->max_space_ns_p)
#undef output_hold_ns
#define output_hold_ns (__comp_inst->output_hold_ns_p)
#undef click_state
#define click_state (__comp_inst->click_state_p)
#undef timer
#define timer (__comp_inst->timer_p)
#undef timeout
#define timeout (__comp_inst->timeout_p)
#undef single_click_hold_timer
#define single_click_hold_timer (__comp_inst->single_click_hold_timer_p)
#undef single_click_only_hold_timer
#define single_click_only_hold_timer (__comp_inst->single_click_only_hold_timer_p)
#undef double_click_hold_timer
#define double_click_hold_timer (__comp_inst->double_click_hold_timer_p)
#undef double_click_only_hold_timer
#define double_click_only_hold_timer (__comp_inst->double_click_only_hold_timer_p)
#undef triple_click_hold_timer
#define triple_click_hold_timer (__comp_inst->triple_click_hold_timer_p)
#undef triple_click_only_hold_timer
#define triple_click_only_hold_timer (__comp_inst->triple_click_only_hold_timer_p)
#undef quadruple_click_hold_timer
#define quadruple_click_hold_timer (__comp_inst->quadruple_click_hold_timer_p)
#undef quadruple_click_only_hold_timer
#define quadruple_click_only_hold_timer (__comp_inst->quadruple_click_only_hold_timer_p)


#line 144 "/home/end/projects/linuxcnc/src/hal/components/multiclick.comp"

typedef enum {
    IDLE = 0,
    SAW_FIRST_RISING_EDGE,
    SAW_FIRST_CLICK,
    SAW_SECOND_RISING_EDGE,
    SAW_SECOND_CLICK,
    SAW_THIRD_RISING_EDGE,
    SAW_THIRD_CLICK,
    SAW_FOURTH_RISING_EDGE,
    SAW_FOURTH_CLICK,
    HELD_TOO_LONG
} state_t;

FUNCTION(_) {
    int new_in = in;

    if (1 == invert_input) {
        new_in = !new_in;
    }

    if (click_state != IDLE) {
        timer += period;
    }


    //
    // update the output pins
    //

    if (single_click_hold_timer > 0) {
        if (single_click_hold_timer > period) {
            single_click_hold_timer -= period;
        } else {
            single_click_hold_timer = 0;
            single_click = 0;
        }
    }

    if (single_click_only_hold_timer > 0) {
        if (single_click_only_hold_timer > period) {
            single_click_only_hold_timer -= period;
        } else {
            single_click_only_hold_timer = 0;
            single_click_only = 0;
        }
    }

    if (double_click_hold_timer > 0) {
        if (double_click_hold_timer > period) {
            double_click_hold_timer -= period;
        } else {
            double_click_hold_timer = 0;
            double_click = 0;
        }
    }

    if (double_click_only_hold_timer > 0) {
        if (double_click_only_hold_timer > period) {
            double_click_only_hold_timer -= period;
        } else {
            double_click_only_hold_timer = 0;
            double_click_only = 0;
        }
    }

    if (triple_click_hold_timer > 0) {
        if (triple_click_hold_timer > period) {
            triple_click_hold_timer -= period;
        } else {
            triple_click_hold_timer = 0;
            triple_click = 0;
        }
    }

    if (triple_click_only_hold_timer > 0) {
        if (triple_click_only_hold_timer > period) {
            triple_click_only_hold_timer -= period;
        } else {
            triple_click_only_hold_timer = 0;
            triple_click_only = 0;
        }
    }

    if (quadruple_click_hold_timer > 0) {
        if (quadruple_click_hold_timer > period) {
            quadruple_click_hold_timer -= period;
        } else {
            quadruple_click_hold_timer = 0;
            quadruple_click = 0;
        }
    }

    if (quadruple_click_only_hold_timer > 0) {
        if (quadruple_click_only_hold_timer > period) {
            quadruple_click_only_hold_timer -= period;
        } else {
            quadruple_click_only_hold_timer = 0;
            quadruple_click_only = 0;
        }
    }


    //
    // update state, if needed
    //

    switch (click_state) {
        case IDLE: {
            if (1 == new_in) {
                click_state = SAW_FIRST_RISING_EDGE;
                timer = 0;
                timeout = max_hold_ns;
            }
            break;
        }

        case SAW_FIRST_RISING_EDGE: {
            if (0 == new_in) {
                click_state = SAW_FIRST_CLICK;
                timer = 0;
                timeout = max_space_ns;
                single_click = 1;
                single_click_hold_timer = output_hold_ns;
            }
            break;
        }

        case SAW_FIRST_CLICK: {
            if (1 == new_in) {
                click_state = SAW_SECOND_RISING_EDGE;
                timer = 0;
                timeout = max_hold_ns;
            }
            break;
        }

        case SAW_SECOND_RISING_EDGE: {
            if (0 == new_in) {
                click_state = SAW_SECOND_CLICK;
                timer = 0;
                timeout = max_space_ns;
                double_click = 1;
                double_click_hold_timer = output_hold_ns;
            }
            break;
        }

        case SAW_SECOND_CLICK: {
            if (1 == new_in) {
                click_state = SAW_THIRD_RISING_EDGE;
                timer = 0;
                timeout = max_hold_ns;
            }
            break;
        }

        case SAW_THIRD_RISING_EDGE: {
            if (0 == new_in) {
                click_state = SAW_THIRD_CLICK;
                timer = 0;
                timeout = max_space_ns;
                triple_click = 1;
                triple_click_hold_timer = output_hold_ns;
            }
            break;
        }

        case SAW_THIRD_CLICK: {
            if (1 == new_in) {
                click_state = SAW_FOURTH_RISING_EDGE;
                timer = 0;
                timeout = max_hold_ns;
            }
            break;
        }

        case SAW_FOURTH_RISING_EDGE: {
            if (0 == new_in) {
                // four clicks is the most we look for, and we just saw it,
                // so we're done now
                click_state = SAW_FOURTH_CLICK;
                timer = 0;
                timeout = max_space_ns;
                quadruple_click = 1;
                quadruple_click_hold_timer = output_hold_ns;
            }
            break;
        }

        case SAW_FOURTH_CLICK: {
            if (1 == new_in) {
                click_state = HELD_TOO_LONG;
            }
            break;
        }

        case HELD_TOO_LONG: {
            if (0 == new_in) {
                click_state = IDLE;
            }
            break;
        }

        default: {
            // invalid click_state!
            click_state = IDLE;
        }
    }

    if ((click_state != IDLE) && (click_state != HELD_TOO_LONG) && (timer > timeout)) {
        if (1 == new_in) {
            click_state = HELD_TOO_LONG;
        } else {
            // timeout after some activity on the input line, trigger one
            // of the "only" outputs if appropriate
            switch (click_state) {
                case SAW_FIRST_CLICK: {
                    single_click_only = 1;
                    single_click_only_hold_timer = output_hold_ns;
                    break;
                }
                case SAW_SECOND_CLICK: {
                    double_click_only = 1;
                    double_click_only_hold_timer = output_hold_ns;
                    break;
                }
                case SAW_THIRD_CLICK: {
                    triple_click_only = 1;
                    triple_click_only_hold_timer = output_hold_ns;
                    break;
                }
                case SAW_FOURTH_CLICK: {
                    quadruple_click_only = 1;
                    quadruple_click_only_hold_timer = output_hold_ns;
                    break;
                }
            }
            click_state = IDLE;
        }
    }

    state = click_state;
}


static int __comp_get_data_size(void) { return 0; }
