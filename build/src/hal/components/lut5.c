/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:lut5:Arbitrary 5-input logic function based on a look-up table");
MODULE_INFO(linuxcnc, "pin:in_0:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in_1:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in_2:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in_3:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:in_4:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:out:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "param:function:u32:0:rw::None:None");
MODULE_INFO(linuxcnc, "funct:_:0:");
MODULE_INFO(linuxcnc, "descr:\n.B lut5\nconstructs a logic function with up to 5 inputs using a \\fBl\\fRook-\\fBu\\fRp \\fBt\\fRable.\nThe value for \\fBfunction\\fR can be determined by writing the truth table,\nand computing the sum of \\fBall\\fR the \\fBweights\\fR for which the output value would be \\fRTRUE\\fR.\nThe weights are hexadecimal not decimal so hexadecimal math must be used to sum the weights.\nA wiki page has a calculator to assist in computing the proper value for function.\n.PP\nhttps://wiki.linuxcnc.org/cgi-bin/wiki.pl?Lut5\n.PP\nNote that LUT5 will generate any of the 4,294,967,296\nlogical functions of 5 inputs so \\fBAND\\fR, \\fBOR\\fR, \\fBNAND\\fR,\n\\fBNOR\\fR, \\fBXOR\\fR and every other combinatorial function is possible.\n.PP\n.SS Example Functions\nA 5-input\n\\fIand\\fR function is TRUE only when all the inputs are true, so the correct\nvalue for \\fBfunction\\fR is \\fB0x80000000\\fR.\n.PP\nA 2-input \\fIor\\fR function would be the sum of \\fB0x2\\fR + \\fB0x4\\fR +\n\\fB0x8\\fR, so the correct value for \\fBfunction\\fR is \\fB0xe\\fR.\n.PP\nA 5-input \\fIor\\fR\nfunction is TRUE whenever any of the inputs are true, so the correct value for\n\\fBfunction\\fR is \\fB0xfffffffe\\fR. Because every weight except \\fB0x1\\fR\nis true the function is the sum of every line except the first one.\n.PP\nA 2-input \\fIxor\\fR function is\nTRUE whenever exactly one of the inputs is true, so the correct value for\n\\fBfunction\\fR is \\fB0x6\\fR.  Only \\fBin-0\\fR and \\fBin-1\\fR should be\nconnected to signals, because if any other bit is \\fBTRUE\\fR then the output\nwill be \\fBFALSE\\fR.\n.PP\n.ie '\\*[.T]'html' \\{\\\n.HTML \\\n<STYLE> \\\n#weight TD { text-align: center; padding-left: .5ex; padding-right: .5ex } \\\n#weight TH { text-align: center; padding-left: .5ex; padding-right: .5ex } \\\n#weight TD.W { text-align: right; } \\\n</STYLE> \\\n<TABLE ID=\"weight\" STYLE=\"border: 1px solid black; border-collapse: collapse\"> \\\n    <COL SPAN=5 STYLE=\"margin: .2ex\"><COL SPAN=1 STYLE=\"border-left: 1px solid black\"> \\\n<TR STYLE=\"border-bottom: 1px solid black\"> \\\n    <TH COLSPAN=6>Weights for each line of truth table \\\n<TR STYLE=\"border-bottom: 1px solid black\"> \\\n    <TH>Bit 4<TH>Bit 3<TH>Bit 2<TH>Bit 1<TH>Bit 0<TH> Weight \\\n<TR><TD>0<TD>0<TD>0<TD>0<TD>0<TD CLASS=\"w\">0x1 \\\n<TR><TD>0<TD>0<TD>0<TD>0<TD>1<TD CLASS=\"w\">0x2 \\\n<TR><TD>0<TD>0<TD>0<TD>1<TD>0<TD CLASS=\"w\">0x4 \\\n<TR><TD>0<TD>0<TD>0<TD>1<TD>1<TD CLASS=\"w\">0x8 \\\n<TR><TD>0<TD>0<TD>1<TD>0<TD>0<TD CLASS=\"w\">0x10 \\\n<TR><TD>0<TD>0<TD>1<TD>0<TD>1<TD CLASS=\"w\">0x20 \\\n<TR><TD>0<TD>0<TD>1<TD>1<TD>0<TD CLASS=\"w\">0x40 \\\n<TR><TD>0<TD>0<TD>1<TD>1<TD>1<TD CLASS=\"w\">0x80 \\\n<TR><TD>0<TD>1<TD>0<TD>0<TD>0<TD CLASS=\"w\">0x100 \\\n<TR><TD>0<TD>1<TD>0<TD>0<TD>1<TD CLASS=\"w\">0x200 \\\n<TR><TD>0<TD>1<TD>0<TD>1<TD>0<TD CLASS=\"w\">0x400 \\\n<TR><TD>0<TD>1<TD>0<TD>1<TD>1<TD CLASS=\"w\">0x800 \\\n<TR><TD>0<TD>1<TD>1<TD>0<TD>0<TD CLASS=\"w\">0x1000 \\\n<TR><TD>0<TD>1<TD>1<TD>0<TD>1<TD CLASS=\"w\">0x2000 \\\n<TR><TD>0<TD>1<TD>1<TD>1<TD>0<TD CLASS=\"w\">0x4000 \\\n<TR><TD>0<TD>1<TD>1<TD>1<TD>1<TD CLASS=\"w\">0x8000 \\\n<TR><TD>1<TD>0<TD>0<TD>0<TD>0<TD CLASS=\"w\">0x10000 \\\n<TR><TD>1<TD>0<TD>0<TD>0<TD>1<TD CLASS=\"w\">0x20000 \\\n<TR><TD>1<TD>0<TD>0<TD>1<TD>0<TD CLASS=\"w\">0x40000 \\\n<TR><TD>1<TD>0<TD>0<TD>1<TD>1<TD CLASS=\"w\">0x80000 \\\n<TR><TD>1<TD>0<TD>1<TD>0<TD>0<TD CLASS=\"w\">0x100000 \\\n<TR><TD>1<TD>0<TD>1<TD>0<TD>1<TD CLASS=\"w\">0x200000 \\\n<TR><TD>1<TD>0<TD>1<TD>1<TD>0<TD CLASS=\"w\">0x400000 \\\n<TR><TD>1<TD>0<TD>1<TD>1<TD>1<TD CLASS=\"w\">0x800000 \\\n<TR><TD>1<TD>1<TD>0<TD>0<TD>0<TD CLASS=\"w\">0x1000000 \\\n<TR><TD>1<TD>1<TD>0<TD>0<TD>1<TD CLASS=\"w\">0x2000000 \\\n<TR><TD>1<TD>1<TD>0<TD>1<TD>0<TD CLASS=\"w\">0x4000000 \\\n<TR><TD>1<TD>1<TD>0<TD>1<TD>1<TD CLASS=\"w\">0x8000000 \\\n<TR><TD>1<TD>1<TD>1<TD>0<TD>0<TD CLASS=\"w\">0x10000000 \\\n<TR><TD>1<TD>1<TD>1<TD>0<TD>1<TD CLASS=\"w\">0x20000000 \\\n<TR><TD>1<TD>1<TD>1<TD>1<TD>0<TD CLASS=\"w\">0x40000000 \\\n<TR><TD>1<TD>1<TD>1<TD>1<TD>1<TD CLASS=\"w\">0x80000000 \\\n</TABLE>\n\\}\n.el \\{\\\n.TS\nbox tab(;);\ncb s s s s s\ncb cb cb cb cb | cb\nc  c  c  c  c  | r.\nWeights for each line of truth table\n_\nBit 4;Bit 3;Bit 2;Bit 1;Bit 0; Weight\n_\n0;0;0;0;0;0x1\n0;0;0;0;1;0x2\n0;0;0;1;0;0x4\n0;0;0;1;1;0x8\n0;0;1;0;0;0x10\n0;0;1;0;1;0x20\n0;0;1;1;0;0x40\n0;0;1;1;1;0x80\n0;1;0;0;0;0x100\n0;1;0;0;1;0x200\n0;1;0;1;0;0x400\n0;1;0;1;1;0x800\n0;1;1;0;0;0x1000\n0;1;1;0;1;0x2000\n0;1;1;1;0;0x4000\n0;1;1;1;1;0x8000\n1;0;0;0;0;0x10000\n1;0;0;0;1;0x20000\n1;0;0;1;0;0x40000\n1;0;0;1;1;0x80000\n1;0;1;0;0;0x100000\n1;0;1;0;1;0x200000\n1;0;1;1;0;0x400000\n1;0;1;1;1;0x800000\n1;1;0;0;0;0x1000000\n1;1;0;0;1;0x2000000\n1;1;0;1;0;0x4000000\n1;1;0;1;1;0x8000000\n1;1;1;0;0;0x10000000\n1;1;1;0;1;0x20000000\n1;1;1;1;0;0x40000000\n1;1;1;1;1;0x80000000\n.TE\n\\}\n");
MODULE_INFO(linuxcnc, "see_also:\n\\fBand\\fR(9),\n\\fBlogic\\fR(9),\n\\fBnot\\fR(9),\n\\fBor2\\fR(9),\n\\fBxor2\\fR(9).\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Jeff Epler");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *in_0_p;
    hal_bit_t *in_1_p;
    hal_bit_t *in_2_p;
    hal_bit_t *in_3_p;
    hal_bit_t *in_4_p;
    hal_bit_t *out_p;
    hal_u32_t function_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_0_p), comp_id,
        "%s.in-0", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_1_p), comp_id,
        "%s.in-1", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_2_p), comp_id,
        "%s.in-2", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_3_p), comp_id,
        "%s.in-3", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->in_4_p), comp_id,
        "%s.in-4", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->out_p), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->function_p), comp_id,
        "%s.function", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 0, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of lut5");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of lut5");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("lut5");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "lut5.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in_0
#undef in_0_ptr
#define in_0_ptr (__comp_inst->in_0_p)
#define in_0 (0+*__comp_inst->in_0_p)
#undef in_1
#undef in_1_ptr
#define in_1_ptr (__comp_inst->in_1_p)
#define in_1 (0+*__comp_inst->in_1_p)
#undef in_2
#undef in_2_ptr
#define in_2_ptr (__comp_inst->in_2_p)
#define in_2 (0+*__comp_inst->in_2_p)
#undef in_3
#undef in_3_ptr
#define in_3_ptr (__comp_inst->in_3_p)
#define in_3 (0+*__comp_inst->in_3_p)
#undef in_4
#undef in_4_ptr
#define in_4_ptr (__comp_inst->in_4_p)
#define in_4 (0+*__comp_inst->in_4_p)
#undef out
#undef out_ptr
#define out_ptr (__comp_inst->out_p)
#define out (*__comp_inst->out_p)
#undef function
#define function (__comp_inst->function_p)


#line 145 "/home/end/projects/linuxcnc/src/hal/components/lut5.comp"

FUNCTION(_) {
    int shift = 0;
    if(in_0) shift += 1;
    if(in_1) shift += 2;
    if(in_2) shift += 4;
    if(in_3) shift += 8;
    if(in_4) shift += 16;

    out = (function & (1<<shift)) != 0;
}

static int __comp_get_data_size(void) { return 0; }
