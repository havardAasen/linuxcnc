/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:simple_tp:This component is a single axis simple trajectory planner, same as used for jogging in LinuxCNC.\nUsed by PNCconf to allow testing of acceleration and velocity values for an axis.");
MODULE_INFO(linuxcnc, "pin:target-pos:float:0:in:target position to plan for.:None:None");
MODULE_INFO(linuxcnc, "pin:maxvel:float:0:in:Maximum velocity:None:None");
MODULE_INFO(linuxcnc, "pin:maxaccel:float:0:in:Acceleration rate:None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:If disabled, planner sets velocity to zero immediately.:None:None");
MODULE_INFO(linuxcnc, "pin:current-pos:float:0:out:position commanded at this point in time.:None:None");
MODULE_INFO(linuxcnc, "pin:current-vel:float:0:out:velocity commanded at this moment in time.:None:None");
MODULE_INFO(linuxcnc, "pin:active:bit:0:out:if active is true, the planner is requesting movement.:None:None");
MODULE_INFO(linuxcnc, "funct:update:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Chris S Morley");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *target_pos_p;
    hal_float_t *maxvel_p;
    hal_float_t *maxaccel_p;
    hal_bit_t *enable_p;
    hal_float_t *current_pos_p;
    hal_float_t *current_vel_p;
    hal_bit_t *active_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void update(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->target_pos_p), comp_id,
        "%s.target-pos", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->maxvel_p), comp_id,
        "%s.maxvel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->maxaccel_p), comp_id,
        "%s.maxaccel", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable_p), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->current_pos_p), comp_id,
        "%s.current-pos", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->current_vel_p), comp_id,
        "%s.current-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->active_p), comp_id,
        "%s.active", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.update", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))update, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of simple_tp");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of simple_tp");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("simple_tp");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "simple-tp.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef target_pos
#undef target_pos_ptr
#define target_pos_ptr (__comp_inst->target_pos_p)
#define target_pos (0+*__comp_inst->target_pos_p)
#undef maxvel
#undef maxvel_ptr
#define maxvel_ptr (__comp_inst->maxvel_p)
#define maxvel (0+*__comp_inst->maxvel_p)
#undef maxaccel
#undef maxaccel_ptr
#define maxaccel_ptr (__comp_inst->maxaccel_p)
#define maxaccel (0+*__comp_inst->maxaccel_p)
#undef enable
#undef enable_ptr
#define enable_ptr (__comp_inst->enable_p)
#define enable (0+*__comp_inst->enable_p)
#undef current_pos
#undef current_pos_ptr
#define current_pos_ptr (__comp_inst->current_pos_p)
#define current_pos (*__comp_inst->current_pos_p)
#undef current_vel
#undef current_vel_ptr
#define current_vel_ptr (__comp_inst->current_vel_p)
#define current_vel (*__comp_inst->current_vel_p)
#undef active
#undef active_ptr
#define active_ptr (__comp_inst->active_p)
#define active (*__comp_inst->active_p)


#line 36 "/home/end/projects/linuxcnc/src/hal/components/simple_tp.comp"
#include "rtapi_math.h"
FUNCTION(update) {
    double max_dv, tiny_dp, pos_err, vel_req;

    active = 0;
    /* compute max change in velocity per servo period */
    max_dv = maxaccel * fperiod;
    /* compute a tiny position range, to be treated as zero */
    tiny_dp = max_dv * fperiod * 0.001;
    /* calculate desired velocity */
    if (enable) {
	/* planner enabled, request a velocity that tends to drive
	   pos_err to zero, but allows for stopping without position
	   overshoot */
	pos_err = target_pos - current_pos;
	/* positive and negative errors require some sign flipping to
	   avoid sqrt(negative) */
	if (pos_err > tiny_dp) {
	    vel_req = -max_dv +
		       sqrt(2.0 * maxaccel * pos_err + max_dv * max_dv);
	    /* mark planner as active */
	    active = 1;
	} else if (pos_err < -tiny_dp) {
	    vel_req =  max_dv -
		       sqrt(-2.0 * maxaccel * pos_err + max_dv * max_dv);
	    /* mark planner as active */
	    active = 1;
	} else {
	    /* within 'tiny_dp' of desired pos, no need to move */
	    vel_req = 0.0;
	}
    } else {
	/* planner disabled, request zero velocity */
	vel_req = 0.0;
    }
    /* limit velocity request */
    if (vel_req > maxvel) {
        vel_req = maxvel;
    } else if (vel_req < -maxvel) {
	vel_req = -maxvel;
    }
    /* ramp velocity toward request at accel limit */
    if (vel_req > current_vel + max_dv) {
	current_vel += max_dv;
    } else if (vel_req < current_vel - max_dv) {
	current_vel -= max_dv;
    } else {
	current_vel = vel_req;
    }
    /* check for still moving */
    if (current_vel != 0.0) {
	/* yes, mark planner active */
	active = 1;
    }
    /* integrate velocity to get new position */
    current_pos += current_vel * fperiod;
}


static int __comp_get_data_size(void) { return 0; }
