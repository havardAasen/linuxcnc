/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:max31855:Support for the MAX31855 Thermocouple-to-Digital converter using bitbanged spi");
MODULE_INFO(linuxcnc, "descr:The component requires at least 3 pins to bitbang spi protocol, for example:\n\n\\fB loadrt max31855 personality=1\\fR\n\n\\fB setp hm2_6i25.0.gpio.023.is_output true\\fR\n\\fB setp hm2_6i25.0.gpio.024.is_output true\\fR\n\n\\fB net spi.clk.in    hm2_6i25.0.gpio.023.out     max31855.0.clk.out\\fR\n\\fB net spi.cs.in     hm2_6i25.0.gpio.024.out     max31855.0.cs.out\\fR\n\\fB net spi.data0.in  hm2_6i25.0.gpio.033.in_not  max31855.0.data.0.in\\fR\n\n\\fB addf max31855.0.bitbang-spi servo-thread \\fR\n\n\nThe MAX31855 supports a range of -270C to 1800C, however linearization data \nis only available for the -200C to 1350C range, beyond which raw temperature is returned.\n\nTemperature pins are provided for readings in Celsius, Fahrenheit and Kelvin,\ntemperature values are not updated while a fault condition is present.\n\nThe personality parameter is used to indicate the number of sensors.\nMultiple sensors share the clk and cs pins, but connect to discrete data input pins.\nA maximum of 15 sensors are supported.\n\n");
MODULE_INFO(linuxcnc, "pin:data.#.in:bit:(15, '( personality & 0xf )'):in:Pin(s) connected to data out.:None:None");
MODULE_INFO(linuxcnc, "pin:cs.out:bit:0:out:Pin connected to cs, pulled low to shift data, pulled high for data refresh.:None:None");
MODULE_INFO(linuxcnc, "pin:clk.out:bit:0:out:Pin connected to clk.:None:None");
MODULE_INFO(linuxcnc, "pin:temp_celsius.#:float:(15, '( personality & 0xf )'):out:Temperature output values in Celsius.:None:None");
MODULE_INFO(linuxcnc, "pin:temp_fahrenheit.#:float:(15, '( personality & 0xf )'):out:Temperature in Fahrenheit.:None:None");
MODULE_INFO(linuxcnc, "pin:temp_kelvin.#:float:(15, '( personality & 0xf )'):out:Temperature in Kelvin.:None:None");
MODULE_INFO(linuxcnc, "pin:fault.#:bit:(15, '( personality & 0xf )'):out:Fault condition detected.:None:None");
MODULE_INFO(linuxcnc, "pin:fault_flags.#:u32:(15, '( personality & 0xf )'):out:Fault flags: 0x1  = open sensor, 0x2 short to gnd, 0x3 short to vcc.:None:None");
MODULE_INFO(linuxcnc, "funct:bitbang_spi:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Joseph Calderon");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *data_in_p[15];
    hal_bit_t *cs_out_p;
    hal_bit_t *clk_out_p;
    hal_float_t *temp_celsius_p[15];
    hal_float_t *temp_fahrenheit_p[15];
    hal_float_t *temp_kelvin_p[15];
    hal_bit_t *fault_p[15];
    hal_u32_t *fault_flags_p[15];
    unsigned data_frame_p[15];

    unsigned state_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void bitbang_spi(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin data.#.in: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->data_in_p[j]), comp_id,
            "%s.data.%01d.in", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_bit_newf(HAL_OUT, &(inst->cs_out_p), comp_id,
        "%s.cs.out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->clk_out_p), comp_id,
        "%s.clk.out", prefix);
    if(r != 0) return r;
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin temp_celsius.#: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->temp_celsius_p[j]), comp_id,
            "%s.temp-celsius.%01d", prefix, j);
        if(r != 0) return r;
    }
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin temp_fahrenheit.#: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->temp_fahrenheit_p[j]), comp_id,
            "%s.temp-fahrenheit.%01d", prefix, j);
        if(r != 0) return r;
    }
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin temp_kelvin.#: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->temp_kelvin_p[j]), comp_id,
            "%s.temp-kelvin.%01d", prefix, j);
        if(r != 0) return r;
    }
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin fault.#: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->fault_p[j]), comp_id,
            "%s.fault.%01d", prefix, j);
        if(r != 0) return r;
    }
    if((( personality & 0xf )) > (15)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin fault_flags.#: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)15);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_u32_newf(HAL_OUT, &(inst->fault_flags_p[j]), comp_id,
            "%s.fault-flags.%01d", prefix, j);
        if(r != 0) return r;
    }
    inst->state_p = 1.0;
    rtapi_snprintf(buf, sizeof(buf), "%s.bitbang-spi", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))bitbang_spi, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of max31855");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of max31855");
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each max31855");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("max31855");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "max31855.%d", i);
            r = export(buf, i, p_value("max31855", buf, i) );
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx, p_value("max31855", buf, idx) );
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef data_in
#undef data_in_ptr
#define data_in_ptr(i) (__comp_inst->data_in_p[i])
#define data_in(i) (0+*(__comp_inst->data_in_p[i]))
#undef cs_out
#undef cs_out_ptr
#define cs_out_ptr (__comp_inst->cs_out_p)
#define cs_out (*__comp_inst->cs_out_p)
#undef clk_out
#undef clk_out_ptr
#define clk_out_ptr (__comp_inst->clk_out_p)
#define clk_out (*__comp_inst->clk_out_p)
#undef temp_celsius
#undef temp_celsius_ptr
#define temp_celsius_ptr(i) (__comp_inst->temp_celsius_p[i])
#define temp_celsius(i) (*(__comp_inst->temp_celsius_p[i]))
#undef temp_fahrenheit
#undef temp_fahrenheit_ptr
#define temp_fahrenheit_ptr(i) (__comp_inst->temp_fahrenheit_p[i])
#define temp_fahrenheit(i) (*(__comp_inst->temp_fahrenheit_p[i]))
#undef temp_kelvin
#undef temp_kelvin_ptr
#define temp_kelvin_ptr(i) (__comp_inst->temp_kelvin_p[i])
#define temp_kelvin(i) (*(__comp_inst->temp_kelvin_p[i]))
#undef fault
#undef fault_ptr
#define fault_ptr(i) (__comp_inst->fault_p[i])
#define fault(i) (*(__comp_inst->fault_p[i]))
#undef fault_flags
#undef fault_flags_ptr
#define fault_flags_ptr(i) (__comp_inst->fault_flags_p[i])
#define fault_flags(i) (*(__comp_inst->fault_flags_p[i]))
#undef data_frame
#define data_frame (__comp_inst->data_frame_p)
#undef state
#define state (__comp_inst->state_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 48 "/home/end/projects/linuxcnc/src/hal/components/max31855.comp"

#include "rtapi_math.h"

static float accpoly(float *v, size_t n, float p) {
  int i;
  float ret = 0;
  for (i = 0; i < n; i++) {
    ret += v[i] * pow(p, i);
  }
  return ret;
}

static float to_kelvin(float celsius) {
  return celsius + 273.15;
}

static float to_fahrenheit(float celsius) {
  return celsius * 1.80 + 32.0;
}

static float read_celsius(int32_t v) {
  if (v & 0x7) {
    return nan(""); /* fault bit(s) set */
  }

  /* thermocouple temperature is in bits 31:18 */
  if (v & 0x80000000) {
    v = 0xffffc000 | ((v >> 18) & 0x0003ffff); /* extend sign bit */
  } else {
    v >>= 18;
  }
  return v / 4.0; /* 0.25 degree resolution */
}

static float read_internal(int32_t v) {
  if (v & 0x7) {
    return nan(""); /* fault bit(s) set */
  }

  /* internal temperature is in bits 15:4 */
  v = 0x0000ffff & v;
  if (v & 0x8000) {
    v = 0xfffff000 | ((v >> 4) & 0x00000fff); /* extend sign bit */
  } else {
    v >>= 4;
  }
  return v / 16.0; /* 0.0625 degree resolution */
}

static float read_celsius_adjusted(int32_t sensor_data) {
  float temp_raw = read_celsius(sensor_data);
  float temp_internal = read_internal(sensor_data);
  float voltage_internal = 0, voltage_thermocouple = 0, temp_corrected = 0;

  if (isnan(temp_raw) || isnan(temp_internal))
    return nan("");

  /* NIST K-Type table (http://srdata.nist.gov/its90/download/type_k.tab) */
  float coeff[][11] = {
      {-0.0176004134, 0.0389212035, 1.85587705e-05, -9.94575942e-08,
       3.18409465e-10, -5.60728439e-13, 5.60750581e-16, -3.20207199e-19,
       9.71511487e-23, -1.21047216e-26, 0},
      {0, 0.0394501276, 2.36223732e-05, -3.28589067e-07, -4.99048269e-09,
       -6.75090608e-11, -5.74103265e-13, -3.10888726e-15, -1.0451609e-17,
       -1.9889267e-20, -1.63226981e-23},
      {0, 25.1734619, -1.16628778, -1.08336377, -0.897735417, -0.373423755,
       -0.0866326466, -0.0104505979, -0.000519205758, 0, 0},
      {0, 25.0835495, 0.0786010623, -0.250313103, 0.0831526965, -0.0122803403,
       0.000980403624, -4.41302982e-05, 1.05773404e-06, -1.05275504e-08, 0},
      {-131.805801, 48.3022194, -1.64603102, 0.0546473116, -0.000965071493,
       8.80219341e-06, -3.1108101e-08, 0, 0, 0, 0}};
  int coeff_cols = sizeof(coeff[0]) / sizeof(float);

  /* determine thermocouple voltage by subtracting internal temp and adjusting
   * for K-type thermocouple */
  voltage_thermocouple = (temp_raw - temp_internal) * 0.041276;

  if (temp_internal >= 0) {
    float a[] = {0.118597597, -0.000118343203, 126.968597};
    /* for positive temps additional exponential coefficients are needed */
    voltage_internal += accpoly(coeff[0], coeff_cols, temp_internal);
    voltage_internal += a[0] * exp(a[1] * pow((temp_internal - a[2]), 2));
  } else if (temp_internal < 0) {
    voltage_internal += accpoly(coeff[1], coeff_cols, temp_internal);
  }

  float voltage_total = voltage_thermocouple + voltage_internal;

  /* linearize temperature depending on voltage range */
  if (voltage_total < 0) {
    /* Temperature is between -200 and 0C. */
    temp_corrected += accpoly(coeff[2], coeff_cols, voltage_total);
  } else if (voltage_total < 20.644) {
    /* Temperature is between 0C and 500C. */
    temp_corrected += accpoly(coeff[3], coeff_cols, voltage_total);
  } else if (voltage_total < 54.886) {
    /* Temperature is between 500C and 1372C. */
    temp_corrected += accpoly(coeff[4], coeff_cols, voltage_total);
  } else {
    /* NIST only has data for K-type thermocouples from -200C to +1372C. */
    temp_corrected = temp_raw;
  }

  return temp_corrected;
}

FUNCTION(bitbang_spi) {
  int nbit = (state >> 1) & 0x3f;
  int delay = (state >> 7) & 0x3ff;
  int cs = state & 0x1;

  clk_out ^= 0x1;
  if (cs) {
    /* data refreshes when cs is pulled high */
    delay--;
    if (delay <= 0) {
      nbit = 32;
      cs = 0;
    }
  } else {
    int i, n = (personality > 15) ? 15 : personality;
    /* with cs low pull data bits when clock is high */
    if (clk_out) {
      for (i = 0; i < n; i++) {
        data_frame[i] |= (data_in(i) << nbit);
      }
      nbit--;
    }
    if (nbit < 0) {
      for (i = 0; i < n; i++) {
        float f = read_celsius_adjusted((int32_t)data_frame[i]);
        fault(i) = (data_frame[i] & 0x7) ? TRUE : FALSE;
        fault_flags(i) = data_frame[i] & 0x7;
        if (isnan(f)) {
          rtapi_print("max31855: sensor %d detected fault %x\n", i, data_frame[i] & 0x7);
        } else {
          temp_celsius(i) = f;
          temp_fahrenheit(i) = to_fahrenheit(f);
          temp_kelvin(i) = to_kelvin(f);
        }
        data_frame[i] = 0;
      }
      nbit = 0;
      cs = 1;
    }
    delay++;
  }
  state = (delay << 7) | (nbit << 1) | cs;
  cs_out = cs;
}

static int __comp_get_data_size(void) { return 0; }
