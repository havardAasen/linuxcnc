/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:50 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:joyhandle:sets nonlinear joypad movements, deadbands and scales");
MODULE_INFO(linuxcnc, "pin:in:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "param:power:float:0:rw::2.0:None");
MODULE_INFO(linuxcnc, "param:deadband:float:0:rw::0.:None");
MODULE_INFO(linuxcnc, "param:scale:float:0:rw::1.:None");
MODULE_INFO(linuxcnc, "param:offset:float:0:rw::0.:None");
MODULE_INFO(linuxcnc, "param:inverse:bit:0:rw::0:None");
MODULE_INFO(linuxcnc, "descr:\nThe component \\fBjoyhandle\\fR uses the following formula for a non linear joypad movements:\n\n\\fBy = (scale * (a*x^power + b*x)) + offset\\fR\n\nThe parameters a and b are adjusted in such a way, that the function starts at (deadband,offset) and ends at (1,scale+offset).\n\nNegative values will be treated point symmetrically to origin. Values \\-deadband < x < +deadband will be set to zero.\n\nValues x > 1 and x < \\-1 will be skipped to \\(+-(scale+offset). Invert transforms the function to a progressive movement.\n\nWith power one can adjust the nonlinearity (default = 2). Default for deadband is 0.\n\nValid values are: power >= 1.0 (reasonable values are 1.x .. 4\\(hy5, take higher power\\(hyvalues for higher deadbands (>0.5), if you want to start with a nearly horizontal slope), 0 <= deadband < 0.99 (reasonable 0.1).\n\nAn additional offset component can be set in special cases (default = 0).\n\nAll values can be adjusted for each instance separately.\n");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Paul Willutzki");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *in_p;
    hal_float_t *out_p;
    hal_float_t power_p;
    hal_float_t deadband_p;
    hal_float_t scale_p;
    hal_float_t offset_p;
    hal_bit_t inverse_p;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->in_p), comp_id,
        "%s.in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->out_p), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->power_p), comp_id,
        "%s.power", prefix);
    inst->power_p = 2.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->deadband_p), comp_id,
        "%s.deadband", prefix);
    inst->deadband_p = 0.;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->scale_p), comp_id,
        "%s.scale", prefix);
    inst->scale_p = 1.;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->offset_p), comp_id,
        "%s.offset", prefix);
    inst->offset_p = 0.;
    if(r != 0) return r;
    r = hal_param_bit_newf(HAL_RW, &(inst->inverse_p), comp_id,
        "%s.inverse", prefix);
    inst->inverse_p = 0;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of joyhandle");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of joyhandle");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("joyhandle");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "joyhandle.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#undef in_ptr
#define in_ptr (__comp_inst->in_p)
#define in (0+*__comp_inst->in_p)
#undef out
#undef out_ptr
#define out_ptr (__comp_inst->out_p)
#define out (*__comp_inst->out_p)
#undef power
#define power (__comp_inst->power_p)
#undef deadband
#define deadband (__comp_inst->deadband_p)
#undef scale
#define scale (__comp_inst->scale_p)
#undef offset
#define offset (__comp_inst->offset_p)
#undef inverse
#define inverse (__comp_inst->inverse_p)


#line 50 "/home/end/projects/linuxcnc/src/hal/components/joyhandle.comp"
#include <rtapi_math.h>

FUNCTION(_) {
double p,a,b,alin,clin,xm,ym,xinv,yinv;

if (power < 1.0) power =1.0;

if (deadband >= 0.99) deadband = 0.99;
else if (deadband <= 0.) deadband = 0.;

p = power - 1.;
a = -1./(pow(deadband,p)-1.);
b = 1. - a;
alin = -scale/(deadband-1);
clin = 1.*(scale+offset-alin);

if (in >= 1.) out = scale + offset;
else if ((in <= deadband) && (in >= (-1*deadband))) out = 0.;
else if (in <= -1.) out = -scale - offset;
else if ((in > deadband) && (in < 1.))
    {
	if (power == 1.) out=alin*in + clin;
 	else {
		if (inverse == 0) out = scale*(a*pow(in,power) + b*in) + offset;
		else {
			xm = (deadband+1)/2;
        		ym = alin*xm + clin;
        		xinv = 2*xm-in;
        		yinv = scale*(a*pow(xinv,power) + b*xinv) + offset;
        		out =2*ym-yinv;
		     }
	     }
     }
else if ((in < (-1.*deadband)) && (in > -1.))
    {
	if (power == 1.) out=-1.*(alin*-1.*in + clin);
 	else {
		if (inverse == 0) out = -1*(scale*(a*pow((-1.*in),power) - b*in) + offset);
		else {
			xm = (deadband+1)/2;
        		ym = alin*xm + clin;
        		xinv = 2*xm+in;
        		yinv = scale*(a*pow(xinv,power) + b*xinv) + offset;
        		out =-2*ym-yinv;
		     }
	     }
     }
else out = 0.;
 
// out = scale*(a*pow(in,power) + b*in) + offset;
}

static int __comp_get_data_size(void) { return 0; }
