/* Autogenerated by /home/end/projects/linuxcnc/build/bin/halcompile on Thu Sep 28 23:37:49 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:bldc:BLDC and AC-servo control component \n.B loadrt bldc cfg=qi6,aH\\fB");
MODULE_INFO(linuxcnc, "pin:hall1:bit:0:in:Hall sensor signal 1:None:personality & 0x01");
MODULE_INFO(linuxcnc, "pin:hall2:bit:0:in:Hall sensor signal 2:None:personality & 0x01");
MODULE_INFO(linuxcnc, "pin:hall3:bit:0:in:Hall sensor signal 3:None:personality & 0x01");
MODULE_INFO(linuxcnc, "pin:hall_error:bit:0:out:Indicates that the selected hall pattern gives inconsistent rotor position data.\nThis can be due to the pattern being wrong for the motor, or one or more sensors being unconnected or broken.\nA consistent pattern is not neceesarily valid, but an inconsistent one can never be valid.:None:personality & 0x01");
MODULE_INFO(linuxcnc, "pin:C1:bit:0:in:Fanuc Gray-code bit 0 input:None:( personality & 0x10 )");
MODULE_INFO(linuxcnc, "pin:C2:bit:0:in:Fanuc Gray-code bit 1 input:None:( personality & 0x10 )");
MODULE_INFO(linuxcnc, "pin:C4:bit:0:in:Fanuc Gray-code bit 2 input:None:( personality & 0x10 )");
MODULE_INFO(linuxcnc, "pin:C8:bit:0:in:Fanuc Gray-code bit 3 input:None:( personality & 0x10 )");
MODULE_INFO(linuxcnc, "pin:value:float:0:in:PWM master amplitude input:None:None");
MODULE_INFO(linuxcnc, "pin:lead-angle:float:0:in:The phase lead between the electrical vector and the rotor position in degrees:90:personality & 0x06");
MODULE_INFO(linuxcnc, "pin:rev:bit:0:in:Set this pin true to reverse the motor. Negative PWM amplitudes will alsoreverse the motor and there will generally be a Hall pattern that runs the motor in each direction too.:None:None");
MODULE_INFO(linuxcnc, "pin:frequency:float:0:in:Frequency input for motors with no feedback at all, or those with only an index (which is ignored):None:( personality & 0x0F ) == 0");
MODULE_INFO(linuxcnc, "pin:initvalue:float:0:in:The current to be used for the homing sequence in applications where an incremental encoder is used with no hall-sensor feedback:0.2:personality & 0x04");
MODULE_INFO(linuxcnc, "pin:rawcounts:s32:0:in:Encoder counts input. This must be linked to the encoder rawcounts pin or encoder index resets will cause the motor commutation to fail.:0:personality & 0x06");
MODULE_INFO(linuxcnc, "pin:index-enable:bit:0:io:This pin should be connected to the associated encoder index-enable pin to zero the encoder when it passes index.\nThis is only used indicate to the bldc control component that an index has been seen.:None:personality & 0x08");
MODULE_INFO(linuxcnc, "pin:init:bit:0:in:A rising edge on this pin starts the motor alignment sequence.\nThis pin should be connected in such a way that the motors re-align any time that encoder monitoring has been interrupted.\nTypically this will only be at machine power-off.\nThe alignment process involves powering the motor phases in such a way as to put the motor in a known position.\nThe encoder counts are then stored in the \\fBoffset\\fP parameter.\nThe alignment process will tend to cause a following error if it is triggered while the axis is enabled, so should be set before the matching axis.N.enable pin.\nThe complementary \\fBinit-done\\fP pin can be used to handle the required sequencing.\n\nBoth pins can be ignored if the encoder offset is known explicitly, such as is the case with an absolute encoder.\nIn that case the \\fBoffset\\fP parameter can be set directly in the HAL file.:None:( personality & 0x05 ) == 4");
MODULE_INFO(linuxcnc, "pin:init-done:bit:0:out:Indicates homing sequence complete.:0:( personality & 0x05 ) == 4");
MODULE_INFO(linuxcnc, "pin:A-value:float:0:out:Output amplitude for phase A:None:( personality & 0xF00 ) == 0");
MODULE_INFO(linuxcnc, "pin:B-value:float:0:out:Output amplitude for phase B:None:( personality & 0xF00 ) == 0");
MODULE_INFO(linuxcnc, "pin:C-value:float:0:out:Output amplitude for phase C:None:( personality & 0xF00 ) == 0");
MODULE_INFO(linuxcnc, "pin:A-on:bit:0:out:Output bit for phase A:None:( personality & 0xF00 ) == 0x100");
MODULE_INFO(linuxcnc, "pin:B-on:bit:0:out:Output bit for phase B:None:( personality & 0xF00 ) == 0x100");
MODULE_INFO(linuxcnc, "pin:C-on:bit:0:out:Output bit for phase C:None:( personality & 0xF00 ) == 0x100");
MODULE_INFO(linuxcnc, "pin:A-high:float:0:out:High-side driver for phase A:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:B-high:float:0:out:High-side driver for phase B:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:C-high:float:0:out:High-side driver for phase C:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:A-low:float:0:out:Low-side driver for phase A:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:B-low:float:0:out:Low-side driver for phase B:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:C-low:float:0:out:Low-side driver for phase C:None:( personality & 0xF00 ) == 0x200");
MODULE_INFO(linuxcnc, "pin:A-high-on:bit:0:out:High-side driver for phase A:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:B-high-on:bit:0:out:High-side driver for phase B:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:C-high-on:bit:0:out:High-side driver for phase C:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:A-low-on:bit:0:out:Low-side driver for phase A:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:B-low-on:bit:0:out:Low-side driver for phase B:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:C-low-on:bit:0:out:Low-side driver for phase C:None:( personality & 0xF00 ) == 0x300");
MODULE_INFO(linuxcnc, "pin:hall1-out:bit:0:out:Hall 1 output:None:( personality & 0x400 )");
MODULE_INFO(linuxcnc, "pin:hall2-out:bit:0:out:Hall 2 output:None:( personality & 0x400 )");
MODULE_INFO(linuxcnc, "pin:hall3-out:bit:0:out:Hall 3 output:None:( personality & 0x400 )");
MODULE_INFO(linuxcnc, "pin:C1-out:bit:0:out:Fanuc Gray-code bit 0 output:None:( personality & 0x800 )");
MODULE_INFO(linuxcnc, "pin:C2-out:bit:0:out:Fanuc Gray-code bit 1 output:None:( personality & 0x800 )");
MODULE_INFO(linuxcnc, "pin:C4-out:bit:0:out:Fanuc Gray-code bit 2 output:None:( personality & 0x800 )");
MODULE_INFO(linuxcnc, "pin:C8-out:bit:0:out:Fanuc Gray-code bit 3 output:None:( personality & 0x800 )");
MODULE_INFO(linuxcnc, "pin:phase-angle:float:0:out:Phase angle including lead/lag angle after encoder zeroing, etc. Useful for angle/current drives.\nThis value has a range of 0 to 1 and measures electrical revolutions.\nIt will have two zeros for a 4 pole motor, three for a 6-pole, etc.:0:None");
MODULE_INFO(linuxcnc, "pin:rotor-angle:float:0:out:Rotor angle after encoder zeroing etc. Useful for angle/current drives which add their own phase offset such as the 8I20.\nThis value has a range of 0 to 1 and measures electrical revolutions. It will have two zeros for a 4 pole motor, three for a 6-pole, etc.:0:None");
MODULE_INFO(linuxcnc, "pin:out:float:0:out:Current output, including the effect of the dir pin and the alignment sequence.:None:None");
MODULE_INFO(linuxcnc, "pin:out-dir:bit:0:out:Direction output, high if /fBvalue/fR is negative XOR /fBrev/fR is true.:None:None");
MODULE_INFO(linuxcnc, "pin:out-abs:float:0:out:Absolute value of the input value:None:None");
MODULE_INFO(linuxcnc, "param:in_type:s32:0:r:state machine output, will probably hide after debug:-1:None");
MODULE_INFO(linuxcnc, "param:out_type:s32:0:r:state machine output, will probably hide after debug:-1:None");
MODULE_INFO(linuxcnc, "param:scale:s32:0:rw:The number of encoder counts per rotor revolution.:512:personality & 0x06");
MODULE_INFO(linuxcnc, "param:poles:s32:0:rw:The number of motor poles. The encoder scale will be divided by this value\nto determine the number of encoder counts per electrical revolution.:4:personality & 0x06");
MODULE_INFO(linuxcnc, "param:encoder-offset:s32:0:rw:The offset, in encoder counts, between the motor electrical zero and the\nencoder zero modulo the number of counts per electrical revolution:0:personality & 0x0A");
MODULE_INFO(linuxcnc, "param:offset_measured:s32:0:r:The encoder offset measured by the homing sequence (in certain modes):0:personality & 0x04");
MODULE_INFO(linuxcnc, "param:drive-offset:float:0:rw:The angle, in degrees, applied to the commanded angle by the drive in degrees.\nThis value is only used during the homing sequence of drives with incremental encoder feedback.\nIt is used to back-calculate from commanded angle to actual phase angle.\nIt is only relevant to drives which expect rotor-angle input rather than phase-angle demand. Should be 0 for most drives.:0:None");
MODULE_INFO(linuxcnc, "param:output-pattern:u32:0:rw:Commutation pattern to be output in Hall Signal translation mode. See the description of /fBpattern/fR for details.:25:personality & 0x400");
MODULE_INFO(linuxcnc, "param:pattern:u32:0:rw:Commutation pattern to use, from 0 to 47. Default is type 25.\nEvery plausible combination is included.\nThe table shows the excitation pattern along the top, and the pattern code on the left hand side.\nThe table entries are the hall patterns in H1, H2, H3 order.\nCommon patterns are:\n0 (30 degree commutation) and 26, its reverse.\n17 (120 degree).\n18 (alternate 60 degree).\n21 (300 degree, Bodine).\n22 (240 degree).\n25 (60 degree commutation).\n\nNote that a number of incorrect commutations will have non-zero net torque which might look as if they work, but don't really.\n\nIf your motor lacks documentation it might be worth trying every pattern.\n\n.ie '\\*[.T]'html' \\{\\\n.HTML \\\n<STYLE> \\\n#pattern TD { text-align: center; padding-left: .5ex; padding-right: .5ex } \\\n#pattern TH { text-align: center; padding-left: .5ex; padding-right: .5ex } \\\n#pattern TD.W { text-align: right; } \\\n</STYLE> \\\n<TABLE ID=\"pattern\" STYLE=\"border: 1px solid black; border-collapse: collapse\"> \\\n<COL SPAN=7 STYLE=\"margin: .2ex\"><COL SPAN=1 STYLE=\"border-left: 1px solid black\"> \\\n<TR><TD>&nbsp;<TH COLSPAN=6 CLASS=W>Phases, Source - Sink \\\n<TR><TH CLASS=W>pat<TH CLASS=W>B-A<TH CLASS=W>C-A<TH CLASS=W>C-B<TH CLASS=W>A-B<TH CLASS=W>A-C<TH CLASS=W>B-C \\\n<TR><TH>0<TD>000<TD>001<TD>011<TD>111<TD>110<TD>100 \\\n<TR><TH>1<TD>001<TD>000<TD>010<TD>110<TD>111<TD>101 \\\n<TR><TH>2<TD>000<TD>010<TD>011<TD>111<TD>101<TD>100 \\\n<TR><TH>3<TD>001<TD>011<TD>010<TD>110<TD>100<TD>101 \\\n<TR><TH>4<TD>010<TD>011<TD>001<TD>101<TD>100<TD>110 \\\n<TR><TH>5<TD>011<TD>010<TD>000<TD>100<TD>101<TD>111 \\\n<TR><TH>6<TD>010<TD>000<TD>001<TD>101<TD>111<TD>110 \\\n<TR><TH>7<TD>011<TD>001<TD>000<TD>100<TD>110<TD>111 \\\n<TR><TH>8<TD>000<TD>001<TD>101<TD>111<TD>110<TD>010 \\\n<TR><TH>9<TD>001<TD>000<TD>100<TD>110<TD>111<TD>011 \\\n<TR><TH>10<TD>000<TD>010<TD>110<TD>111<TD>101<TD>001 \\\n<TR><TH>11<TD>001<TD>011<TD>111<TD>110<TD>100<TD>000 \\\n<TR><TH>12<TD>010<TD>011<TD>111<TD>101<TD>100<TD>000 \\\n<TR><TH>13<TD>011<TD>010<TD>110<TD>100<TD>101<TD>001 \\\n<TR><TH>14<TD>010<TD>000<TD>100<TD>101<TD>111<TD>011 \\\n<TR><TH>15<TD>011<TD>001<TD>101<TD>100<TD>110<TD>010 \\\n<TR><TH>16<TD>000<TD>100<TD>101<TD>111<TD>011<TD>010 \\\n<TR><TH>17<TD>001<TD>101<TD>100<TD>110<TD>010<TD>011 \\\n<TR><TH>18<TD>000<TD>100<TD>110<TD>111<TD>011<TD>001 \\\n<TR><TH>19<TD>001<TD>101<TD>111<TD>110<TD>010<TD>000 \\\n<TR><TH>20<TD>010<TD>110<TD>111<TD>101<TD>001<TD>000 \\\n<TR><TH>21<TD>011<TD>111<TD>110<TD>100<TD>000<TD>001 \\\n<TR><TH>22<TD>010<TD>110<TD>100<TD>101<TD>001<TD>011 \\\n<TR><TH>23<TD>011<TD>111<TD>101<TD>100<TD>000<TD>010 \\\n<TR><TH>24<TD>100<TD>101<TD>111<TD>011<TD>010<TD>000 \\\n<TR><TH>25<TD>101<TD>100<TD>110<TD>010<TD>011<TD>001 \\\n<TR><TH>26<TD>100<TD>110<TD>111<TD>011<TD>001<TD>000 \\\n<TR><TH>27<TD>101<TD>111<TD>110<TD>010<TD>000<TD>001 \\\n<TR><TH>28<TD>110<TD>111<TD>101<TD>001<TD>000<TD>010 \\\n<TR><TH>29<TD>111<TD>110<TD>100<TD>000<TD>001<TD>011 \\\n<TR><TH>30<TD>110<TD>100<TD>101<TD>001<TD>011<TD>010 \\\n<TR><TH>31<TD>111<TD>101<TD>100<TD>000<TD>010<TD>011 \\\n<TR><TH>32<TD>100<TD>101<TD>001<TD>011<TD>010<TD>110 \\\n<TR><TH>33<TD>101<TD>100<TD>000<TD>010<TD>011<TD>111 \\\n<TR><TH>34<TD>100<TD>110<TD>010<TD>011<TD>001<TD>101 \\\n<TR><TH>35<TD>101<TD>111<TD>011<TD>010<TD>000<TD>100 \\\n<TR><TH>36<TD>110<TD>111<TD>011<TD>001<TD>000<TD>100 \\\n<TR><TH>37<TD>111<TD>110<TD>010<TD>000<TD>001<TD>101 \\\n<TR><TH>38<TD>110<TD>100<TD>000<TD>001<TD>011<TD>111 \\\n<TR><TH>39<TD>111<TD>101<TD>001<TD>000<TD>010<TD>110 \\\n<TR><TH>40<TD>100<TD>000<TD>001<TD>011<TD>111<TD>110 \\\n<TR><TH>41<TD>101<TD>001<TD>000<TD>010<TD>110<TD>111 \\\n<TR><TH>42<TD>100<TD>000<TD>010<TD>011<TD>111<TD>101 \\\n<TR><TH>43<TD>101<TD>001<TD>011<TD>010<TD>110<TD>100 \\\n<TR><TH>44<TD>110<TD>010<TD>011<TD>001<TD>101<TD>100 \\\n<TR><TH>45<TD>111<TD>011<TD>010<TD>000<TD>100<TD>101 \\\n<TR><TH>46<TD>110<TD>010<TD>000<TD>001<TD>101<TD>111 \\\n<TR><TH>47<TD>111<TD>011<TD>001<TD>000<TD>100<TD>110 \\\n</TABLE>\n\\}\n.el \\{\\\n\n.TS\nbox tab(;);\ncb s s s s s s\ncb|cb cb cb cb cb cb\nc | c  c  c  c c r.\nPhases, Source - Sink\n_\npat;B-A;C-A;C-B;A-B;A-C;B-C\n_\n0;000;001;011;111;110;100\n1;001;000;010;110;111;101\n2;000;010;011;111;101;100\n3;001;011;010;110;100;101\n4;010;011;001;101;100;110\n5;011;010;000;100;101;111\n6;010;000;001;101;111;110\n7;011;001;000;100;110;111\n8;000;001;101;111;110;010\n9;001;000;100;110;111;011\n10;000;010;110;111;101;001\n11;001;011;111;110;100;000\n12;010;011;111;101;100;000\n13;011;010;110;100;101;001\n14;010;000;100;101;111;011\n15;011;001;101;100;110;010\n16;000;100;101;111;011;010\n17;001;101;100;110;010;011\n18;000;100;110;111;011;001\n19;001;101;111;110;010;000\n20;010;110;111;101;001;000\n21;011;111;110;100;000;001\n22;010;110;100;101;001;011\n23;011;111;101;100;000;010\n24;100;101;111;011;010;000\n25;101;100;110;010;011;001\n26;100;110;111;011;001;000\n27;101;111;110;010;000;001\n28;110;111;101;001;000;010\n29;111;110;100;000;001;011\n30;110;100;101;001;011;010\n31;111;101;100;000;010;011\n32;100;101;001;011;010;110\n33;101;100;000;010;011;111\n34;100;110;010;011;001;101\n35;101;111;011;010;000;100\n36;110;111;011;001;000;100\n37;111;110;010;000;001;101\n38;110;100;000;001;011;111\n39;111;101;001;000;010;110\n40;100;000;001;011;111;110\n41;101;001;000;010;110;111\n42;100;000;010;011;111;101\n43;101;001;011;010;110;100\n44;110;010;011;001;101;100\n45;111;011;010;000;100;101\n46;110;010;000;001;101;111\n47;111;011;001;000;100;110\n.TE\n\\}\n:25:personality & 0x01");
MODULE_INFO(linuxcnc, "descr:\nThis component is designed as an interface between the most common forms of three-phase motor feedback devices and the corresponding types of drive.\nHowever, there is no requirement that the motor and drive should necessarily be of inherently compatible types.\n\nEach instance of the component is defined by a group of letters describing the input and output types.\nA comma separates individual instances of the component. For example \\fBloadrt bldc cfg=qi6,aH\\fR.\n\n.SH Tags\nInput type definitions are all lower-case.\n\n\\fBn\\fR No motor feedback. This mode could be used to drive AC induction motors,\nbut is also potentially useful for creating free-running motor simulators for drive testing.\n\n\\fBh\\fR Hall sensor input.\nBrushless DC motors (electronically commutated permanent magnet 3-phase motors) typically use a set of three Hall sensors to measure the angular position of the rotor.\nA lower-case \\fBh\\fR in the cfg string indicates that these should be used.\n\n\\fBa\\fR Absolute encoder input. (Also possibly used by some forms of Resolver conversion hardware).\nThe presence of this tag over-rides all other inputs.\nNote that the component still requires to be be connected to the \\fBrawcounts\\fR encoder pin to prevent loss of commutation on index-reset.\n\n\\fBq\\fR Incremental (quadrature) encoder input.\nIf this input is used then the rotor will need to be homed before the motor can be run.\n\n\\fBi\\fR Use the index of an incremental encoder as a home reference.\n\n\\fBf\\fR Use a 4-bit Gray-scale patttern to determine rotor alignment.\nThis scheme is only used on the Fanuc \"Red Cap\" motors.\nThis mode could be used to control one of these motors using a non-Fanuc drive.\n\nOutput type descriptions are all upper-case.\n\n\\fBDefaults\\fR The component will always calculate rotor angle, phase angle and the absolute value of the input \\fBvalue\\fR for interfacing with drives such as the Mesa 8I20.\nIt will also default to three individual, bipolar phase output values if no other output type modifiers are used.\n\n\\fBB\\fR Bit level outputs. Either 3 or 6 logic-level outputs indicating which high or low gate drivers on an external drive should be used.\n\n\\fB6\\fR Create 6 rather than the default 3 outputs.\nIn the case of numeric value outputs these are separate positive and negative drive amplitudes.\nBoth have positive magnitude.\n\n\\fBH\\fR Emulated Hall sensor output.\nThis mode can be used to control a drive which expects 3x Hall signals,\nor to convert between a motor with one hall pattern and a drive which expects a different one.\n\n\\fBF\\fR Emulated Fanuc Red Cap Gray-code encoder output.\nThis mode might be used to drive a non-Fanuc motor using a Fanuc drive intended for the \"Red-Cap\" motors.\n\n\\fBT\\fR Force Trapezoidal mode.\n\n.SH OPERATING MODES\nThe component can control a drive in either Trapezoidal or Sinusoidal mode, but will always default to sinusoidal if the input and output modes allow it.\nThis can be over-ridden by the \\fBT\\fR tag. Sinusoidal commutation is significantly smoother (trapezoidal commutation induces 13% torque ripple).\n\n.SH ROTOR HOMING.\nTo use an encoder for commutation a reference 0-degrees point must be found.\nThe component uses the convention that motor zero is the point that an unloaded\nmotor aligns to with a positive voltage on the A (or U) terminal and the B & C\n(or V and W) terminals connected together and to \\-ve voltage. There will be\ntwo such positions on a 4-pole motor, 3 on a 6-pole and so on. They are all\nfunctionally equivalent as far as driving the motor is concerned.\nIf the motor has Hall sensors then the motor can be started in trapezoidal\ncommutation mode, and will switch to sinusoidal commutation when an alignment is\nfound. If the mode is \\fBqh\\fR then the first Hall state-transition will be\nused. If the mode is \\fBqhi\\fR then the encoder index will be used. This\ngives a more accurate homing position if the distance in encoder counts between\nmotor zero and encoder index is known. To force homing to the Hall edges instead\nsimply omit the \\fBi\\fR.\n\nMotors without Hall sensors may be homed in synchronous/direct mode.\nThe better of these options is to home to the encoder zero using the \\fBiq\\fR\nconfig parameter. When the \\fBinit\\fR pin goes high the motor will rotate (in\na direction determined by the \\fBrev\\fR pin) until the encoder indicates an\nindex-latch (the servo thread runs too slowly to rely on detecting an encoder\nindex directly).\nIf there is no encoder index or its location relative to motor zero can not be\nfound, then an alternative is to use \\fImagnetic\\fR homing using the \\fBq\\fR\nconfig. In this mode the motor will go through an alignment sequence ending at\nmotor zero when the init pin goes high It will then set the final position as\nmotor zero. Unfortunately the motor is rather \\fIspringy\\fR in this mode and\nso alignment is likely to be fairly sensitive to load.\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Andy Pugh");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *hall1_p;
    hal_bit_t *hall2_p;
    hal_bit_t *hall3_p;
    hal_bit_t *hall_error_p;
    hal_bit_t *C1_p;
    hal_bit_t *C2_p;
    hal_bit_t *C4_p;
    hal_bit_t *C8_p;
    hal_float_t *value_p;
    hal_float_t *lead_angle_p;
    hal_bit_t *rev_p;
    hal_float_t *frequency_p;
    hal_float_t *initvalue_p;
    hal_s32_t *rawcounts_p;
    hal_bit_t *index_enable_p;
    hal_bit_t *init_p;
    hal_bit_t *init_done_p;
    hal_float_t *A_value_p;
    hal_float_t *B_value_p;
    hal_float_t *C_value_p;
    hal_bit_t *A_on_p;
    hal_bit_t *B_on_p;
    hal_bit_t *C_on_p;
    hal_float_t *A_high_p;
    hal_float_t *B_high_p;
    hal_float_t *C_high_p;
    hal_float_t *A_low_p;
    hal_float_t *B_low_p;
    hal_float_t *C_low_p;
    hal_bit_t *A_high_on_p;
    hal_bit_t *B_high_on_p;
    hal_bit_t *C_high_on_p;
    hal_bit_t *A_low_on_p;
    hal_bit_t *B_low_on_p;
    hal_bit_t *C_low_on_p;
    hal_bit_t *hall1_out_p;
    hal_bit_t *hall2_out_p;
    hal_bit_t *hall3_out_p;
    hal_bit_t *C1_out_p;
    hal_bit_t *C2_out_p;
    hal_bit_t *C4_out_p;
    hal_bit_t *C8_out_p;
    hal_float_t *phase_angle_p;
    hal_float_t *rotor_angle_p;
    hal_float_t *out_p;
    hal_bit_t *out_dir_p;
    hal_float_t *out_abs_p;
    hal_s32_t in_type_p;
    hal_s32_t out_type_p;
    hal_s32_t scale_p;
    hal_s32_t poles_p;
    hal_s32_t encoder_offset_p;
    hal_s32_t offset_measured_p;
    hal_float_t drive_offset_p;
    hal_u32_t output_pattern_p;
    hal_u32_t pattern_p;
    int old_init_p;

    char old_ph_p;

    int old_pattern_p;

    double counter_p;

    rtapi_s64 long_rawcounts_p;

    rtapi_s64 old_long_rawcounts_p;

    rtapi_s32 old_rawcounts_p;

    int force_trap_p;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    personality = inst->_personality;
if(personality & 0x01) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->hall1_p), comp_id,
        "%s.hall1", prefix);
    if(r != 0) return r;
}
if(personality & 0x01) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->hall2_p), comp_id,
        "%s.hall2", prefix);
    if(r != 0) return r;
}
if(personality & 0x01) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->hall3_p), comp_id,
        "%s.hall3", prefix);
    if(r != 0) return r;
}
if(personality & 0x01) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->hall_error_p), comp_id,
        "%s.hall-error", prefix);
    if(r != 0) return r;
}
if(( personality & 0x10 )) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->C1_p), comp_id,
        "%s.C1", prefix);
    if(r != 0) return r;
}
if(( personality & 0x10 )) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->C2_p), comp_id,
        "%s.C2", prefix);
    if(r != 0) return r;
}
if(( personality & 0x10 )) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->C4_p), comp_id,
        "%s.C4", prefix);
    if(r != 0) return r;
}
if(( personality & 0x10 )) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->C8_p), comp_id,
        "%s.C8", prefix);
    if(r != 0) return r;
}
    r = hal_pin_float_newf(HAL_IN, &(inst->value_p), comp_id,
        "%s.value", prefix);
    if(r != 0) return r;
if(personality & 0x06) {
    r = hal_pin_float_newf(HAL_IN, &(inst->lead_angle_p), comp_id,
        "%s.lead-angle", prefix);
    if(r != 0) return r;
    *(inst->lead_angle_p) = 90;
}
    r = hal_pin_bit_newf(HAL_IN, &(inst->rev_p), comp_id,
        "%s.rev", prefix);
    if(r != 0) return r;
if(( personality & 0x0F ) == 0) {
    r = hal_pin_float_newf(HAL_IN, &(inst->frequency_p), comp_id,
        "%s.frequency", prefix);
    if(r != 0) return r;
}
if(personality & 0x04) {
    r = hal_pin_float_newf(HAL_IN, &(inst->initvalue_p), comp_id,
        "%s.initvalue", prefix);
    if(r != 0) return r;
    *(inst->initvalue_p) = 0.2;
}
if(personality & 0x06) {
    r = hal_pin_s32_newf(HAL_IN, &(inst->rawcounts_p), comp_id,
        "%s.rawcounts", prefix);
    if(r != 0) return r;
    *(inst->rawcounts_p) = 0;
}
if(personality & 0x08) {
    r = hal_pin_bit_newf(HAL_IO, &(inst->index_enable_p), comp_id,
        "%s.index-enable", prefix);
    if(r != 0) return r;
}
if(( personality & 0x05 ) == 4) {
    r = hal_pin_bit_newf(HAL_IN, &(inst->init_p), comp_id,
        "%s.init", prefix);
    if(r != 0) return r;
}
if(( personality & 0x05 ) == 4) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->init_done_p), comp_id,
        "%s.init-done", prefix);
    if(r != 0) return r;
    *(inst->init_done_p) = 0;
}
if(( personality & 0xF00 ) == 0) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->A_value_p), comp_id,
        "%s.A-value", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->B_value_p), comp_id,
        "%s.B-value", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->C_value_p), comp_id,
        "%s.C-value", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x100) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->A_on_p), comp_id,
        "%s.A-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x100) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->B_on_p), comp_id,
        "%s.B-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x100) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C_on_p), comp_id,
        "%s.C-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->A_high_p), comp_id,
        "%s.A-high", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->B_high_p), comp_id,
        "%s.B-high", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->C_high_p), comp_id,
        "%s.C-high", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->A_low_p), comp_id,
        "%s.A-low", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->B_low_p), comp_id,
        "%s.B-low", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x200) {
    r = hal_pin_float_newf(HAL_OUT, &(inst->C_low_p), comp_id,
        "%s.C-low", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->A_high_on_p), comp_id,
        "%s.A-high-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->B_high_on_p), comp_id,
        "%s.B-high-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C_high_on_p), comp_id,
        "%s.C-high-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->A_low_on_p), comp_id,
        "%s.A-low-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->B_low_on_p), comp_id,
        "%s.B-low-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0xF00 ) == 0x300) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C_low_on_p), comp_id,
        "%s.C-low-on", prefix);
    if(r != 0) return r;
}
if(( personality & 0x400 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->hall1_out_p), comp_id,
        "%s.hall1-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x400 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->hall2_out_p), comp_id,
        "%s.hall2-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x400 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->hall3_out_p), comp_id,
        "%s.hall3-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x800 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C1_out_p), comp_id,
        "%s.C1-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x800 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C2_out_p), comp_id,
        "%s.C2-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x800 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C4_out_p), comp_id,
        "%s.C4-out", prefix);
    if(r != 0) return r;
}
if(( personality & 0x800 )) {
    r = hal_pin_bit_newf(HAL_OUT, &(inst->C8_out_p), comp_id,
        "%s.C8-out", prefix);
    if(r != 0) return r;
}
    r = hal_pin_float_newf(HAL_OUT, &(inst->phase_angle_p), comp_id,
        "%s.phase-angle", prefix);
    if(r != 0) return r;
    *(inst->phase_angle_p) = 0;
    r = hal_pin_float_newf(HAL_OUT, &(inst->rotor_angle_p), comp_id,
        "%s.rotor-angle", prefix);
    if(r != 0) return r;
    *(inst->rotor_angle_p) = 0;
    r = hal_pin_float_newf(HAL_OUT, &(inst->out_p), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->out_dir_p), comp_id,
        "%s.out-dir", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->out_abs_p), comp_id,
        "%s.out-abs", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->in_type_p), comp_id,
        "%s.in-type", prefix);
    inst->in_type_p = -1;
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RO, &(inst->out_type_p), comp_id,
        "%s.out-type", prefix);
    inst->out_type_p = -1;
    if(r != 0) return r;
if(personality & 0x06) {
    r = hal_param_s32_newf(HAL_RW, &(inst->scale_p), comp_id,
        "%s.scale", prefix);
    inst->scale_p = 512;
    if(r != 0) return r;
}
if(personality & 0x06) {
    r = hal_param_s32_newf(HAL_RW, &(inst->poles_p), comp_id,
        "%s.poles", prefix);
    inst->poles_p = 4;
    if(r != 0) return r;
}
if(personality & 0x0A) {
    r = hal_param_s32_newf(HAL_RW, &(inst->encoder_offset_p), comp_id,
        "%s.encoder-offset", prefix);
    inst->encoder_offset_p = 0;
    if(r != 0) return r;
}
if(personality & 0x04) {
    r = hal_param_s32_newf(HAL_RO, &(inst->offset_measured_p), comp_id,
        "%s.offset-measured", prefix);
    inst->offset_measured_p = 0;
    if(r != 0) return r;
}
    r = hal_param_float_newf(HAL_RW, &(inst->drive_offset_p), comp_id,
        "%s.drive-offset", prefix);
    inst->drive_offset_p = 0;
    if(r != 0) return r;
if(personality & 0x400) {
    r = hal_param_u32_newf(HAL_RW, &(inst->output_pattern_p), comp_id,
        "%s.output-pattern", prefix);
    inst->output_pattern_p = 25;
    if(r != 0) return r;
}
if(personality & 0x01) {
    r = hal_param_u32_newf(HAL_RW, &(inst->pattern_p), comp_id,
        "%s.pattern", prefix);
    inst->pattern_p = 25;
    if(r != 0) return r;
}
    inst->old_init_p = 0.0;
    inst->old_ph_p = 0.0;
    inst->old_pattern_p = -1.0;
    inst->counter_p = 0.0;
    inst->long_rawcounts_p = 0.0;
    inst->old_long_rawcounts_p = 0.0;
    inst->old_rawcounts_p = 0.0;
    inst->force_trap_p = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int get_count(void);
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each bldc");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    int count = get_count();
    comp_id = hal_init("bldc");
    if(comp_id < 0) return comp_id;
    for(i=0; i<count; i++) {
        char buf[HAL_NAME_LEN + 1];
        rtapi_snprintf(buf, sizeof(buf), "bldc.%d", i);
        r = export(buf, i, p_value("bldc", buf, i) );
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef hall1
#undef hall1_ptr
#define hall1_ptr (__comp_inst->hall1_p)
#define hall1 (0+*__comp_inst->hall1_p)
#undef hall2
#undef hall2_ptr
#define hall2_ptr (__comp_inst->hall2_p)
#define hall2 (0+*__comp_inst->hall2_p)
#undef hall3
#undef hall3_ptr
#define hall3_ptr (__comp_inst->hall3_p)
#define hall3 (0+*__comp_inst->hall3_p)
#undef hall_error
#undef hall_error_ptr
#define hall_error_ptr (__comp_inst->hall_error_p)
#define hall_error (*__comp_inst->hall_error_p)
#undef C1
#undef C1_ptr
#define C1_ptr (__comp_inst->C1_p)
#define C1 (0+*__comp_inst->C1_p)
#undef C2
#undef C2_ptr
#define C2_ptr (__comp_inst->C2_p)
#define C2 (0+*__comp_inst->C2_p)
#undef C4
#undef C4_ptr
#define C4_ptr (__comp_inst->C4_p)
#define C4 (0+*__comp_inst->C4_p)
#undef C8
#undef C8_ptr
#define C8_ptr (__comp_inst->C8_p)
#define C8 (0+*__comp_inst->C8_p)
#undef value
#undef value_ptr
#define value_ptr (__comp_inst->value_p)
#define value (0+*__comp_inst->value_p)
#undef lead_angle
#undef lead_angle_ptr
#define lead_angle_ptr (__comp_inst->lead_angle_p)
#define lead_angle (0+*__comp_inst->lead_angle_p)
#undef rev
#undef rev_ptr
#define rev_ptr (__comp_inst->rev_p)
#define rev (0+*__comp_inst->rev_p)
#undef frequency
#undef frequency_ptr
#define frequency_ptr (__comp_inst->frequency_p)
#define frequency (0+*__comp_inst->frequency_p)
#undef initvalue
#undef initvalue_ptr
#define initvalue_ptr (__comp_inst->initvalue_p)
#define initvalue (0+*__comp_inst->initvalue_p)
#undef rawcounts
#undef rawcounts_ptr
#define rawcounts_ptr (__comp_inst->rawcounts_p)
#define rawcounts (0+*__comp_inst->rawcounts_p)
#undef index_enable
#undef index_enable_ptr
#define index_enable_ptr (__comp_inst->index_enable_p)
#define index_enable (*__comp_inst->index_enable_p)
#undef init
#undef init_ptr
#define init_ptr (__comp_inst->init_p)
#define init (0+*__comp_inst->init_p)
#undef init_done
#undef init_done_ptr
#define init_done_ptr (__comp_inst->init_done_p)
#define init_done (*__comp_inst->init_done_p)
#undef A_value
#undef A_value_ptr
#define A_value_ptr (__comp_inst->A_value_p)
#define A_value (*__comp_inst->A_value_p)
#undef B_value
#undef B_value_ptr
#define B_value_ptr (__comp_inst->B_value_p)
#define B_value (*__comp_inst->B_value_p)
#undef C_value
#undef C_value_ptr
#define C_value_ptr (__comp_inst->C_value_p)
#define C_value (*__comp_inst->C_value_p)
#undef A_on
#undef A_on_ptr
#define A_on_ptr (__comp_inst->A_on_p)
#define A_on (*__comp_inst->A_on_p)
#undef B_on
#undef B_on_ptr
#define B_on_ptr (__comp_inst->B_on_p)
#define B_on (*__comp_inst->B_on_p)
#undef C_on
#undef C_on_ptr
#define C_on_ptr (__comp_inst->C_on_p)
#define C_on (*__comp_inst->C_on_p)
#undef A_high
#undef A_high_ptr
#define A_high_ptr (__comp_inst->A_high_p)
#define A_high (*__comp_inst->A_high_p)
#undef B_high
#undef B_high_ptr
#define B_high_ptr (__comp_inst->B_high_p)
#define B_high (*__comp_inst->B_high_p)
#undef C_high
#undef C_high_ptr
#define C_high_ptr (__comp_inst->C_high_p)
#define C_high (*__comp_inst->C_high_p)
#undef A_low
#undef A_low_ptr
#define A_low_ptr (__comp_inst->A_low_p)
#define A_low (*__comp_inst->A_low_p)
#undef B_low
#undef B_low_ptr
#define B_low_ptr (__comp_inst->B_low_p)
#define B_low (*__comp_inst->B_low_p)
#undef C_low
#undef C_low_ptr
#define C_low_ptr (__comp_inst->C_low_p)
#define C_low (*__comp_inst->C_low_p)
#undef A_high_on
#undef A_high_on_ptr
#define A_high_on_ptr (__comp_inst->A_high_on_p)
#define A_high_on (*__comp_inst->A_high_on_p)
#undef B_high_on
#undef B_high_on_ptr
#define B_high_on_ptr (__comp_inst->B_high_on_p)
#define B_high_on (*__comp_inst->B_high_on_p)
#undef C_high_on
#undef C_high_on_ptr
#define C_high_on_ptr (__comp_inst->C_high_on_p)
#define C_high_on (*__comp_inst->C_high_on_p)
#undef A_low_on
#undef A_low_on_ptr
#define A_low_on_ptr (__comp_inst->A_low_on_p)
#define A_low_on (*__comp_inst->A_low_on_p)
#undef B_low_on
#undef B_low_on_ptr
#define B_low_on_ptr (__comp_inst->B_low_on_p)
#define B_low_on (*__comp_inst->B_low_on_p)
#undef C_low_on
#undef C_low_on_ptr
#define C_low_on_ptr (__comp_inst->C_low_on_p)
#define C_low_on (*__comp_inst->C_low_on_p)
#undef hall1_out
#undef hall1_out_ptr
#define hall1_out_ptr (__comp_inst->hall1_out_p)
#define hall1_out (*__comp_inst->hall1_out_p)
#undef hall2_out
#undef hall2_out_ptr
#define hall2_out_ptr (__comp_inst->hall2_out_p)
#define hall2_out (*__comp_inst->hall2_out_p)
#undef hall3_out
#undef hall3_out_ptr
#define hall3_out_ptr (__comp_inst->hall3_out_p)
#define hall3_out (*__comp_inst->hall3_out_p)
#undef C1_out
#undef C1_out_ptr
#define C1_out_ptr (__comp_inst->C1_out_p)
#define C1_out (*__comp_inst->C1_out_p)
#undef C2_out
#undef C2_out_ptr
#define C2_out_ptr (__comp_inst->C2_out_p)
#define C2_out (*__comp_inst->C2_out_p)
#undef C4_out
#undef C4_out_ptr
#define C4_out_ptr (__comp_inst->C4_out_p)
#define C4_out (*__comp_inst->C4_out_p)
#undef C8_out
#undef C8_out_ptr
#define C8_out_ptr (__comp_inst->C8_out_p)
#define C8_out (*__comp_inst->C8_out_p)
#undef phase_angle
#undef phase_angle_ptr
#define phase_angle_ptr (__comp_inst->phase_angle_p)
#define phase_angle (*__comp_inst->phase_angle_p)
#undef rotor_angle
#undef rotor_angle_ptr
#define rotor_angle_ptr (__comp_inst->rotor_angle_p)
#define rotor_angle (*__comp_inst->rotor_angle_p)
#undef out
#undef out_ptr
#define out_ptr (__comp_inst->out_p)
#define out (*__comp_inst->out_p)
#undef out_dir
#undef out_dir_ptr
#define out_dir_ptr (__comp_inst->out_dir_p)
#define out_dir (*__comp_inst->out_dir_p)
#undef out_abs
#undef out_abs_ptr
#define out_abs_ptr (__comp_inst->out_abs_p)
#define out_abs (*__comp_inst->out_abs_p)
#undef in_type
#define in_type (__comp_inst->in_type_p)
#undef out_type
#define out_type (__comp_inst->out_type_p)
#undef scale
#define scale (__comp_inst->scale_p)
#undef poles
#define poles (__comp_inst->poles_p)
#undef encoder_offset
#define encoder_offset (__comp_inst->encoder_offset_p)
#undef offset_measured
#define offset_measured (__comp_inst->offset_measured_p)
#undef drive_offset
#define drive_offset (__comp_inst->drive_offset_p)
#undef output_pattern
#define output_pattern (__comp_inst->output_pattern_p)
#undef pattern
#define pattern (__comp_inst->pattern_p)
#undef old_init
#define old_init (__comp_inst->old_init_p)
#undef old_ph
#define old_ph (__comp_inst->old_ph_p)
#undef old_pattern
#define old_pattern (__comp_inst->old_pattern_p)
#undef counter
#define counter (__comp_inst->counter_p)
#undef long_rawcounts
#define long_rawcounts (__comp_inst->long_rawcounts_p)
#undef old_long_rawcounts
#define old_long_rawcounts (__comp_inst->old_long_rawcounts_p)
#undef old_rawcounts
#define old_rawcounts (__comp_inst->old_rawcounts_p)
#undef force_trap
#define force_trap (__comp_inst->force_trap_p)
#undef personality
#define personality (__comp_inst->_personality)


#line 360 "/home/end/projects/linuxcnc/src/hal/components/bldc.comp"

#include <rtapi_math.h>
#define MAX_CHAN 8
#define NUM_TAG 8

static char *cfg[NUM_TAG];
RTAPI_MP_ARRAY_STRING(cfg, MAX_CHAN, "Description of each motor");

/*dir H1 H2 H3 pattern
000  001  010  011  100  101  110  111 */
static unsigned int P[]={
024, 014, 000, 012, 021, 000, 041, 042,
014, 024, 012, 000, 000, 021, 042, 041,
024, 000, 014, 012, 021, 041, 000, 042,
000, 024, 012, 014, 041, 021, 042, 000,
000, 012, 024, 014, 041, 042, 021, 000,
012, 000, 014, 024, 042, 041, 000, 021,
014, 012, 024, 000, 000, 042, 021, 041,
012, 014, 000, 024, 042, 000, 041, 021,
024, 014, 021, 000, 000, 012, 041, 042,
014, 024, 000, 021, 012, 000, 042, 041,
024, 021, 014, 000, 000, 041, 012, 042,
021, 024, 000, 014, 041, 000, 042, 012,
021, 000, 024, 014, 041, 042, 000, 012,
000, 021, 014, 024, 042, 041, 012, 000,
014, 000, 024, 021, 012, 042, 000, 041,
000, 014, 021, 024, 042, 012, 041, 000,
024, 000, 021, 041, 014, 012, 000, 042,
000, 024, 041, 021, 012, 014, 042, 000,
024, 021, 000, 041, 014, 000, 012, 042,
021, 024, 041, 000, 000, 014, 042, 012,
021, 041, 024, 000, 000, 042, 014, 012,
041, 021, 000, 024, 042, 000, 012, 014,
000, 041, 024, 021, 012, 042, 014, 000,
041, 000, 021, 024, 042, 012, 000, 014,
021, 000, 041, 042, 024, 014, 000, 012,
000, 021, 042, 041, 014, 024, 012, 000,
021, 041, 000, 042, 024, 000, 014, 012,
041, 021, 042, 000, 000, 024, 012, 014,
041, 042, 021, 000, 000, 012, 024, 014,
042, 041, 000, 021, 012, 000, 014, 024,
000, 042, 021, 041, 014, 012, 024, 000,
042, 000, 041, 021, 012, 014, 000, 024,
000, 012, 041, 042, 024, 014, 021, 000,
012, 000, 042, 041, 014, 024, 000, 021,
000, 041, 012, 042, 024, 021, 014, 000,
041, 000, 042, 012, 021, 024, 000, 014,
041, 042, 000, 012, 021, 000, 024, 014,
042, 041, 012, 000, 000, 021, 014, 024,
012, 042, 000, 041, 014, 000, 024, 021,
042, 012, 041, 000, 000, 014, 021, 024,
014, 012, 000, 042, 024, 000, 021, 041,
012, 014, 042, 000, 000, 024, 041, 021,
014, 000, 012, 042, 024, 021, 000, 041,
000, 014, 042, 012, 021, 024, 041, 000,
000, 042, 014, 012, 021, 041, 024, 000,
042, 000, 012, 014, 041, 021, 000, 024,
012, 042, 014, 000, 000, 041, 024, 021,
042, 012, 000, 014, 041, 000, 021, 024};

int phases[] =   {021,   024,   014,    012,    042,    041,    021,    024   };
double angles[] = {0.0/36,6.0/36,12.0/36,18.0/36,24.0/36,30.0/36,36.0/36,42.0/36};
int gray_b[] = {000, 001, 003, 002, 006, 007, 005, 004, 014, 015, 017, 016, 012,
                013, 011, 010, 000};
double gray_a[] = {0.0, 0.0625, 0.125, 0.1875, 0.25, 0.3125, 0.375, 0.4375, 0.5,
                   0.5625, 0.625, 0.6875, 0.75, 0.8125, 0.875, 0.9375, 1.0};

const double pi2 = 6.283185307179586;
const double cos120 = -0.5;
const double sin120 = 0.8660254037844386;
const double absc[] = {2.4, 2.0, 1.2, 0.8, 0.4, 0.0}; // Alignment sequence def
const double V_a[] = {0, 1, 1, 1, 1, 1};
const double th_a[] = {0, 0, -.25, .25, 0, 0};

FUNCTION(_) {
    int i;
    double V;
    double lead;
    double sintheta, costheta;
    long long lagcomped_counts;
    char ph;
    int trap = -1; // Flag for sinusoidal/trapezoidal output

    if (rev) V = -value;
    else V = value;
    out_dir = (V < 0);
    out_abs = fabs(V);
    // Would expect to set "out" here too, but some modes need to over-ride it.

    if ((personality & 0x05) == 4){
        if (init && !old_init && init_done) {
            init_done = 0;
            in_type = -1;
        }
        else {
            old_init = init;
        }
    }

    if (personality & 0x06) {
        // Handle s32 rollover of rawcounts
        old_long_rawcounts = long_rawcounts;
        long_rawcounts += (rawcounts-old_rawcounts);
        old_rawcounts = rawcounts;
    }

    trap = 0;

    switch(in_type){
        case -2: // Error type, simply to suppress error messages
            return;
        case -1: // Initialisation
            in_type = personality & 0xFF;
            if (in_type & 0x08) index_enable = 1;
            counter = absc[0];
            out_type = personality & 0x7F00;
            force_trap = (personality & 0x8000);
            return;

        case 0x00: // Dumb VFD mode, just set the angle with no feedback
            phase_angle += (frequency * period / 1000000000.0);
            phase_angle -= floor(phase_angle);
            rotor_angle = phase_angle;
            break;

        case 0x01: // Trapezoidal Hall Commutation.
        case 0x05: // incremental encoder homing to hall transition
        case 0x0D:// incremental encoder homing to index

            trap = 1;

            if (pattern > 47){
                rtapi_print_msg(RTAPI_MSG_ERR,
                                "Only `Hall patterns 0-47 are allowed, you have"
                                " requested pattern %i\n", pattern);
                pattern = 0;
                return;
            }

            i  = (pattern << 3) + ((hall1 != 0) << 2) 
                    + ((hall2 != 0) << 1) + (hall3 != 0);
            ph = P[i];

            // calculate angle. This looks at transitions between motor field
            // excitation patterns to remove the effect of different hall patterns.
            // As the phase pattern at this point corresponds to that which is
            // required for forwards rotation, it provides a way to infer rotor
            // position. The fixed 90 degree Hall offset is incorporated in the
            // angle lookup table.

            for (i = 0 ; phases[i] != ph && i<8 ; i++) {}
            rotor_angle = angles[i];
            rotor_angle -= floor(rotor_angle);
            if (out_dir) phase_angle = rotor_angle + 0.25;
            else phase_angle = rotor_angle - 0.25;
            phase_angle -= floor(phase_angle);
            
            if (! (ph & old_ph)){ hall_error = 1;}
            if (pattern != old_pattern){hall_error = 0;}

            if (force_trap) break;

            if (in_type == 0x05 && old_ph && ph != old_ph) { // Homing to hall edges
                for (i = 1 ; phases[i] != ph && i<8 ; i++) {}
                if (phases[i - 1] == old_ph) {
                    rotor_angle = (angles[i] + angles[i - 1])/2;}
                else{
                    rotor_angle = (angles[i] + angles[i + 1])/2;
                }
                rotor_angle -= floor(rotor_angle);
                if (out_dir) phase_angle = rotor_angle - 0.25;
                else phase_angle = rotor_angle + 0.25;
                phase_angle -= floor(phase_angle);
                offset_measured = long_rawcounts - rotor_angle * ( 2 * scale/poles);
                // And now we are homed, switch to sinusoidal drive
                in_type = 0x02;
            }
            else if (in_type == 0x0D) { // homing to encoder index
                if (!index_enable){ // index has reset
                    offset_measured = long_rawcounts;
                    in_type = 0x02;
                }
            }
            old_ph = ph;
            old_pattern = pattern;
            break;

        case 0x10: // Fanuc-style Gray-code input
        case 0x14: // incremental encoder homing to gray-code transition
        case 0x1C: // incremental encoder homing to index.
            ph = (C1 != 0) | ((C2 != 0) << 1) 
                    | ((C4 != 0) << 2) | ((C8 != 0) << 3);

            for (i = 0 ; gray_b[i] != ph && i<16 ; i++) {}
            rotor_angle = gray_a[i] + 0.03125;
            rotor_angle -= floor(rotor_angle);
            if (out_dir) phase_angle = rotor_angle - 0.25;
            else phase_angle = rotor_angle + 0.25;
            phase_angle -= floor(phase_angle);

            if (force_trap) break;

            if (in_type == 0x14 && old_ph && ph != old_ph) { // Homing to Gray edges
                for (i = 1 ; gray_b[i] != ph && i<15 ; i++) {}
                if (phases[i - 1] == old_ph) {
                    rotor_angle = gray_a[i];
                }
                else{
                    rotor_angle = gray_a[i + 1];
                }
                rotor_angle -= floor(rotor_angle);
                if (out_dir) phase_angle = rotor_angle - 0.25;
                else phase_angle = rotor_angle + 0.25;
                phase_angle -= floor(phase_angle);
                offset_measured = long_rawcounts - rotor_angle * ( 2 * scale/poles);
                // And now we are homed, switch to sinusoidal drive
                in_type = 0x02;
            }
            else if (in_type == 0x1C) { // homing to encoder index
                if (!index_enable){ // index has reset
                    offset_measured = long_rawcounts;
                    in_type = 0x02;
                }
            }
            old_ph = ph;

            break;

         case 0x04: // Incremental encoder homing "magnetically"

            if (! init) {
                V = 0;
                return;
            }
            if (! init_done) {
                if (counter <= 0) {
                    offset_measured = long_rawcounts - phase_angle * ( 2 * scale/poles);
                    counter = absc[0];
                    old_init = 1;
                    init_done = 1;
                    in_type = 0x02; // switch to sinusoidal commutation
                    return;
                }
                init_done = 0;
                for (i = 0 ; absc[i] >= counter && i < 6 ; i++ ) {}
                V = initvalue * (V_a[i-1] + (V_a[i] - V_a[i-1])
                                   * (counter - absc[i-1]) / (absc[i] - absc[i-1]));
                phase_angle = (th_a[i-1] + (th_a[i] - th_a[i-1])
                               * (counter - absc[i-1]) / (absc[i] - absc[i-1]));
                phase_angle -= floor(phase_angle);
                counter -= fperiod;
                rotor_angle = phase_angle - (drive_offset/360.0);
                rotor_angle -= floor(rotor_angle);
            }
            else {
                rtapi_print_msg(RTAPI_MSG_ERR, "An error has occurred in the "
                                "bldc homing sequence. Init done without state");
                return;}
            break;

        case 0x0C: // Incremental encoder homing to index.
            if (! init) return;
            if (!index_enable){ // index has reset
                offset_measured = long_rawcounts;
                counter = absc[0];
                old_init = 1;
                init_done = 1;
                in_type = 0x02;
                break;
            }
            if (! init_done){
                if (initvalue < 0) rotor_angle -= period / 1000000000.0;
                    else rotor_angle += period / 1000000000.0;
                rotor_angle -= floor(rotor_angle);
                phase_angle = rotor_angle;
                V = fabs(initvalue);
            }
            break;

        case 0x02: // Sinusoidal Commutation, homed or absolute
            if (out_dir && !force_trap) {
                lead = lead_angle / -360.0;
            } else {
                lead = lead_angle / 360.0;
            }
            lagcomped_counts = long_rawcounts + ((long_rawcounts - old_long_rawcounts)/2);
            rotor_angle = (double)((lagcomped_counts - offset_measured 
                                    - encoder_offset)* poles/2)/scale;
            rotor_angle -= floor(rotor_angle);
            phase_angle = rotor_angle + lead;
            phase_angle -= floor(phase_angle);
            break;

        case 0x03:
        case 0x0B:
            rtapi_print_msg(RTAPI_MSG_ERR, "Both Hall Sensors and Absolute "
                            "encoder specified on the same motor. Only the"
                            "Encoder will be used\n");
            in_type = 0x02;
            return;
        case 0x06:
        case 0x07:
        case 0x0E:
        case 0x0F:
            rtapi_print_msg(RTAPI_MSG_ERR, "Specifying the use of both absolute "
                            "and incremental encoders on the same motor is an "
                             "error. Motor disabled\n");
            in_type = -2;
            return;
        case 0x08:
            rtapi_print_msg(RTAPI_MSG_ERR, "Driving an electronically commutated"
                            "motor with only an index for feedback is not"
                            "possible. Motor Disabled\n" );
            in_type = -2;
            return;
        case 0x09:
            rtapi_print_msg(RTAPI_MSG_ERR, "The use of an encoder Index with "
                            "Hall sensors is not supported. Defaulting to "
                            "trapezoidal commutation\n");
            in_type = 0x01;
            return;
        case 0x0A:
            rtapi_print_msg(RTAPI_MSG_ERR, "Index is not needed with an Absolute"
                            "encoder and will be ignored\n");
            in_type = 0x02;
            return;
        default:
        rtapi_print_msg(RTAPI_MSG_ERR, "Unknown input type pattern (%X) in "
                        "bldc\n", in_type);
            in_type = -2;
        return;
    }

/**************************************************************
     Now calculate the output values
***************************************************************/

    // equivalent trapezoidal pattern for non-hall types
    if (!trap){
        for (i = 0 ; rotor_angle > angles[i] - 3.0/36 && i < 8 ; i++) {}
        ph = phases[i];
    }

    if (force_trap) {trap = 1;} // forced trapezoidal mode

    out = V;
    out_abs = fabs(V);

    switch (out_type){
        case 0: // Default; 3-wire sinusoidal or trapezoidal
            if (trap){
                if (ph & 040) A_value =V;
                else if (ph & 004) A_value = -V;
                else A_value = 0;

                if (ph & 020) B_value = V;
                else if (ph & 002) B_value = -V;
                else B_value = 0;

                if (ph & 010) C_value = V;
                else if (ph & 001) C_value = -V;
                else C_value = 0;
            }
            else
            {
                sintheta = sin(phase_angle * pi2);
                costheta = cos(phase_angle * pi2);
                A_value = out_abs * costheta;
                B_value = out_abs * (costheta * cos120 + sintheta * sin120);
                C_value = out_abs * (costheta * cos120 - sintheta * sin120);
            }
            return;

        case 0x100: // bit outputs, 3-wire. Dubious utility
            if (out_dir){ ph = (ph & 070) >> 3 | (ph & 007) << 3;}
            if      (ph & 040) {A_on = 1;}
            else if (ph & 020) {B_on = 1;}
            else if (ph & 010) {C_on = 1;}
            else               {A_on = 0 ; B_on = 0 ; C_on = 0;}
            if      (ph & 004) {A_on = 0;}
            else if (ph & 002) {B_on = 0;}
            else if (ph & 001) {C_on = 0;}
            else               {A_on = 0 ; B_on = 0 ; C_on = 0;}
            return;

        case 0x200: // 6-wire modes
            if (trap){
                if (out_dir){ ph = (ph & 070) >> 3 | (ph & 007) << 3;}
                if (ph & 040) { A_high = out_abs; A_low = 0;}
                else if (ph & 004) {A_high = 0; A_low = out_abs;}
                else {A_high = 0; A_low = 0;}

                if (ph & 020) {B_high = out_abs; B_low = 0;}
                else if (ph & 002) {B_high = 0; B_low = out_abs;}
                else {B_high = 0; B_low = 0;}

                if (ph & 010) {C_high = out_abs; C_low = 0;}
                else if (ph & 001) {C_high = 0; C_low = out_abs;}
                else {C_high = 0; C_low=0;}
            }
            else
            {
                sintheta = sin(phase_angle * pi2);
                costheta = cos(phase_angle * pi2);
                if (costheta >=0){
                    A_high = out_abs * costheta; A_low = 0;}
                else {
                    A_high = 0; A_low = -out_abs * costheta;}

                if ((costheta * cos120 + sintheta * sin120) >= 0){
                    B_high = out_abs * (costheta * cos120 + sintheta * sin120);
                    B_low = 0;}
                else {
                    B_high = 0;
                    B_low = -out_abs * (costheta * cos120 + sintheta * sin120);}

                if ((costheta * cos120 - sintheta * sin120) >= 0) {
                    C_high = out_abs * (costheta * cos120 - sintheta * sin120);
                    C_low = 0;}
                else {
                    C_high = 0;
                    C_low = -out_abs * (costheta * cos120 - sintheta * sin120);}
            }
            return;
        case 0x300: // 6-wire bit mode
            if (out_dir) {
                A_high_on = (ph & 004) ; A_low_on = (ph & 040);
                B_high_on = (ph & 002) ; B_low_on = (ph & 020);
                C_high_on = (ph & 001) ; C_low_on = (ph & 010);

            }
            else
            {
                A_high_on = (ph & 040) ; A_low_on = (ph & 004);
                B_high_on = (ph & 020) ; B_low_on = (ph & 002);
                C_high_on = (ph & 010) ; C_low_on = (ph & 001);
            }
            return;

        case 0x400: // Hall Output
            for (i = 0; P[(output_pattern << 3) + i] != ph && i < 8 ; i++) {}
            hall1_out = (i & 0x04);
            hall2_out = (i & 0x02);
            hall3_out = (i & 0x01);
            return;

        case 0x800: // Fanuc Red Cap style Gray-Code emulation
            for (i = 0; (gray_a[i] + 0.0625) < rotor_angle && i < 16 ; i++) {}
            C1_out = (gray_b[i] & 001);
            C2_out = (gray_b[i] & 002);
            C4_out = (gray_b[i] & 004);
            C8_out = (gray_b[i] & 010);
            return;

        case 0x500:
            rtapi_print_msg(RTAPI_MSG_ERR, "Combinations of Hall Pattern and Bit"
                            " outputs are not supported. Defaulting to Hall");
            out_type = 0x400;
            return;
        case 0x600:
            rtapi_print_msg(RTAPI_MSG_ERR, "6-Wire Hall patterns outputs are "
                            "not supported. Defaulting to 3-wire");
            out_type = 0x400;
            return;
        case 0x700:
            rtapi_print_msg(RTAPI_MSG_ERR, "6-wire combinations of Hall and Bit"
                            " outputs can't be supported. Defaulting to 3-wire"
                            " Hall pattern");
            out_type = 0x400;
            return;
        case 0x900:
        case 0xB00:
        case 0xA00:
            rtapi_print_msg(RTAPI_MSG_ERR, "Combinations of bit level and "
                            " Gray Code outputs are not supported. Defaulting"
                            " to Gray Code");
            out_type = 0x800;
            return;
        case 0xC00:
            rtapi_print_msg(RTAPI_MSG_ERR, "Hall Sensor and Gray-code outputs"
                            " can not be combined. defaulting to Hall");
            out_type = 0x400;
            return;
        default:
            rtapi_print_msg(RTAPI_MSG_ERR, "Unsupported output type (%X) in bldc"
                            , out_type);
            in_type = -2;
            return;
    }
}

EXTRA_SETUP(){
    int i;
    char c;
    for (i = 0; cfg[extra_arg][i] != 0 && i < NUM_TAG ; i++){
        c = cfg[extra_arg][i];
        if (c == 'h') personality |= 0x01;
        if (c == 'a') personality |= 0x02;
        if (c == 'q') personality |= 0x04;
        if (c == 'i') personality |= 0x08;
        if (c == 'f') personality |= 0x10;
        if (c == 'B') personality |= 0x0100;
        if (c == '6') personality |= 0x0200;
        if (c == 'H') personality |= 0x0400;
        if (c == 'F') personality |= 0x0800;
        if (c == 'T') personality |= 0x8000;
    }
    return 0;
}

int get_count(void){
    int i;

    for (i=0; cfg[i] != NULL && i < MAX_CHAN; i++){}
    if (i == 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "The bldc component needs at least one "
                    "feedback type tag.\nValid tags are h, a, q, i, b, 6, n\n" );
        return 0;
    }
    return i;
}

static int __comp_get_data_size(void) { return 0; }
